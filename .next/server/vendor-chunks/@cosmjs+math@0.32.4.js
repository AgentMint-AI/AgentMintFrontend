"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@cosmjs+math@0.32.4";
exports.ids = ["vendor-chunks/@cosmjs+math@0.32.4"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/decimal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/decimal.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Decimal = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\n// Too large values lead to massive memory usage. Limit to something sensible.\n// The largest value we need is 18 (Ether).\nconst maxFractionalDigits = 100;\n/**\n * A type for arbitrary precision, non-negative decimals.\n *\n * Instances of this class are immutable.\n */\nclass Decimal {\n    static fromUserInput(input, fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        const badCharacter = input.match(/[^0-9.]/);\n        if (badCharacter) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            throw new Error(`Invalid character at position ${badCharacter.index + 1}`);\n        }\n        let whole;\n        let fractional;\n        if (input === \"\") {\n            whole = \"0\";\n            fractional = \"\";\n        }\n        else if (input.search(/\\./) === -1) {\n            // integer format, no separator\n            whole = input;\n            fractional = \"\";\n        }\n        else {\n            const parts = input.split(\".\");\n            switch (parts.length) {\n                case 0:\n                case 1:\n                    throw new Error(\"Fewer than two elements in split result. This must not happen here.\");\n                case 2:\n                    if (!parts[1])\n                        throw new Error(\"Fractional part missing\");\n                    whole = parts[0];\n                    fractional = parts[1].replace(/0+$/, \"\");\n                    break;\n                default:\n                    throw new Error(\"More than one separator found\");\n            }\n        }\n        if (fractional.length > fractionalDigits) {\n            throw new Error(\"Got more fractional digits than supported\");\n        }\n        const quantity = `${whole}${fractional.padEnd(fractionalDigits, \"0\")}`;\n        return new Decimal(quantity, fractionalDigits);\n    }\n    static fromAtomics(atomics, fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(atomics, fractionalDigits);\n    }\n    /**\n     * Creates a Decimal with value 0.0 and the given number of fractial digits.\n     *\n     * Fractional digits are not relevant for the value but needed to be able\n     * to perform arithmetic operations with other decimals.\n     */\n    static zero(fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(\"0\", fractionalDigits);\n    }\n    /**\n     * Creates a Decimal with value 1.0 and the given number of fractial digits.\n     *\n     * Fractional digits are not relevant for the value but needed to be able\n     * to perform arithmetic operations with other decimals.\n     */\n    static one(fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(\"1\" + \"0\".repeat(fractionalDigits), fractionalDigits);\n    }\n    static verifyFractionalDigits(fractionalDigits) {\n        if (!Number.isInteger(fractionalDigits))\n            throw new Error(\"Fractional digits is not an integer\");\n        if (fractionalDigits < 0)\n            throw new Error(\"Fractional digits must not be negative\");\n        if (fractionalDigits > maxFractionalDigits) {\n            throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);\n        }\n    }\n    static compare(a, b) {\n        if (a.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        return a.data.atomics.cmp(new bn_js_1.default(b.atomics));\n    }\n    get atomics() {\n        return this.data.atomics.toString();\n    }\n    get fractionalDigits() {\n        return this.data.fractionalDigits;\n    }\n    constructor(atomics, fractionalDigits) {\n        if (!atomics.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format. Only non-negative integers in decimal representation supported.\");\n        }\n        this.data = {\n            atomics: new bn_js_1.default(atomics),\n            fractionalDigits: fractionalDigits,\n        };\n    }\n    /** Creates a new instance with the same value */\n    clone() {\n        return new Decimal(this.atomics, this.fractionalDigits);\n    }\n    /** Returns the greatest decimal <= this which has no fractional part (rounding down) */\n    floor() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return this.clone();\n        }\n        else {\n            return Decimal.fromAtomics(whole.mul(factor).toString(), this.fractionalDigits);\n        }\n    }\n    /** Returns the smallest decimal >= this which has no fractional part (rounding up) */\n    ceil() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return this.clone();\n        }\n        else {\n            return Decimal.fromAtomics(whole.addn(1).mul(factor).toString(), this.fractionalDigits);\n        }\n    }\n    toString() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return whole.toString();\n        }\n        else {\n            const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, \"0\");\n            const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, \"\");\n            return `${whole.toString()}.${trimmedFractionalPart}`;\n        }\n    }\n    /**\n     * Returns an approximation as a float type. Only use this if no\n     * exact calculation is required.\n     */\n    toFloatApproximation() {\n        const out = Number(this.toString());\n        if (Number.isNaN(out))\n            throw new Error(\"Conversion to number failed\");\n        return out;\n    }\n    /**\n     * a.plus(b) returns a+b.\n     *\n     * Both values need to have the same fractional digits.\n     */\n    plus(b) {\n        if (this.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        const sum = this.data.atomics.add(new bn_js_1.default(b.atomics));\n        return new Decimal(sum.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.minus(b) returns a-b.\n     *\n     * Both values need to have the same fractional digits.\n     * The resulting difference needs to be non-negative.\n     */\n    minus(b) {\n        if (this.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        const difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));\n        if (difference.ltn(0))\n            throw new Error(\"Difference must not be negative\");\n        return new Decimal(difference.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.multiply(b) returns a*b.\n     *\n     * We only allow multiplication by unsigned integers to avoid rounding errors.\n     */\n    multiply(b) {\n        const product = this.data.atomics.mul(new bn_js_1.default(b.toString()));\n        return new Decimal(product.toString(), this.fractionalDigits);\n    }\n    equals(b) {\n        return Decimal.compare(this, b) === 0;\n    }\n    isLessThan(b) {\n        return Decimal.compare(this, b) < 0;\n    }\n    isLessThanOrEqual(b) {\n        return Decimal.compare(this, b) <= 0;\n    }\n    isGreaterThan(b) {\n        return Decimal.compare(this, b) > 0;\n    }\n    isGreaterThanOrEqual(b) {\n        return Decimal.compare(this, b) >= 0;\n    }\n}\nexports.Decimal = Decimal;\n//# sourceMappingURL=decimal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvc21qcyttYXRoQDAuMzIuNC9ub2RlX21vZHVsZXMvQGNvc21qcy9tYXRoL2J1aWxkL2RlY2ltYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsZ0NBQWdDLG1CQUFPLENBQUMsa0ZBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx1QkFBdUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSxFQUFFLHlDQUF5QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG9CQUFvQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCLEdBQUcsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb3NtanMrbWF0aEAwLjMyLjQvbm9kZV9tb2R1bGVzL0Bjb3NtanMvbWF0aC9idWlsZC9kZWNpbWFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWNpbWFsID0gdm9pZCAwO1xuY29uc3QgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuLy8gVG9vIGxhcmdlIHZhbHVlcyBsZWFkIHRvIG1hc3NpdmUgbWVtb3J5IHVzYWdlLiBMaW1pdCB0byBzb21ldGhpbmcgc2Vuc2libGUuXG4vLyBUaGUgbGFyZ2VzdCB2YWx1ZSB3ZSBuZWVkIGlzIDE4IChFdGhlcikuXG5jb25zdCBtYXhGcmFjdGlvbmFsRGlnaXRzID0gMTAwO1xuLyoqXG4gKiBBIHR5cGUgZm9yIGFyYml0cmFyeSBwcmVjaXNpb24sIG5vbi1uZWdhdGl2ZSBkZWNpbWFscy5cbiAqXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgaW1tdXRhYmxlLlxuICovXG5jbGFzcyBEZWNpbWFsIHtcbiAgICBzdGF0aWMgZnJvbVVzZXJJbnB1dChpbnB1dCwgZnJhY3Rpb25hbERpZ2l0cykge1xuICAgICAgICBEZWNpbWFsLnZlcmlmeUZyYWN0aW9uYWxEaWdpdHMoZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgICAgIGNvbnN0IGJhZENoYXJhY3RlciA9IGlucHV0Lm1hdGNoKC9bXjAtOS5dLyk7XG4gICAgICAgIGlmIChiYWRDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyIGF0IHBvc2l0aW9uICR7YmFkQ2hhcmFjdGVyLmluZGV4ICsgMX1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2hvbGU7XG4gICAgICAgIGxldCBmcmFjdGlvbmFsO1xuICAgICAgICBpZiAoaW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdob2xlID0gXCIwXCI7XG4gICAgICAgICAgICBmcmFjdGlvbmFsID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC5zZWFyY2goL1xcLi8pID09PSAtMSkge1xuICAgICAgICAgICAgLy8gaW50ZWdlciBmb3JtYXQsIG5vIHNlcGFyYXRvclxuICAgICAgICAgICAgd2hvbGUgPSBpbnB1dDtcbiAgICAgICAgICAgIGZyYWN0aW9uYWwgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBpbnB1dC5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZld2VyIHRoYW4gdHdvIGVsZW1lbnRzIGluIHNwbGl0IHJlc3VsdC4gVGhpcyBtdXN0IG5vdCBoYXBwZW4gaGVyZS5cIik7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnRzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhY3Rpb25hbCBwYXJ0IG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHdob2xlID0gcGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uYWwgPSBwYXJ0c1sxXS5yZXBsYWNlKC8wKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9yZSB0aGFuIG9uZSBzZXBhcmF0b3IgZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWN0aW9uYWwubGVuZ3RoID4gZnJhY3Rpb25hbERpZ2l0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR290IG1vcmUgZnJhY3Rpb25hbCBkaWdpdHMgdGhhbiBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVhbnRpdHkgPSBgJHt3aG9sZX0ke2ZyYWN0aW9uYWwucGFkRW5kKGZyYWN0aW9uYWxEaWdpdHMsIFwiMFwiKX1gO1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwocXVhbnRpdHksIGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUF0b21pY3MoYXRvbWljcywgZnJhY3Rpb25hbERpZ2l0cykge1xuICAgICAgICBEZWNpbWFsLnZlcmlmeUZyYWN0aW9uYWxEaWdpdHMoZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbChhdG9taWNzLCBmcmFjdGlvbmFsRGlnaXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERlY2ltYWwgd2l0aCB2YWx1ZSAwLjAgYW5kIHRoZSBnaXZlbiBudW1iZXIgb2YgZnJhY3RpYWwgZGlnaXRzLlxuICAgICAqXG4gICAgICogRnJhY3Rpb25hbCBkaWdpdHMgYXJlIG5vdCByZWxldmFudCBmb3IgdGhlIHZhbHVlIGJ1dCBuZWVkZWQgdG8gYmUgYWJsZVxuICAgICAqIHRvIHBlcmZvcm0gYXJpdGhtZXRpYyBvcGVyYXRpb25zIHdpdGggb3RoZXIgZGVjaW1hbHMuXG4gICAgICovXG4gICAgc3RhdGljIHplcm8oZnJhY3Rpb25hbERpZ2l0cykge1xuICAgICAgICBEZWNpbWFsLnZlcmlmeUZyYWN0aW9uYWxEaWdpdHMoZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbChcIjBcIiwgZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBEZWNpbWFsIHdpdGggdmFsdWUgMS4wIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGZyYWN0aWFsIGRpZ2l0cy5cbiAgICAgKlxuICAgICAqIEZyYWN0aW9uYWwgZGlnaXRzIGFyZSBub3QgcmVsZXZhbnQgZm9yIHRoZSB2YWx1ZSBidXQgbmVlZGVkIHRvIGJlIGFibGVcbiAgICAgKiB0byBwZXJmb3JtIGFyaXRobWV0aWMgb3BlcmF0aW9ucyB3aXRoIG90aGVyIGRlY2ltYWxzLlxuICAgICAqL1xuICAgIHN0YXRpYyBvbmUoZnJhY3Rpb25hbERpZ2l0cykge1xuICAgICAgICBEZWNpbWFsLnZlcmlmeUZyYWN0aW9uYWxEaWdpdHMoZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbChcIjFcIiArIFwiMFwiLnJlcGVhdChmcmFjdGlvbmFsRGlnaXRzKSwgZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgfVxuICAgIHN0YXRpYyB2ZXJpZnlGcmFjdGlvbmFsRGlnaXRzKGZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGZyYWN0aW9uYWxEaWdpdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhY3Rpb25hbCBkaWdpdHMgaXMgbm90IGFuIGludGVnZXJcIik7XG4gICAgICAgIGlmIChmcmFjdGlvbmFsRGlnaXRzIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyYWN0aW9uYWwgZGlnaXRzIG11c3Qgbm90IGJlIG5lZ2F0aXZlXCIpO1xuICAgICAgICBpZiAoZnJhY3Rpb25hbERpZ2l0cyA+IG1heEZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnJhY3Rpb25hbCBkaWdpdHMgbXVzdCBub3QgZXhjZWVkICR7bWF4RnJhY3Rpb25hbERpZ2l0c31gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyZShhLCBiKSB7XG4gICAgICAgIGlmIChhLmZyYWN0aW9uYWxEaWdpdHMgIT09IGIuZnJhY3Rpb25hbERpZ2l0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyYWN0aW9uYWwgZGlnaXRzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGEuZGF0YS5hdG9taWNzLmNtcChuZXcgYm5fanNfMS5kZWZhdWx0KGIuYXRvbWljcykpO1xuICAgIH1cbiAgICBnZXQgYXRvbWljcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hdG9taWNzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldCBmcmFjdGlvbmFsRGlnaXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmZyYWN0aW9uYWxEaWdpdHM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGF0b21pY3MsIGZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICAgICAgaWYgKCFhdG9taWNzLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZyBmb3JtYXQuIE9ubHkgbm9uLW5lZ2F0aXZlIGludGVnZXJzIGluIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgICAgICBhdG9taWNzOiBuZXcgYm5fanNfMS5kZWZhdWx0KGF0b21pY3MpLFxuICAgICAgICAgICAgZnJhY3Rpb25hbERpZ2l0czogZnJhY3Rpb25hbERpZ2l0cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSB2YWx1ZSAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwodGhpcy5hdG9taWNzLCB0aGlzLmZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgZ3JlYXRlc3QgZGVjaW1hbCA8PSB0aGlzIHdoaWNoIGhhcyBubyBmcmFjdGlvbmFsIHBhcnQgKHJvdW5kaW5nIGRvd24pICovXG4gICAgZmxvb3IoKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IG5ldyBibl9qc18xLmRlZmF1bHQoMTApLnBvdyhuZXcgYm5fanNfMS5kZWZhdWx0KHRoaXMuZGF0YS5mcmFjdGlvbmFsRGlnaXRzKSk7XG4gICAgICAgIGNvbnN0IHdob2xlID0gdGhpcy5kYXRhLmF0b21pY3MuZGl2KGZhY3Rvcik7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uYWwgPSB0aGlzLmRhdGEuYXRvbWljcy5tb2QoZmFjdG9yKTtcbiAgICAgICAgaWYgKGZyYWN0aW9uYWwuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGVjaW1hbC5mcm9tQXRvbWljcyh3aG9sZS5tdWwoZmFjdG9yKS50b1N0cmluZygpLCB0aGlzLmZyYWN0aW9uYWxEaWdpdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBzbWFsbGVzdCBkZWNpbWFsID49IHRoaXMgd2hpY2ggaGFzIG5vIGZyYWN0aW9uYWwgcGFydCAocm91bmRpbmcgdXApICovXG4gICAgY2VpbCgpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgxMCkucG93KG5ldyBibl9qc18xLmRlZmF1bHQodGhpcy5kYXRhLmZyYWN0aW9uYWxEaWdpdHMpKTtcbiAgICAgICAgY29uc3Qgd2hvbGUgPSB0aGlzLmRhdGEuYXRvbWljcy5kaXYoZmFjdG9yKTtcbiAgICAgICAgY29uc3QgZnJhY3Rpb25hbCA9IHRoaXMuZGF0YS5hdG9taWNzLm1vZChmYWN0b3IpO1xuICAgICAgICBpZiAoZnJhY3Rpb25hbC5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEZWNpbWFsLmZyb21BdG9taWNzKHdob2xlLmFkZG4oMSkubXVsKGZhY3RvcikudG9TdHJpbmcoKSwgdGhpcy5mcmFjdGlvbmFsRGlnaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgxMCkucG93KG5ldyBibl9qc18xLmRlZmF1bHQodGhpcy5kYXRhLmZyYWN0aW9uYWxEaWdpdHMpKTtcbiAgICAgICAgY29uc3Qgd2hvbGUgPSB0aGlzLmRhdGEuYXRvbWljcy5kaXYoZmFjdG9yKTtcbiAgICAgICAgY29uc3QgZnJhY3Rpb25hbCA9IHRoaXMuZGF0YS5hdG9taWNzLm1vZChmYWN0b3IpO1xuICAgICAgICBpZiAoZnJhY3Rpb25hbC5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdob2xlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsRnJhY3Rpb25hbFBhcnQgPSBmcmFjdGlvbmFsLnRvU3RyaW5nKCkucGFkU3RhcnQodGhpcy5kYXRhLmZyYWN0aW9uYWxEaWdpdHMsIFwiMFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcmFjdGlvbmFsUGFydCA9IGZ1bGxGcmFjdGlvbmFsUGFydC5yZXBsYWNlKC8wKyQvLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiBgJHt3aG9sZS50b1N0cmluZygpfS4ke3RyaW1tZWRGcmFjdGlvbmFsUGFydH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXBwcm94aW1hdGlvbiBhcyBhIGZsb2F0IHR5cGUuIE9ubHkgdXNlIHRoaXMgaWYgbm9cbiAgICAgKiBleGFjdCBjYWxjdWxhdGlvbiBpcyByZXF1aXJlZC5cbiAgICAgKi9cbiAgICB0b0Zsb2F0QXBwcm94aW1hdGlvbigpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gTnVtYmVyKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4ob3V0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZlcnNpb24gdG8gbnVtYmVyIGZhaWxlZFwiKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYS5wbHVzKGIpIHJldHVybnMgYStiLlxuICAgICAqXG4gICAgICogQm90aCB2YWx1ZXMgbmVlZCB0byBoYXZlIHRoZSBzYW1lIGZyYWN0aW9uYWwgZGlnaXRzLlxuICAgICAqL1xuICAgIHBsdXMoYikge1xuICAgICAgICBpZiAodGhpcy5mcmFjdGlvbmFsRGlnaXRzICE9PSBiLmZyYWN0aW9uYWxEaWdpdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcmFjdGlvbmFsIGRpZ2l0cyBkbyBub3QgbWF0Y2hcIik7XG4gICAgICAgIGNvbnN0IHN1bSA9IHRoaXMuZGF0YS5hdG9taWNzLmFkZChuZXcgYm5fanNfMS5kZWZhdWx0KGIuYXRvbWljcykpO1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoc3VtLnRvU3RyaW5nKCksIHRoaXMuZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGEubWludXMoYikgcmV0dXJucyBhLWIuXG4gICAgICpcbiAgICAgKiBCb3RoIHZhbHVlcyBuZWVkIHRvIGhhdmUgdGhlIHNhbWUgZnJhY3Rpb25hbCBkaWdpdHMuXG4gICAgICogVGhlIHJlc3VsdGluZyBkaWZmZXJlbmNlIG5lZWRzIHRvIGJlIG5vbi1uZWdhdGl2ZS5cbiAgICAgKi9cbiAgICBtaW51cyhiKSB7XG4gICAgICAgIGlmICh0aGlzLmZyYWN0aW9uYWxEaWdpdHMgIT09IGIuZnJhY3Rpb25hbERpZ2l0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyYWN0aW9uYWwgZGlnaXRzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMuZGF0YS5hdG9taWNzLnN1YihuZXcgYm5fanNfMS5kZWZhdWx0KGIuYXRvbWljcykpO1xuICAgICAgICBpZiAoZGlmZmVyZW5jZS5sdG4oMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWZmZXJlbmNlIG11c3Qgbm90IGJlIG5lZ2F0aXZlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoZGlmZmVyZW5jZS50b1N0cmluZygpLCB0aGlzLmZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhLm11bHRpcGx5KGIpIHJldHVybnMgYSpiLlxuICAgICAqXG4gICAgICogV2Ugb25seSBhbGxvdyBtdWx0aXBsaWNhdGlvbiBieSB1bnNpZ25lZCBpbnRlZ2VycyB0byBhdm9pZCByb3VuZGluZyBlcnJvcnMuXG4gICAgICovXG4gICAgbXVsdGlwbHkoYikge1xuICAgICAgICBjb25zdCBwcm9kdWN0ID0gdGhpcy5kYXRhLmF0b21pY3MubXVsKG5ldyBibl9qc18xLmRlZmF1bHQoYi50b1N0cmluZygpKSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbChwcm9kdWN0LnRvU3RyaW5nKCksIHRoaXMuZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgfVxuICAgIGVxdWFscyhiKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsLmNvbXBhcmUodGhpcywgYikgPT09IDA7XG4gICAgfVxuICAgIGlzTGVzc1RoYW4oYikge1xuICAgICAgICByZXR1cm4gRGVjaW1hbC5jb21wYXJlKHRoaXMsIGIpIDwgMDtcbiAgICB9XG4gICAgaXNMZXNzVGhhbk9yRXF1YWwoYikge1xuICAgICAgICByZXR1cm4gRGVjaW1hbC5jb21wYXJlKHRoaXMsIGIpIDw9IDA7XG4gICAgfVxuICAgIGlzR3JlYXRlclRoYW4oYikge1xuICAgICAgICByZXR1cm4gRGVjaW1hbC5jb21wYXJlKHRoaXMsIGIpID4gMDtcbiAgICB9XG4gICAgaXNHcmVhdGVyVGhhbk9yRXF1YWwoYikge1xuICAgICAgICByZXR1cm4gRGVjaW1hbC5jb21wYXJlKHRoaXMsIGIpID49IDA7XG4gICAgfVxufVxuZXhwb3J0cy5EZWNpbWFsID0gRGVjaW1hbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY2ltYWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/decimal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Uint64 = exports.Uint53 = exports.Uint32 = exports.Int53 = exports.Decimal = void 0;\nvar decimal_1 = __webpack_require__(/*! ./decimal */ \"(ssr)/./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/decimal.js\");\nObject.defineProperty(exports, \"Decimal\", ({ enumerable: true, get: function () { return decimal_1.Decimal; } }));\nvar integers_1 = __webpack_require__(/*! ./integers */ \"(ssr)/./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/integers.js\");\nObject.defineProperty(exports, \"Int53\", ({ enumerable: true, get: function () { return integers_1.Int53; } }));\nObject.defineProperty(exports, \"Uint32\", ({ enumerable: true, get: function () { return integers_1.Uint32; } }));\nObject.defineProperty(exports, \"Uint53\", ({ enumerable: true, get: function () { return integers_1.Uint53; } }));\nObject.defineProperty(exports, \"Uint64\", ({ enumerable: true, get: function () { return integers_1.Uint64; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvc21qcyttYXRoQDAuMzIuNC9ub2RlX21vZHVsZXMvQGNvc21qcy9tYXRoL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxlQUFlO0FBQ2xGLGdCQUFnQixtQkFBTyxDQUFDLDRHQUFXO0FBQ25DLDJDQUEwQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMvRyxpQkFBaUIsbUJBQU8sQ0FBQyw4R0FBWTtBQUNyQyx5Q0FBd0MsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDNUcsMENBQXlDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzlHLDBDQUF5QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUM5RywwQ0FBeUMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDOUciLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb3NtanMrbWF0aEAwLjMyLjQvbm9kZV9tb2R1bGVzL0Bjb3NtanMvbWF0aC9idWlsZC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVWludDY0ID0gZXhwb3J0cy5VaW50NTMgPSBleHBvcnRzLlVpbnQzMiA9IGV4cG9ydHMuSW50NTMgPSBleHBvcnRzLkRlY2ltYWwgPSB2b2lkIDA7XG52YXIgZGVjaW1hbF8xID0gcmVxdWlyZShcIi4vZGVjaW1hbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlY2ltYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY2ltYWxfMS5EZWNpbWFsOyB9IH0pO1xudmFyIGludGVnZXJzXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2Vyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludDUzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlZ2Vyc18xLkludDUzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDMyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlZ2Vyc18xLlVpbnQzMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQ1M1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZWdlcnNfMS5VaW50NTM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50NjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVnZXJzXzEuVWludDY0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/integers.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/integers.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;\n/* eslint-disable no-bitwise */\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nconst uint64MaxValue = new bn_js_1.default(\"18446744073709551615\", 10, \"be\");\nclass Uint32 {\n    /** @deprecated use Uint32.fromBytes */\n    static fromBigEndianBytes(bytes) {\n        return Uint32.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint32 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 4 bytes\n     * @param endianess defaults to big endian\n     */\n    static fromBytes(bytes, endianess = \"be\") {\n        if (bytes.length !== 4) {\n            throw new Error(\"Invalid input length. Expected 4 bytes.\");\n        }\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n            }\n        }\n        const beBytes = endianess === \"be\" ? bytes : Array.from(bytes).reverse();\n        // Use mulitiplication instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Uint32(Number.parseInt(str, 10));\n    }\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        if (input < 0 || input > 4294967295) {\n            throw new Error(\"Input not in uint32 range: \" + input.toString());\n        }\n        this.data = input;\n    }\n    toBytesBigEndian() {\n        // Use division instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 24) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 0) & 0xff,\n        ]);\n    }\n    toBytesLittleEndian() {\n        // Use division instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 0) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 24) & 0xff,\n        ]);\n    }\n    toNumber() {\n        return this.data;\n    }\n    toBigInt() {\n        return BigInt(this.toNumber());\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint32 = Uint32;\nclass Int53 {\n    static fromString(str) {\n        if (!str.match(/^-?[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Int53(Number.parseInt(str, 10));\n    }\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\"Input not in int53 range: \" + input.toString());\n        }\n        this.data = input;\n    }\n    toNumber() {\n        return this.data;\n    }\n    toBigInt() {\n        return BigInt(this.toNumber());\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Int53 = Int53;\nclass Uint53 {\n    static fromString(str) {\n        const signed = Int53.fromString(str);\n        return new Uint53(signed.toNumber());\n    }\n    constructor(input) {\n        const signed = new Int53(input);\n        if (signed.toNumber() < 0) {\n            throw new Error(\"Input is negative\");\n        }\n        this.data = signed;\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n    toBigInt() {\n        return BigInt(this.toNumber());\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint53 = Uint53;\nclass Uint64 {\n    /** @deprecated use Uint64.fromBytes */\n    static fromBytesBigEndian(bytes) {\n        return Uint64.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint64 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 8 bytes\n     * @param endianess defaults to big endian\n     */\n    static fromBytes(bytes, endianess = \"be\") {\n        if (bytes.length !== 8) {\n            throw new Error(\"Invalid input length. Expected 8 bytes.\");\n        }\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n            }\n        }\n        const beBytes = endianess === \"be\" ? Array.from(bytes) : Array.from(bytes).reverse();\n        return new Uint64(new bn_js_1.default(beBytes));\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Uint64(new bn_js_1.default(str, 10, \"be\"));\n    }\n    static fromNumber(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        let bigint;\n        try {\n            bigint = new bn_js_1.default(input);\n        }\n        catch {\n            throw new Error(\"Input is not a safe integer\");\n        }\n        return new Uint64(bigint);\n    }\n    constructor(data) {\n        if (data.isNeg()) {\n            throw new Error(\"Input is negative\");\n        }\n        if (data.gt(uint64MaxValue)) {\n            throw new Error(\"Input exceeds uint64 range\");\n        }\n        this.data = data;\n    }\n    toBytesBigEndian() {\n        return Uint8Array.from(this.data.toArray(\"be\", 8));\n    }\n    toBytesLittleEndian() {\n        return Uint8Array.from(this.data.toArray(\"le\", 8));\n    }\n    toString() {\n        return this.data.toString(10);\n    }\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n}\nexports.Uint64 = Uint64;\n// Assign classes to unused variables in order to verify static interface conformance at compile time.\n// Workaround for https://github.com/microsoft/TypeScript/issues/33892\nconst _int53Class = Int53;\nconst _uint53Class = Uint53;\nconst _uint32Class = Uint32;\nconst _uint64Class = Uint64;\n//# sourceMappingURL=integers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvc21qcyttYXRoQDAuMzIuNC9ub2RlX21vZHVsZXMvQGNvc21qcy9tYXRoL2J1aWxkL2ludGVnZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsY0FBYztBQUNoRTtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLGtGQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWJ1YmFrcmppbW9oL0Rlc2t0b3AvQ29kaW5nIFN0dWZmcy9oYWNrYXRob24vc2VjcmV0LW5ldHdvcmsvbWVtZUFpX2NvaW5fY3JlYXRvci9haS1tZW1lLWNvaW4tY3JlYXRvci9ub2RlX21vZHVsZXMvLnBucG0vQGNvc21qcyttYXRoQDAuMzIuNC9ub2RlX21vZHVsZXMvQGNvc21qcy9tYXRoL2J1aWxkL2ludGVnZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VaW50NjQgPSBleHBvcnRzLlVpbnQ1MyA9IGV4cG9ydHMuSW50NTMgPSBleHBvcnRzLlVpbnQzMiA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmNvbnN0IHVpbnQ2NE1heFZhbHVlID0gbmV3IGJuX2pzXzEuZGVmYXVsdChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIsIDEwLCBcImJlXCIpO1xuY2xhc3MgVWludDMyIHtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIFVpbnQzMi5mcm9tQnl0ZXMgKi9cbiAgICBzdGF0aWMgZnJvbUJpZ0VuZGlhbkJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBVaW50MzIuZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFVpbnQzMiBmcm9tIGEgZml4ZWQgbGVuZ3RoIGJ5dGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnl0ZXMgYSBsaXN0IG9mIGV4YWN0bHkgNCBieXRlc1xuICAgICAqIEBwYXJhbSBlbmRpYW5lc3MgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMsIGVuZGlhbmVzcyA9IFwiYmVcIikge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IGxlbmd0aC4gRXhwZWN0ZWQgNCBieXRlcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGJ5dGVzW2ldKSB8fCBieXRlc1tpXSA+IDI1NSB8fCBieXRlc1tpXSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGluIGJ5dGUuIEZvdW5kOiBcIiArIGJ5dGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiZUJ5dGVzID0gZW5kaWFuZXNzID09PSBcImJlXCIgPyBieXRlcyA6IEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKTtcbiAgICAgICAgLy8gVXNlIG11bGl0aXBsaWNhdGlvbiBpbnN0ZWFkIG9mIHNoaWZ0aW5nIHNpbmNlIGJpdHdpc2Ugb3BlcmF0b3JzIGFyZSBkZWZpbmVkXG4gICAgICAgIC8vIG9uIFNJR05FRCBpbnQzMiBpbiBKYXZhU2NyaXB0IGFuZCB3ZSBkb24ndCB3YW50IHRvIHJpc2sgc3VycHJpc2VzXG4gICAgICAgIHJldHVybiBuZXcgVWludDMyKGJlQnl0ZXNbMF0gKiAyICoqIDI0ICsgYmVCeXRlc1sxXSAqIDIgKiogMTYgKyBiZUJ5dGVzWzJdICogMiAqKiA4ICsgYmVCeXRlc1szXSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICBpZiAoIXN0ci5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDMyKE51bWJlci5wYXJzZUludChzdHIsIDEwKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBub3QgYSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IGFuIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0IDwgMCB8fCBpbnB1dCA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IG5vdCBpbiB1aW50MzIgcmFuZ2U6IFwiICsgaW5wdXQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhID0gaW5wdXQ7XG4gICAgfVxuICAgIHRvQnl0ZXNCaWdFbmRpYW4oKSB7XG4gICAgICAgIC8vIFVzZSBkaXZpc2lvbiBpbnN0ZWFkIG9mIHNoaWZ0aW5nIHNpbmNlIGJpdHdpc2Ugb3BlcmF0b3JzIGFyZSBkZWZpbmVkXG4gICAgICAgIC8vIG9uIFNJR05FRCBpbnQzMiBpbiBKYXZhU2NyaXB0IGFuZCB3ZSBkb24ndCB3YW50IHRvIHJpc2sgc3VycHJpc2VzXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuZGF0YSAvIDIgKiogMjQpICYgMHhmZixcbiAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5kYXRhIC8gMiAqKiAxNikgJiAweGZmLFxuICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLmRhdGEgLyAyICoqIDgpICYgMHhmZixcbiAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5kYXRhIC8gMiAqKiAwKSAmIDB4ZmYsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICB0b0J5dGVzTGl0dGxlRW5kaWFuKCkge1xuICAgICAgICAvLyBVc2UgZGl2aXNpb24gaW5zdGVhZCBvZiBzaGlmdGluZyBzaW5jZSBiaXR3aXNlIG9wZXJhdG9ycyBhcmUgZGVmaW5lZFxuICAgICAgICAvLyBvbiBTSUdORUQgaW50MzIgaW4gSmF2YVNjcmlwdCBhbmQgd2UgZG9uJ3Qgd2FudCB0byByaXNrIHN1cnByaXNlc1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLmRhdGEgLyAyICoqIDApICYgMHhmZixcbiAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5kYXRhIC8gMiAqKiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuZGF0YSAvIDIgKiogMTYpICYgMHhmZixcbiAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5kYXRhIC8gMiAqKiAyNCkgJiAweGZmLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuICAgIHRvQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudG9OdW1iZXIoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5VaW50MzIgPSBVaW50MzI7XG5jbGFzcyBJbnQ1MyB7XG4gICAgc3RhdGljIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgICAgIGlmICghc3RyLm1hdGNoKC9eLT9bMC05XSskLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nIGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEludDUzKE51bWJlci5wYXJzZUludChzdHIsIDEwKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBub3QgYSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IGFuIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0IDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfHwgaW5wdXQgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbm90IGluIGludDUzIHJhbmdlOiBcIiArIGlucHV0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IGlucHV0O1xuICAgIH1cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9XG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy50b051bWJlcigpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLkludDUzID0gSW50NTM7XG5jbGFzcyBVaW50NTMge1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICBjb25zdCBzaWduZWQgPSBJbnQ1My5mcm9tU3RyaW5nKHN0cik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDUzKHNpZ25lZC50b051bWJlcigpKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkID0gbmV3IEludDUzKGlucHV0KTtcbiAgICAgICAgaWYgKHNpZ25lZC50b051bWJlcigpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbmVnYXRpdmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhID0gc2lnbmVkO1xuICAgIH1cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS50b051bWJlcigpO1xuICAgIH1cbiAgICB0b0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnRvTnVtYmVyKCkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuVWludDUzID0gVWludDUzO1xuY2xhc3MgVWludDY0IHtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIFVpbnQ2NC5mcm9tQnl0ZXMgKi9cbiAgICBzdGF0aWMgZnJvbUJ5dGVzQmlnRW5kaWFuKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBVaW50NjQuZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFVpbnQ2NCBmcm9tIGEgZml4ZWQgbGVuZ3RoIGJ5dGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnl0ZXMgYSBsaXN0IG9mIGV4YWN0bHkgOCBieXRlc1xuICAgICAqIEBwYXJhbSBlbmRpYW5lc3MgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMsIGVuZGlhbmVzcyA9IFwiYmVcIikge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IGxlbmd0aC4gRXhwZWN0ZWQgOCBieXRlcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGJ5dGVzW2ldKSB8fCBieXRlc1tpXSA+IDI1NSB8fCBieXRlc1tpXSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGluIGJ5dGUuIEZvdW5kOiBcIiArIGJ5dGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiZUJ5dGVzID0gZW5kaWFuZXNzID09PSBcImJlXCIgPyBBcnJheS5mcm9tKGJ5dGVzKSA6IEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50NjQobmV3IGJuX2pzXzEuZGVmYXVsdChiZUJ5dGVzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICBpZiAoIXN0ci5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDY0KG5ldyBibl9qc18xLmRlZmF1bHQoc3RyLCAxMCwgXCJiZVwiKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTnVtYmVyKGlucHV0KSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBub3QgYSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IGFuIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJpZ2ludDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJpZ2ludCA9IG5ldyBibl9qc18xLmRlZmF1bHQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG5vdCBhIHNhZmUgaW50ZWdlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ2NChiaWdpbnQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG5lZ2F0aXZlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmd0KHVpbnQ2NE1heFZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZXhjZWVkcyB1aW50NjQgcmFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgdG9CeXRlc0JpZ0VuZGlhbigpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh0aGlzLmRhdGEudG9BcnJheShcImJlXCIsIDgpKTtcbiAgICB9XG4gICAgdG9CeXRlc0xpdHRsZUVuZGlhbigpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh0aGlzLmRhdGEudG9BcnJheShcImxlXCIsIDgpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudG9TdHJpbmcoMTApO1xuICAgIH1cbiAgICB0b0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS50b051bWJlcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuVWludDY0ID0gVWludDY0O1xuLy8gQXNzaWduIGNsYXNzZXMgdG8gdW51c2VkIHZhcmlhYmxlcyBpbiBvcmRlciB0byB2ZXJpZnkgc3RhdGljIGludGVyZmFjZSBjb25mb3JtYW5jZSBhdCBjb21waWxlIHRpbWUuXG4vLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMzODkyXG5jb25zdCBfaW50NTNDbGFzcyA9IEludDUzO1xuY29uc3QgX3VpbnQ1M0NsYXNzID0gVWludDUzO1xuY29uc3QgX3VpbnQzMkNsYXNzID0gVWludDMyO1xuY29uc3QgX3VpbnQ2NENsYXNzID0gVWludDY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZWdlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/integers.js\n");

/***/ })

};
;