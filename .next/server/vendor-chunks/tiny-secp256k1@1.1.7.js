/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tiny-secp256k1@1.1.7";
exports.ids = ["vendor-chunks/tiny-secp256k1@1.1.7"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/index.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\ntry {\n  module.exports = __webpack_require__(/*! ./native */ \"(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/native.js\")\n} catch (err) {\n  module.exports = __webpack_require__(/*! ./js */ \"(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/js.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGlueS1zZWNwMjU2azFAMS4xLjcvbm9kZV9tb2R1bGVzL3Rpbnktc2VjcDI1NmsxL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsRUFBRSw2SUFBb0M7QUFDdEMsRUFBRTtBQUNGLEVBQUUscUlBQWdDO0FBQ2xDIiwic291cmNlcyI6WyIvaG9tZS9hYnViYWtyamltb2gvRGVza3RvcC9Db2RpbmcgU3R1ZmZzL2hhY2thdGhvbi9zZWNyZXQtbmV0d29yay9tZW1lQWlfY29pbl9jcmVhdG9yL2FpLW1lbWUtY29pbi1jcmVhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS90aW55LXNlY3AyNTZrMUAxLjEuNy9ub2RlX21vZHVsZXMvdGlueS1zZWNwMjU2azEvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9uYXRpdmUnKVxufSBjYXRjaCAoZXJyKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9qcycpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/js.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/js.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@4.12.1/node_modules/bn.js/lib/bn.js\")\nconst EC = (__webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic.js\").ec)\nconst secp256k1 = new EC('secp256k1')\nconst deterministicGenerateK = __webpack_require__(/*! ./rfc6979 */ \"(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/rfc6979.js\")\n\nconst ZERO32 = Buffer.alloc(32, 0)\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')\nconst EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')\n\nconst n = secp256k1.curve.n\nconst nDiv2 = n.shrn(1)\nconst G = secp256k1.curve.g\n\nconst THROW_BAD_PRIVATE = 'Expected Private'\nconst THROW_BAD_POINT = 'Expected Point'\nconst THROW_BAD_TWEAK = 'Expected Tweak'\nconst THROW_BAD_HASH = 'Expected Hash'\nconst THROW_BAD_SIGNATURE = 'Expected Signature'\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'\n\nfunction isScalar (x) {\n  return (x instanceof Uint8Array) && x.length === 32\n}\n\nfunction isOrderScalar (x) {\n  if (!isScalar(x)) return false\n  return EC_GROUP_ORDER.compare(x) > 0 // < G\n}\n\nfunction isPoint (p) {\n  if (!(p instanceof Uint8Array)) return false\n  if (p.length < 33) return false\n\n  const t = p[0]\n  const x = p.subarray(1, 33)\n  if (ZERO32.compare(x) === 0) return false\n  if (EC_P.compare(x) <= 0) return false\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    try { decodeFrom(p) } catch (e) { return false } // TODO: temporary\n    return true\n  }\n\n  const y = p.subarray(33)\n  if (ZERO32.compare(y) === 0) return false\n  if (EC_P.compare(y) <= 0) return false\n  if (t === 0x04 && p.length === 65) return true\n  return false\n}\n\nfunction __isPointCompressed (p) {\n  return p[0] !== 0x04\n}\n\nfunction isPointCompressed (p) {\n  if (!isPoint(p)) return false\n  return __isPointCompressed(p)\n}\n\nfunction isPrivate (x) {\n  if (!isScalar(x)) return false\n  return ZERO32.compare(x) < 0 && // > 0\n    EC_GROUP_ORDER.compare(x) > 0 // < G\n}\n\nfunction isSignature (value) {\n  const r = value.subarray(0, 32)\n  const s = value.subarray(32, 64)\n  return (value instanceof Uint8Array) && value.length === 64 &&\n    EC_GROUP_ORDER.compare(r) > 0 &&\n    EC_GROUP_ORDER.compare(s) > 0\n}\n\nfunction assumeCompression (value, pubkey) {\n  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)\n  if (value === undefined) return true\n  return value\n}\n\nfunction fromBuffer (d) { return new BN(d) }\nfunction toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }\nfunction decodeFrom (P) { return secp256k1.curve.decodePoint(P) }\nfunction getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }\n\nfunction pointAdd (pA, pB, __compressed) {\n  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)\n  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)\n\n  const a = decodeFrom(pA)\n  const b = decodeFrom(pB)\n  const pp = a.add(b)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed, pA)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointAddScalar (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  if (ZERO32.compare(tweak) === 0) return getEncoded(pp, compressed)\n\n  const tt = fromBuffer(tweak)\n  const qq = G.mul(tt)\n  const uu = pp.add(qq)\n  if (uu.isInfinity()) return null\n\n  return getEncoded(uu, compressed)\n}\n\nfunction pointCompress (p, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n\n  const pp = decodeFrom(p)\n  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)\n\n  const compressed = assumeCompression(__compressed, p)\n\n  return getEncoded(pp, compressed)\n}\n\nfunction pointFromScalar (d, __compressed) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n\n  const dd = fromBuffer(d)\n  const pp = G.mul(dd)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointMultiply (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  const tt = fromBuffer(tweak)\n  const qq = pp.mul(tt)\n  if (qq.isInfinity()) return null\n\n  return getEncoded(qq, compressed)\n}\n\nfunction privateAdd (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.add(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction privateSub (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.sub(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction sign (hash, x) {\n  return __sign(hash, x)\n}\n\nfunction signWithEntropy (hash, x, addData) {\n  return __sign(hash, x, addData)\n}\n\nfunction __sign (hash, x, addData) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)\n\n  const d = fromBuffer(x)\n  const e = fromBuffer(hash)\n\n  let r, s\n  const checkSig = function (k) {\n    const kI = fromBuffer(k)\n    const Q = G.mul(kI)\n\n    if (Q.isInfinity()) return false\n\n    r = Q.x.umod(n)\n    if (r.isZero() === 0) return false\n\n    s = kI\n      .invm(n)\n      .mul(e.add(d.mul(r)))\n      .umod(n)\n    if (s.isZero() === 0) return false\n\n    return true\n  }\n\n  deterministicGenerateK(hash, x, checkSig, isPrivate, addData)\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.cmp(nDiv2) > 0) {\n    s = n.sub(s)\n  }\n\n  const buffer = Buffer.allocUnsafe(64)\n  toBuffer(r).copy(buffer, 0)\n  toBuffer(s).copy(buffer, 32)\n  return buffer\n}\n\nfunction verify (hash, q, signature, strict) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')\n  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)\n\n  const Q = decodeFrom(q)\n  const r = fromBuffer(signature.subarray(0, 32))\n  const s = fromBuffer(signature.subarray(32, 64))\n\n  if (strict && s.cmp(nDiv2) > 0) {\n    return false\n  }\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')\n  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false\n  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false\n\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  const e = fromBuffer(hash)\n\n  // Compute s^-1\n  const sInv = s.invm(n)\n\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  const u1 = e.mul(sInv).umod(n)\n  const u2 = r.mul(sInv).umod(n)\n\n  // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n  const R = G.mulAdd(u1, Q, u2)\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (R.isInfinity()) return false\n\n  // 1.4.6 Convert the field element R.x to an integer\n  const xR = R.x\n\n  // 1.4.7 Set v = xR mod n\n  const v = xR.umod(n)\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.eq(r)\n}\n\nmodule.exports = {\n  isPoint,\n  isPointCompressed,\n  isPrivate,\n  pointAdd,\n  pointAddScalar,\n  pointCompress,\n  pointFromScalar,\n  pointMultiply,\n  privateAdd,\n  privateSub,\n  sign,\n  signWithEntropy,\n  verify\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGlueS1zZWNwMjU2azFAMS4xLjcvbm9kZV9tb2R1bGVzL3Rpbnktc2VjcDI1NmsxL2pzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxtRkFBTztBQUMxQixXQUFXLDJIQUFzQjtBQUNqQztBQUNBLCtCQUErQixtQkFBTyxDQUFDLHlHQUFXOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixZQUFZLGVBQWU7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQixzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hYnViYWtyamltb2gvRGVza3RvcC9Db2RpbmcgU3R1ZmZzL2hhY2thdGhvbi9zZWNyZXQtbmV0d29yay9tZW1lQWlfY29pbl9jcmVhdG9yL2FpLW1lbWUtY29pbi1jcmVhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS90aW55LXNlY3AyNTZrMUAxLjEuNy9ub2RlX21vZHVsZXMvdGlueS1zZWNwMjU2azEvanMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQk4gPSByZXF1aXJlKCdibi5qcycpXG5jb25zdCBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcbmNvbnN0IHNlY3AyNTZrMSA9IG5ldyBFQygnc2VjcDI1NmsxJylcbmNvbnN0IGRldGVybWluaXN0aWNHZW5lcmF0ZUsgPSByZXF1aXJlKCcuL3JmYzY5NzknKVxuXG5jb25zdCBaRVJPMzIgPSBCdWZmZXIuYWxsb2MoMzIsIDApXG5jb25zdCBFQ19HUk9VUF9PUkRFUiA9IEJ1ZmZlci5mcm9tKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgJ2hleCcpXG5jb25zdCBFQ19QID0gQnVmZmVyLmZyb20oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnLCAnaGV4JylcblxuY29uc3QgbiA9IHNlY3AyNTZrMS5jdXJ2ZS5uXG5jb25zdCBuRGl2MiA9IG4uc2hybigxKVxuY29uc3QgRyA9IHNlY3AyNTZrMS5jdXJ2ZS5nXG5cbmNvbnN0IFRIUk9XX0JBRF9QUklWQVRFID0gJ0V4cGVjdGVkIFByaXZhdGUnXG5jb25zdCBUSFJPV19CQURfUE9JTlQgPSAnRXhwZWN0ZWQgUG9pbnQnXG5jb25zdCBUSFJPV19CQURfVFdFQUsgPSAnRXhwZWN0ZWQgVHdlYWsnXG5jb25zdCBUSFJPV19CQURfSEFTSCA9ICdFeHBlY3RlZCBIYXNoJ1xuY29uc3QgVEhST1dfQkFEX1NJR05BVFVSRSA9ICdFeHBlY3RlZCBTaWduYXR1cmUnXG5jb25zdCBUSFJPV19CQURfRVhUUkFfREFUQSA9ICdFeHBlY3RlZCBFeHRyYSBEYXRhICgzMiBieXRlcyknXG5cbmZ1bmN0aW9uIGlzU2NhbGFyICh4KSB7XG4gIHJldHVybiAoeCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICYmIHgubGVuZ3RoID09PSAzMlxufVxuXG5mdW5jdGlvbiBpc09yZGVyU2NhbGFyICh4KSB7XG4gIGlmICghaXNTY2FsYXIoeCkpIHJldHVybiBmYWxzZVxuICByZXR1cm4gRUNfR1JPVVBfT1JERVIuY29tcGFyZSh4KSA+IDAgLy8gPCBHXG59XG5cbmZ1bmN0aW9uIGlzUG9pbnQgKHApIHtcbiAgaWYgKCEocCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSByZXR1cm4gZmFsc2VcbiAgaWYgKHAubGVuZ3RoIDwgMzMpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IHQgPSBwWzBdXG4gIGNvbnN0IHggPSBwLnN1YmFycmF5KDEsIDMzKVxuICBpZiAoWkVSTzMyLmNvbXBhcmUoeCkgPT09IDApIHJldHVybiBmYWxzZVxuICBpZiAoRUNfUC5jb21wYXJlKHgpIDw9IDApIHJldHVybiBmYWxzZVxuICBpZiAoKHQgPT09IDB4MDIgfHwgdCA9PT0gMHgwMykgJiYgcC5sZW5ndGggPT09IDMzKSB7XG4gICAgdHJ5IHsgZGVjb2RlRnJvbShwKSB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZSB9IC8vIFRPRE86IHRlbXBvcmFyeVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCB5ID0gcC5zdWJhcnJheSgzMylcbiAgaWYgKFpFUk8zMi5jb21wYXJlKHkpID09PSAwKSByZXR1cm4gZmFsc2VcbiAgaWYgKEVDX1AuY29tcGFyZSh5KSA8PSAwKSByZXR1cm4gZmFsc2VcbiAgaWYgKHQgPT09IDB4MDQgJiYgcC5sZW5ndGggPT09IDY1KSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gX19pc1BvaW50Q29tcHJlc3NlZCAocCkge1xuICByZXR1cm4gcFswXSAhPT0gMHgwNFxufVxuXG5mdW5jdGlvbiBpc1BvaW50Q29tcHJlc3NlZCAocCkge1xuICBpZiAoIWlzUG9pbnQocCkpIHJldHVybiBmYWxzZVxuICByZXR1cm4gX19pc1BvaW50Q29tcHJlc3NlZChwKVxufVxuXG5mdW5jdGlvbiBpc1ByaXZhdGUgKHgpIHtcbiAgaWYgKCFpc1NjYWxhcih4KSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBaRVJPMzIuY29tcGFyZSh4KSA8IDAgJiYgLy8gPiAwXG4gICAgRUNfR1JPVVBfT1JERVIuY29tcGFyZSh4KSA+IDAgLy8gPCBHXG59XG5cbmZ1bmN0aW9uIGlzU2lnbmF0dXJlICh2YWx1ZSkge1xuICBjb25zdCByID0gdmFsdWUuc3ViYXJyYXkoMCwgMzIpXG4gIGNvbnN0IHMgPSB2YWx1ZS5zdWJhcnJheSgzMiwgNjQpXG4gIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJiB2YWx1ZS5sZW5ndGggPT09IDY0ICYmXG4gICAgRUNfR1JPVVBfT1JERVIuY29tcGFyZShyKSA+IDAgJiZcbiAgICBFQ19HUk9VUF9PUkRFUi5jb21wYXJlKHMpID4gMFxufVxuXG5mdW5jdGlvbiBhc3N1bWVDb21wcmVzc2lvbiAodmFsdWUsIHB1YmtleSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwdWJrZXkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIF9faXNQb2ludENvbXByZXNzZWQocHVia2V5KVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIHZhbHVlXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKGQpIHsgcmV0dXJuIG5ldyBCTihkKSB9XG5mdW5jdGlvbiB0b0J1ZmZlciAoZCkgeyByZXR1cm4gZC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKSB9XG5mdW5jdGlvbiBkZWNvZGVGcm9tIChQKSB7IHJldHVybiBzZWNwMjU2azEuY3VydmUuZGVjb2RlUG9pbnQoUCkgfVxuZnVuY3Rpb24gZ2V0RW5jb2RlZCAoUCwgY29tcHJlc3NlZCkgeyByZXR1cm4gQnVmZmVyLmZyb20oUC5fZW5jb2RlKGNvbXByZXNzZWQpKSB9XG5cbmZ1bmN0aW9uIHBvaW50QWRkIChwQSwgcEIsIF9fY29tcHJlc3NlZCkge1xuICBpZiAoIWlzUG9pbnQocEEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9QT0lOVClcbiAgaWYgKCFpc1BvaW50KHBCKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUE9JTlQpXG5cbiAgY29uc3QgYSA9IGRlY29kZUZyb20ocEEpXG4gIGNvbnN0IGIgPSBkZWNvZGVGcm9tKHBCKVxuICBjb25zdCBwcCA9IGEuYWRkKGIpXG4gIGlmIChwcC5pc0luZmluaXR5KCkpIHJldHVybiBudWxsXG5cbiAgY29uc3QgY29tcHJlc3NlZCA9IGFzc3VtZUNvbXByZXNzaW9uKF9fY29tcHJlc3NlZCwgcEEpXG4gIHJldHVybiBnZXRFbmNvZGVkKHBwLCBjb21wcmVzc2VkKVxufVxuXG5mdW5jdGlvbiBwb2ludEFkZFNjYWxhciAocCwgdHdlYWssIF9fY29tcHJlc3NlZCkge1xuICBpZiAoIWlzUG9pbnQocCkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BPSU5UKVxuICBpZiAoIWlzT3JkZXJTY2FsYXIodHdlYWspKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9UV0VBSylcblxuICBjb25zdCBjb21wcmVzc2VkID0gYXNzdW1lQ29tcHJlc3Npb24oX19jb21wcmVzc2VkLCBwKVxuICBjb25zdCBwcCA9IGRlY29kZUZyb20ocClcbiAgaWYgKFpFUk8zMi5jb21wYXJlKHR3ZWFrKSA9PT0gMCkgcmV0dXJuIGdldEVuY29kZWQocHAsIGNvbXByZXNzZWQpXG5cbiAgY29uc3QgdHQgPSBmcm9tQnVmZmVyKHR3ZWFrKVxuICBjb25zdCBxcSA9IEcubXVsKHR0KVxuICBjb25zdCB1dSA9IHBwLmFkZChxcSlcbiAgaWYgKHV1LmlzSW5maW5pdHkoKSkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZ2V0RW5jb2RlZCh1dSwgY29tcHJlc3NlZClcbn1cblxuZnVuY3Rpb24gcG9pbnRDb21wcmVzcyAocCwgX19jb21wcmVzc2VkKSB7XG4gIGlmICghaXNQb2ludChwKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUE9JTlQpXG5cbiAgY29uc3QgcHAgPSBkZWNvZGVGcm9tKHApXG4gIGlmIChwcC5pc0luZmluaXR5KCkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BPSU5UKVxuXG4gIGNvbnN0IGNvbXByZXNzZWQgPSBhc3N1bWVDb21wcmVzc2lvbihfX2NvbXByZXNzZWQsIHApXG5cbiAgcmV0dXJuIGdldEVuY29kZWQocHAsIGNvbXByZXNzZWQpXG59XG5cbmZ1bmN0aW9uIHBvaW50RnJvbVNjYWxhciAoZCwgX19jb21wcmVzc2VkKSB7XG4gIGlmICghaXNQcml2YXRlKGQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9QUklWQVRFKVxuXG4gIGNvbnN0IGRkID0gZnJvbUJ1ZmZlcihkKVxuICBjb25zdCBwcCA9IEcubXVsKGRkKVxuICBpZiAocHAuaXNJbmZpbml0eSgpKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IGNvbXByZXNzZWQgPSBhc3N1bWVDb21wcmVzc2lvbihfX2NvbXByZXNzZWQpXG4gIHJldHVybiBnZXRFbmNvZGVkKHBwLCBjb21wcmVzc2VkKVxufVxuXG5mdW5jdGlvbiBwb2ludE11bHRpcGx5IChwLCB0d2VhaywgX19jb21wcmVzc2VkKSB7XG4gIGlmICghaXNQb2ludChwKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUE9JTlQpXG4gIGlmICghaXNPcmRlclNjYWxhcih0d2VhaykpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1RXRUFLKVxuXG4gIGNvbnN0IGNvbXByZXNzZWQgPSBhc3N1bWVDb21wcmVzc2lvbihfX2NvbXByZXNzZWQsIHApXG4gIGNvbnN0IHBwID0gZGVjb2RlRnJvbShwKVxuICBjb25zdCB0dCA9IGZyb21CdWZmZXIodHdlYWspXG4gIGNvbnN0IHFxID0gcHAubXVsKHR0KVxuICBpZiAocXEuaXNJbmZpbml0eSgpKSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBnZXRFbmNvZGVkKHFxLCBjb21wcmVzc2VkKVxufVxuXG5mdW5jdGlvbiBwcml2YXRlQWRkIChkLCB0d2Vhaykge1xuICBpZiAoIWlzUHJpdmF0ZShkKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUFJJVkFURSlcbiAgaWYgKCFpc09yZGVyU2NhbGFyKHR3ZWFrKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfVFdFQUspXG5cbiAgY29uc3QgZGQgPSBmcm9tQnVmZmVyKGQpXG4gIGNvbnN0IHR0ID0gZnJvbUJ1ZmZlcih0d2VhaylcbiAgY29uc3QgZHQgPSB0b0J1ZmZlcihkZC5hZGQodHQpLnVtb2QobikpXG4gIGlmICghaXNQcml2YXRlKGR0KSkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZHRcbn1cblxuZnVuY3Rpb24gcHJpdmF0ZVN1YiAoZCwgdHdlYWspIHtcbiAgaWYgKCFpc1ByaXZhdGUoZCkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BSSVZBVEUpXG4gIGlmICghaXNPcmRlclNjYWxhcih0d2VhaykpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1RXRUFLKVxuXG4gIGNvbnN0IGRkID0gZnJvbUJ1ZmZlcihkKVxuICBjb25zdCB0dCA9IGZyb21CdWZmZXIodHdlYWspXG4gIGNvbnN0IGR0ID0gdG9CdWZmZXIoZGQuc3ViKHR0KS51bW9kKG4pKVxuICBpZiAoIWlzUHJpdmF0ZShkdCkpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGR0XG59XG5cbmZ1bmN0aW9uIHNpZ24gKGhhc2gsIHgpIHtcbiAgcmV0dXJuIF9fc2lnbihoYXNoLCB4KVxufVxuXG5mdW5jdGlvbiBzaWduV2l0aEVudHJvcHkgKGhhc2gsIHgsIGFkZERhdGEpIHtcbiAgcmV0dXJuIF9fc2lnbihoYXNoLCB4LCBhZGREYXRhKVxufVxuXG5mdW5jdGlvbiBfX3NpZ24gKGhhc2gsIHgsIGFkZERhdGEpIHtcbiAgaWYgKCFpc1NjYWxhcihoYXNoKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfSEFTSClcbiAgaWYgKCFpc1ByaXZhdGUoeCkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BSSVZBVEUpXG4gIGlmIChhZGREYXRhICE9PSB1bmRlZmluZWQgJiYgIWlzU2NhbGFyKGFkZERhdGEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9FWFRSQV9EQVRBKVxuXG4gIGNvbnN0IGQgPSBmcm9tQnVmZmVyKHgpXG4gIGNvbnN0IGUgPSBmcm9tQnVmZmVyKGhhc2gpXG5cbiAgbGV0IHIsIHNcbiAgY29uc3QgY2hlY2tTaWcgPSBmdW5jdGlvbiAoaykge1xuICAgIGNvbnN0IGtJID0gZnJvbUJ1ZmZlcihrKVxuICAgIGNvbnN0IFEgPSBHLm11bChrSSlcblxuICAgIGlmIChRLmlzSW5maW5pdHkoKSkgcmV0dXJuIGZhbHNlXG5cbiAgICByID0gUS54LnVtb2QobilcbiAgICBpZiAoci5pc1plcm8oKSA9PT0gMCkgcmV0dXJuIGZhbHNlXG5cbiAgICBzID0ga0lcbiAgICAgIC5pbnZtKG4pXG4gICAgICAubXVsKGUuYWRkKGQubXVsKHIpKSlcbiAgICAgIC51bW9kKG4pXG4gICAgaWYgKHMuaXNaZXJvKCkgPT09IDApIHJldHVybiBmYWxzZVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRldGVybWluaXN0aWNHZW5lcmF0ZUsoaGFzaCwgeCwgY2hlY2tTaWcsIGlzUHJpdmF0ZSwgYWRkRGF0YSlcblxuICAvLyBlbmZvcmNlIGxvdyBTIHZhbHVlcywgc2VlIGJpcDYyOiAnbG93IHMgdmFsdWVzIGluIHNpZ25hdHVyZXMnXG4gIGlmIChzLmNtcChuRGl2MikgPiAwKSB7XG4gICAgcyA9IG4uc3ViKHMpXG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNjQpXG4gIHRvQnVmZmVyKHIpLmNvcHkoYnVmZmVyLCAwKVxuICB0b0J1ZmZlcihzKS5jb3B5KGJ1ZmZlciwgMzIpXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gdmVyaWZ5IChoYXNoLCBxLCBzaWduYXR1cmUsIHN0cmljdCkge1xuICBpZiAoIWlzU2NhbGFyKGhhc2gpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9IQVNIKVxuICBpZiAoIWlzUG9pbnQocSkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BPSU5UKVxuXG4gIC8vIDEuNC4xIEVuZm9yY2UgciBhbmQgcyBhcmUgYm90aCBpbnRlZ2VycyBpbiB0aGUgaW50ZXJ2YWwgWzEsIG4g4oiSIDFdICgxLCBpc1NpZ25hdHVyZSBlbmZvcmNlcyAnPCBuIC0gMScpXG4gIGlmICghaXNTaWduYXR1cmUoc2lnbmF0dXJlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfU0lHTkFUVVJFKVxuXG4gIGNvbnN0IFEgPSBkZWNvZGVGcm9tKHEpXG4gIGNvbnN0IHIgPSBmcm9tQnVmZmVyKHNpZ25hdHVyZS5zdWJhcnJheSgwLCAzMikpXG4gIGNvbnN0IHMgPSBmcm9tQnVmZmVyKHNpZ25hdHVyZS5zdWJhcnJheSgzMiwgNjQpKVxuXG4gIGlmIChzdHJpY3QgJiYgcy5jbXAobkRpdjIpID4gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gMS40LjEgRW5mb3JjZSByIGFuZCBzIGFyZSBib3RoIGludGVnZXJzIGluIHRoZSBpbnRlcnZhbCBbMSwgbiDiiJIgMV0gKDIsIGVuZm9yY2VzICc+IDAnKVxuICBpZiAoci5ndG4oMCkgPD0gMCAvKiB8fCByLmNvbXBhcmVUbyhuKSA+PSAwICovKSByZXR1cm4gZmFsc2VcbiAgaWYgKHMuZ3RuKDApIDw9IDAgLyogfHwgcy5jb21wYXJlVG8obikgPj0gMCAqLykgcmV0dXJuIGZhbHNlXG5cbiAgLy8gMS40LjIgSCA9IEhhc2goTSksIGFscmVhZHkgZG9uZSBieSB0aGUgdXNlclxuICAvLyAxLjQuMyBlID0gSFxuICBjb25zdCBlID0gZnJvbUJ1ZmZlcihoYXNoKVxuXG4gIC8vIENvbXB1dGUgc14tMVxuICBjb25zdCBzSW52ID0gcy5pbnZtKG4pXG5cbiAgLy8gMS40LjQgQ29tcHV0ZSB1MSA9IGVzXuKIkjEgbW9kIG5cbiAgLy8gICAgICAgICAgICAgICB1MiA9IHJzXuKIkjEgbW9kIG5cbiAgY29uc3QgdTEgPSBlLm11bChzSW52KS51bW9kKG4pXG4gIGNvbnN0IHUyID0gci5tdWwoc0ludikudW1vZChuKVxuXG4gIC8vIDEuNC41IENvbXB1dGUgUiA9ICh4UiwgeVIpXG4gIC8vICAgICAgICAgICAgICAgUiA9IHUxRyArIHUyUVxuICBjb25zdCBSID0gRy5tdWxBZGQodTEsIFEsIHUyKVxuXG4gIC8vIDEuNC41IChjb250LikgRW5mb3JjZSBSIGlzIG5vdCBhdCBpbmZpbml0eVxuICBpZiAoUi5pc0luZmluaXR5KCkpIHJldHVybiBmYWxzZVxuXG4gIC8vIDEuNC42IENvbnZlcnQgdGhlIGZpZWxkIGVsZW1lbnQgUi54IHRvIGFuIGludGVnZXJcbiAgY29uc3QgeFIgPSBSLnhcblxuICAvLyAxLjQuNyBTZXQgdiA9IHhSIG1vZCBuXG4gIGNvbnN0IHYgPSB4Ui51bW9kKG4pXG5cbiAgLy8gMS40LjggSWYgdiA9IHIsIG91dHB1dCBcInZhbGlkXCIsIGFuZCBpZiB2ICE9IHIsIG91dHB1dCBcImludmFsaWRcIlxuICByZXR1cm4gdi5lcShyKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNQb2ludCxcbiAgaXNQb2ludENvbXByZXNzZWQsXG4gIGlzUHJpdmF0ZSxcbiAgcG9pbnRBZGQsXG4gIHBvaW50QWRkU2NhbGFyLFxuICBwb2ludENvbXByZXNzLFxuICBwb2ludEZyb21TY2FsYXIsXG4gIHBvaW50TXVsdGlwbHksXG4gIHByaXZhdGVBZGQsXG4gIHByaXZhdGVTdWIsXG4gIHNpZ24sXG4gIHNpZ25XaXRoRW50cm9weSxcbiAgdmVyaWZ5XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/js.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/native.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/native.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet binding = __webpack_require__(/*! bindings */ \"(ssr)/./node_modules/.pnpm/bindings@1.5.0/node_modules/bindings/bindings.js\")('secp256k1')\ndelete binding.path\n\n// NaN drops function names, add them for is* (via toJSON)\nfor (let key in binding) {\n  if (key.indexOf('is') !== 0) continue\n\n  binding[key].toJSON = function () { return key }\n}\n\nmodule.exports = binding\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGlueS1zZWNwMjU2azFAMS4xLjcvbm9kZV9tb2R1bGVzL3Rpbnktc2VjcDI1NmsxL25hdGl2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsNkZBQVU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0Qzs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvYWJ1YmFrcmppbW9oL0Rlc2t0b3AvQ29kaW5nIFN0dWZmcy9oYWNrYXRob24vc2VjcmV0LW5ldHdvcmsvbWVtZUFpX2NvaW5fY3JlYXRvci9haS1tZW1lLWNvaW4tY3JlYXRvci9ub2RlX21vZHVsZXMvLnBucG0vdGlueS1zZWNwMjU2azFAMS4xLjcvbm9kZV9tb2R1bGVzL3Rpbnktc2VjcDI1NmsxL25hdGl2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IGJpbmRpbmcgPSByZXF1aXJlKCdiaW5kaW5ncycpKCdzZWNwMjU2azEnKVxuZGVsZXRlIGJpbmRpbmcucGF0aFxuXG4vLyBOYU4gZHJvcHMgZnVuY3Rpb24gbmFtZXMsIGFkZCB0aGVtIGZvciBpcyogKHZpYSB0b0pTT04pXG5mb3IgKGxldCBrZXkgaW4gYmluZGluZykge1xuICBpZiAoa2V5LmluZGV4T2YoJ2lzJykgIT09IDApIGNvbnRpbnVlXG5cbiAgYmluZGluZ1trZXldLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleSB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZGluZ1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/native.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/rfc6979.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/rfc6979.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const createHmac = __webpack_require__(/*! create-hmac */ \"(ssr)/./node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/index.js\")\n\nconst ONE1 = Buffer.alloc(1, 1)\nconst ZERO1 = Buffer.alloc(1, 0)\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK (hash, x, checkSig, isPrivate, extraEntropy) {\n  // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n  let k = Buffer.alloc(32, 0)\n  let v = Buffer.alloc(32, 1)\n\n  // Step D\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ZERO1)\n    .update(x)\n    .update(hash)\n    .update(extraEntropy || '')\n    .digest()\n\n  // Step E\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step F\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ONE1)\n    .update(x)\n    .update(hash)\n    .update(extraEntropy || '')\n    .digest()\n\n  // Step G\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = createHmac('sha256', k).update(v).digest()\n\n  let T = v\n\n  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n  while (!isPrivate(T) || !checkSig(T)) {\n    k = createHmac('sha256', k)\n      .update(v)\n      .update(ZERO1)\n      .digest()\n\n    v = createHmac('sha256', k).update(v).digest()\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = createHmac('sha256', k).update(v).digest()\n    T = v\n  }\n\n  return T\n}\n\nmodule.exports = deterministicGenerateK\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGlueS1zZWNwMjU2azFAMS4xLjcvbm9kZV9tb2R1bGVzL3Rpbnktc2VjcDI1NmsxL3JmYzY5NzkuanMiLCJtYXBwaW5ncyI6IkFBQUEsbUJBQW1CLG1CQUFPLENBQUMsbUdBQWE7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvYWJ1YmFrcmppbW9oL0Rlc2t0b3AvQ29kaW5nIFN0dWZmcy9oYWNrYXRob24vc2VjcmV0LW5ldHdvcmsvbWVtZUFpX2NvaW5fY3JlYXRvci9haS1tZW1lLWNvaW4tY3JlYXRvci9ub2RlX21vZHVsZXMvLnBucG0vdGlueS1zZWNwMjU2azFAMS4xLjcvbm9kZV9tb2R1bGVzL3Rpbnktc2VjcDI1NmsxL3JmYzY5NzkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY3JlYXRlSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJylcblxuY29uc3QgT05FMSA9IEJ1ZmZlci5hbGxvYygxLCAxKVxuY29uc3QgWkVSTzEgPSBCdWZmZXIuYWxsb2MoMSwgMClcblxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5Nzkjc2VjdGlvbi0zLjJcbmZ1bmN0aW9uIGRldGVybWluaXN0aWNHZW5lcmF0ZUsgKGhhc2gsIHgsIGNoZWNrU2lnLCBpc1ByaXZhdGUsIGV4dHJhRW50cm9weSkge1xuICAvLyBTdGVwIEEsIGlnbm9yZWQgYXMgaGFzaCBhbHJlYWR5IHByb3ZpZGVkXG4gIC8vIFN0ZXAgQlxuICAvLyBTdGVwIENcbiAgbGV0IGsgPSBCdWZmZXIuYWxsb2MoMzIsIDApXG4gIGxldCB2ID0gQnVmZmVyLmFsbG9jKDMyLCAxKVxuXG4gIC8vIFN0ZXAgRFxuICBrID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaylcbiAgICAudXBkYXRlKHYpXG4gICAgLnVwZGF0ZShaRVJPMSlcbiAgICAudXBkYXRlKHgpXG4gICAgLnVwZGF0ZShoYXNoKVxuICAgIC51cGRhdGUoZXh0cmFFbnRyb3B5IHx8ICcnKVxuICAgIC5kaWdlc3QoKVxuXG4gIC8vIFN0ZXAgRVxuICB2ID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG5cbiAgLy8gU3RlcCBGXG4gIGsgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKVxuICAgIC51cGRhdGUodilcbiAgICAudXBkYXRlKE9ORTEpXG4gICAgLnVwZGF0ZSh4KVxuICAgIC51cGRhdGUoaGFzaClcbiAgICAudXBkYXRlKGV4dHJhRW50cm9weSB8fCAnJylcbiAgICAuZGlnZXN0KClcblxuICAvLyBTdGVwIEdcbiAgdiA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIGspLnVwZGF0ZSh2KS5kaWdlc3QoKVxuXG4gIC8vIFN0ZXAgSDEvSDJhLCBpZ25vcmVkIGFzIHRsZW4gPT09IHFsZW4gKDI1NiBiaXQpXG4gIC8vIFN0ZXAgSDJiXG4gIHYgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKS51cGRhdGUodikuZGlnZXN0KClcblxuICBsZXQgVCA9IHZcblxuICAvLyBTdGVwIEgzLCByZXBlYXQgdW50aWwgVCBpcyB3aXRoaW4gdGhlIGludGVydmFsIFsxLCBuIC0gMV0gYW5kIGlzIHN1aXRhYmxlIGZvciBFQ0RTQVxuICB3aGlsZSAoIWlzUHJpdmF0ZShUKSB8fCAhY2hlY2tTaWcoVCkpIHtcbiAgICBrID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaylcbiAgICAgIC51cGRhdGUodilcbiAgICAgIC51cGRhdGUoWkVSTzEpXG4gICAgICAuZGlnZXN0KClcblxuICAgIHYgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKS51cGRhdGUodikuZGlnZXN0KClcblxuICAgIC8vIFN0ZXAgSDEvSDJhLCBhZ2FpbiwgaWdub3JlZCBhcyB0bGVuID09PSBxbGVuICgyNTYgYml0KVxuICAgIC8vIFN0ZXAgSDJiIGFnYWluXG4gICAgdiA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIGspLnVwZGF0ZSh2KS5kaWdlc3QoKVxuICAgIFQgPSB2XG4gIH1cblxuICByZXR1cm4gVFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRldGVybWluaXN0aWNHZW5lcmF0ZUtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/rfc6979.js\n");

/***/ })

};
;