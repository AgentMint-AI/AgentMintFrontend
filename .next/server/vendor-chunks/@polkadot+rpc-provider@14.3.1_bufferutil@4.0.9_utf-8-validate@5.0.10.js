"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10";
exports.ids = ["vendor-chunks/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/coder/error.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/coder/error.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RpcError)\n/* harmony export */ });\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/is/function.js\");\n\nconst UNKNOWN = -99999;\nfunction extend(that, name, value) {\n    Object.defineProperty(that, name, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n}\n/**\n * @name RpcError\n * @summary Extension to the basic JS Error.\n * @description\n * The built-in JavaScript Error class is extended by adding a code to allow for Error categorization. In addition to the normal `stack`, `message`, the numeric `code` and `data` (any types) parameters are available on the object.\n * @example\n * <BR>\n *\n * ```javascript\n * const { RpcError } from '@polkadot/util');\n *\n * throw new RpcError('some message', RpcError.CODES.METHOD_NOT_FOUND); // => error.code = -32601\n * ```\n */\nclass RpcError extends Error {\n    code;\n    data;\n    message;\n    name;\n    stack;\n    constructor(message = '', code = UNKNOWN, data) {\n        super();\n        extend(this, 'message', String(message));\n        extend(this, 'name', this.constructor.name);\n        extend(this, 'data', data);\n        extend(this, 'code', code);\n        if ((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(Error.captureStackTrace)) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        else {\n            const { stack } = new Error(message);\n            stack && extend(this, 'stack', stack);\n        }\n    }\n    static CODES = {\n        ASSERT: -90009,\n        INVALID_JSONRPC: -99998,\n        METHOD_NOT_FOUND: -32601, // Rust client\n        UNKNOWN\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvY29kZXIvZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hYnViYWtyamltb2gvRGVza3RvcC9Db2RpbmcgU3R1ZmZzL2hhY2thdGhvbi9zZWNyZXQtbmV0d29yay9tZW1lQWlfY29pbl9jcmVhdG9yL2FpLW1lbWUtY29pbi1jcmVhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS9AcG9sa2Fkb3QrcnBjLXByb3ZpZGVyQDE0LjMuMV9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvQHBvbGthZG90L3JwYy1wcm92aWRlci9jb2Rlci9lcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnQHBvbGthZG90L3V0aWwnO1xuY29uc3QgVU5LTk9XTiA9IC05OTk5OTtcbmZ1bmN0aW9uIGV4dGVuZCh0aGF0LCBuYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGF0LCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlXG4gICAgfSk7XG59XG4vKipcbiAqIEBuYW1lIFJwY0Vycm9yXG4gKiBAc3VtbWFyeSBFeHRlbnNpb24gdG8gdGhlIGJhc2ljIEpTIEVycm9yLlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYnVpbHQtaW4gSmF2YVNjcmlwdCBFcnJvciBjbGFzcyBpcyBleHRlbmRlZCBieSBhZGRpbmcgYSBjb2RlIHRvIGFsbG93IGZvciBFcnJvciBjYXRlZ29yaXphdGlvbi4gSW4gYWRkaXRpb24gdG8gdGhlIG5vcm1hbCBgc3RhY2tgLCBgbWVzc2FnZWAsIHRoZSBudW1lcmljIGBjb2RlYCBhbmQgYGRhdGFgIChhbnkgdHlwZXMpIHBhcmFtZXRlcnMgYXJlIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIDxCUj5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCB7IFJwY0Vycm9yIH0gZnJvbSAnQHBvbGthZG90L3V0aWwnKTtcbiAqXG4gKiB0aHJvdyBuZXcgUnBjRXJyb3IoJ3NvbWUgbWVzc2FnZScsIFJwY0Vycm9yLkNPREVTLk1FVEhPRF9OT1RfRk9VTkQpOyAvLyA9PiBlcnJvci5jb2RlID0gLTMyNjAxXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnBjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29kZTtcbiAgICBkYXRhO1xuICAgIG1lc3NhZ2U7XG4gICAgbmFtZTtcbiAgICBzdGFjaztcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJycsIGNvZGUgPSBVTktOT1dOLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGV4dGVuZCh0aGlzLCAnbWVzc2FnZScsIFN0cmluZyhtZXNzYWdlKSk7XG4gICAgICAgIGV4dGVuZCh0aGlzLCAnbmFtZScsIHRoaXMuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIGV4dGVuZCh0aGlzLCAnZGF0YScsIGRhdGEpO1xuICAgICAgICBleHRlbmQodGhpcywgJ2NvZGUnLCBjb2RlKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhY2sgfSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHN0YWNrICYmIGV4dGVuZCh0aGlzLCAnc3RhY2snLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIENPREVTID0ge1xuICAgICAgICBBU1NFUlQ6IC05MDAwOSxcbiAgICAgICAgSU5WQUxJRF9KU09OUlBDOiAtOTk5OTgsXG4gICAgICAgIE1FVEhPRF9OT1RfRk9VTkQ6IC0zMjYwMSwgLy8gUnVzdCBjbGllbnRcbiAgICAgICAgVU5LTk9XTlxuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/coder/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/coder/index.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/coder/index.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RpcCoder: () => (/* binding */ RpcCoder)\n/* harmony export */ });\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/is/undefined.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/is/string.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/stringify.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/is/number.js\");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./error.js */ \"(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/coder/error.js\");\n\n\nfunction formatErrorData(data) {\n    if ((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(data)) {\n        return '';\n    }\n    const formatted = `: ${(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_1__.isString)(data)\n        ? data.replace(/Error\\(\"/g, '').replace(/\\(\"/g, '(').replace(/\"\\)/g, ')').replace(/\\(/g, ', ').replace(/\\)/g, '')\n        : (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(data)}`;\n    // We need some sort of cut-off here since these can be very large and\n    // very nested, pick a number and trim the result display to it\n    return formatted.length <= 256\n        ? formatted\n        : `${formatted.substring(0, 255)}â€¦`;\n}\nfunction checkError(error) {\n    if (error) {\n        const { code, data, message } = error;\n        throw new _error_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](`${code}: ${message}${formatErrorData(data)}`, code, data);\n    }\n}\n/** @internal */\nclass RpcCoder {\n    __internal__id = 0;\n    decodeResponse(response) {\n        if (!response || response.jsonrpc !== '2.0') {\n            throw new Error('Invalid jsonrpc field in decoded object');\n        }\n        const isSubscription = !(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(response.params) && !(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(response.method);\n        if (!(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_4__.isNumber)(response.id) &&\n            (!isSubscription || (!(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_4__.isNumber)(response.params.subscription) &&\n                !(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_1__.isString)(response.params.subscription)))) {\n            throw new Error('Invalid id field in decoded object');\n        }\n        checkError(response.error);\n        if (response.result === undefined && !isSubscription) {\n            throw new Error('No result found in jsonrpc response');\n        }\n        if (isSubscription) {\n            checkError(response.params.error);\n            return response.params.result;\n        }\n        return response.result;\n    }\n    encodeJson(method, params) {\n        const [id, data] = this.encodeObject(method, params);\n        return [id, (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(data)];\n    }\n    encodeObject(method, params) {\n        const id = ++this.__internal__id;\n        return [id, {\n                id,\n                jsonrpc: '2.0',\n                method,\n                params\n            }];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvY29kZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRFO0FBQzFDO0FBQ2xDO0FBQ0EsUUFBUSwyREFBVztBQUNuQjtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFRO0FBQ25DO0FBQ0EsVUFBVSx5REFBUyxPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QyxrQkFBa0IsaURBQVEsSUFBSSxLQUFLLElBQUksUUFBUSxFQUFFLHNCQUFzQjtBQUN2RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQVcsc0JBQXNCLDJEQUFXO0FBQzVFLGFBQWEsd0RBQVE7QUFDckIsa0NBQWtDLHdEQUFRO0FBQzFDLGlCQUFpQix3REFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWJ1YmFrcmppbW9oL0Rlc2t0b3AvQ29kaW5nIFN0dWZmcy9oYWNrYXRob24vc2VjcmV0LW5ldHdvcmsvbWVtZUFpX2NvaW5fY3JlYXRvci9haS1tZW1lLWNvaW4tY3JlYXRvci9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvY29kZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOdW1iZXIsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCwgc3RyaW5naWZ5IH0gZnJvbSAnQHBvbGthZG90L3V0aWwnO1xuaW1wb3J0IFJwY0Vycm9yIGZyb20gJy4vZXJyb3IuanMnO1xuZnVuY3Rpb24gZm9ybWF0RXJyb3JEYXRhKGRhdGEpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBgOiAke2lzU3RyaW5nKGRhdGEpXG4gICAgICAgID8gZGF0YS5yZXBsYWNlKC9FcnJvclxcKFwiL2csICcnKS5yZXBsYWNlKC9cXChcIi9nLCAnKCcpLnJlcGxhY2UoL1wiXFwpL2csICcpJykucmVwbGFjZSgvXFwoL2csICcsICcpLnJlcGxhY2UoL1xcKS9nLCAnJylcbiAgICAgICAgOiBzdHJpbmdpZnkoZGF0YSl9YDtcbiAgICAvLyBXZSBuZWVkIHNvbWUgc29ydCBvZiBjdXQtb2ZmIGhlcmUgc2luY2UgdGhlc2UgY2FuIGJlIHZlcnkgbGFyZ2UgYW5kXG4gICAgLy8gdmVyeSBuZXN0ZWQsIHBpY2sgYSBudW1iZXIgYW5kIHRyaW0gdGhlIHJlc3VsdCBkaXNwbGF5IHRvIGl0XG4gICAgcmV0dXJuIGZvcm1hdHRlZC5sZW5ndGggPD0gMjU2XG4gICAgICAgID8gZm9ybWF0dGVkXG4gICAgICAgIDogYCR7Zm9ybWF0dGVkLnN1YnN0cmluZygwLCAyNTUpfeKApmA7XG59XG5mdW5jdGlvbiBjaGVja0Vycm9yKGVycm9yKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgY29kZSwgZGF0YSwgbWVzc2FnZSB9ID0gZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBScGNFcnJvcihgJHtjb2RlfTogJHttZXNzYWdlfSR7Zm9ybWF0RXJyb3JEYXRhKGRhdGEpfWAsIGNvZGUsIGRhdGEpO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBScGNDb2RlciB7XG4gICAgX19pbnRlcm5hbF9faWQgPSAwO1xuICAgIGRlY29kZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2UgfHwgcmVzcG9uc2UuanNvbnJwYyAhPT0gJzIuMCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBqc29ucnBjIGZpZWxkIGluIGRlY29kZWQgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNTdWJzY3JpcHRpb24gPSAhaXNVbmRlZmluZWQocmVzcG9uc2UucGFyYW1zKSAmJiAhaXNVbmRlZmluZWQocmVzcG9uc2UubWV0aG9kKTtcbiAgICAgICAgaWYgKCFpc051bWJlcihyZXNwb25zZS5pZCkgJiZcbiAgICAgICAgICAgICghaXNTdWJzY3JpcHRpb24gfHwgKCFpc051bWJlcihyZXNwb25zZS5wYXJhbXMuc3Vic2NyaXB0aW9uKSAmJlxuICAgICAgICAgICAgICAgICFpc1N0cmluZyhyZXNwb25zZS5wYXJhbXMuc3Vic2NyaXB0aW9uKSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaWQgZmllbGQgaW4gZGVjb2RlZCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0Vycm9yKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3VsdCA9PT0gdW5kZWZpbmVkICYmICFpc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXN1bHQgZm91bmQgaW4ganNvbnJwYyByZXNwb25zZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgY2hlY2tFcnJvcihyZXNwb25zZS5wYXJhbXMuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnBhcmFtcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICB9XG4gICAgZW5jb2RlSnNvbihtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBbaWQsIGRhdGFdID0gdGhpcy5lbmNvZGVPYmplY3QobWV0aG9kLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gW2lkLCBzdHJpbmdpZnkoZGF0YSldO1xuICAgIH1cbiAgICBlbmNvZGVPYmplY3QobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgaWQgPSArK3RoaXMuX19pbnRlcm5hbF9faWQ7XG4gICAgICAgIHJldHVybiBbaWQsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICB9XTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/coder/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/defaults.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/defaults.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst HTTP_URL = 'http://127.0.0.1:9933';\nconst WS_URL = 'ws://127.0.0.1:9944';\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    HTTP_URL,\n    WS_URL\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL0Bwb2xrYWRvdCtycGMtcHJvdmlkZXJAMTQuMy4xX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QvcnBjLXByb3ZpZGVyL2RlZmF1bHRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEhUVFBfVVJMID0gJ2h0dHA6Ly8xMjcuMC4wLjE6OTkzMyc7XG5jb25zdCBXU19VUkwgPSAnd3M6Ly8xMjcuMC4wLjE6OTk0NCc7XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgSFRUUF9VUkwsXG4gICAgV1NfVVJMXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/defaults.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/http/index.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/http/index.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpProvider: () => (/* binding */ HttpProvider)\n/* harmony export */ });\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/logger.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/noop.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/stringify.js\");\n/* harmony import */ var _polkadot_x_fetch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polkadot/x-fetch */ \"(rsc)/./node_modules/.pnpm/@polkadot+x-fetch@13.4.3/node_modules/@polkadot/x-fetch/node.js\");\n/* harmony import */ var _coder_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coder/index.js */ \"(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/coder/index.js\");\n/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../defaults.js */ \"(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/defaults.js\");\n/* harmony import */ var _lru_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lru.js */ \"(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/lru.js\");\n\n\n\n\n\nconst ERROR_SUBSCRIBE = 'HTTP Provider does not have subscriptions, use WebSockets instead';\nconst l = (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.logger)('api-http');\n/**\n * # @polkadot/rpc-provider\n *\n * @name HttpProvider\n *\n * @description The HTTP Provider allows sending requests using HTTP to a HTTP RPC server TCP port. It does not support subscriptions so you won't be able to listen to events such as new blocks or balance changes. It is usually preferable using the [[WsProvider]].\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { HttpProvider } from '@polkadot/rpc-provider';\n *\n * const provider = new HttpProvider('http://127.0.0.1:9933');\n * const api = new Api(provider);\n * ```\n *\n * @see [[WsProvider]]\n */\nclass HttpProvider {\n    __internal__callCache;\n    __internal__cacheCapacity;\n    __internal__coder;\n    __internal__endpoint;\n    __internal__headers;\n    __internal__stats;\n    /**\n     * @param {string} endpoint The endpoint url starting with http://\n     */\n    constructor(endpoint = _defaults_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].HTTP_URL, headers = {}, cacheCapacity) {\n        if (!/^(https|http):\\/\\//.test(endpoint)) {\n            throw new Error(`Endpoint should start with 'http://' or 'https://', received '${endpoint}'`);\n        }\n        this.__internal__coder = new _coder_index_js__WEBPACK_IMPORTED_MODULE_2__.RpcCoder();\n        this.__internal__endpoint = endpoint;\n        this.__internal__headers = headers;\n        this.__internal__callCache = new _lru_js__WEBPACK_IMPORTED_MODULE_3__.LRUCache(cacheCapacity === 0 ? 0 : cacheCapacity || _lru_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CAPACITY);\n        this.__internal__cacheCapacity = cacheCapacity === 0 ? 0 : cacheCapacity || _lru_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CAPACITY;\n        this.__internal__stats = {\n            active: { requests: 0, subscriptions: 0 },\n            total: { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 }\n        };\n    }\n    /**\n     * @summary `true` when this provider supports subscriptions\n     */\n    get hasSubscriptions() {\n        return !!false;\n    }\n    /**\n     * @description Returns a clone of the object\n     */\n    clone() {\n        return new HttpProvider(this.__internal__endpoint, this.__internal__headers);\n    }\n    /**\n     * @description Manually connect from the connection\n     */\n    async connect() {\n        // noop\n    }\n    /**\n     * @description Manually disconnect from the connection\n     */\n    async disconnect() {\n        // noop\n    }\n    /**\n     * @description Returns the connection stats\n     */\n    get stats() {\n        return this.__internal__stats;\n    }\n    /**\n     * @summary `true` when this provider supports clone()\n     */\n    get isClonable() {\n        return !!true;\n    }\n    /**\n     * @summary Whether the node is connected or not.\n     * @return {boolean} true if connected\n     */\n    get isConnected() {\n        return !!true;\n    }\n    /**\n     * @summary Events are not supported with the HttpProvider, see [[WsProvider]].\n     * @description HTTP Provider does not have 'on' emitters. WebSockets should be used instead.\n     */\n    on(_type, _sub) {\n        l.error('HTTP Provider does not have \\'on\\' emitters, use WebSockets instead');\n        return _polkadot_util__WEBPACK_IMPORTED_MODULE_4__.noop;\n    }\n    /**\n     * @summary Send HTTP POST Request with Body to configured HTTP Endpoint.\n     */\n    async send(method, params, isCacheable) {\n        this.__internal__stats.total.requests++;\n        const [, body] = this.__internal__coder.encodeJson(method, params);\n        if (this.__internal__cacheCapacity === 0) {\n            return this.__internal__send(body);\n        }\n        const cacheKey = isCacheable ? `${method}::${(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_5__.stringify)(params)}` : '';\n        let resultPromise = isCacheable\n            ? this.__internal__callCache.get(cacheKey)\n            : null;\n        if (!resultPromise) {\n            resultPromise = this.__internal__send(body);\n            if (isCacheable) {\n                this.__internal__callCache.set(cacheKey, resultPromise);\n            }\n        }\n        else {\n            this.__internal__stats.total.cached++;\n        }\n        return resultPromise;\n    }\n    async __internal__send(body) {\n        this.__internal__stats.active.requests++;\n        this.__internal__stats.total.bytesSent += body.length;\n        try {\n            const response = await (0,_polkadot_x_fetch__WEBPACK_IMPORTED_MODULE_6__.fetch)(this.__internal__endpoint, {\n                body,\n                headers: {\n                    Accept: 'application/json',\n                    'Content-Length': `${body.length}`,\n                    'Content-Type': 'application/json',\n                    ...this.__internal__headers\n                },\n                method: 'POST'\n            });\n            if (!response.ok) {\n                throw new Error(`[${response.status}]: ${response.statusText}`);\n            }\n            const result = await response.text();\n            this.__internal__stats.total.bytesRecv += result.length;\n            const decoded = this.__internal__coder.decodeResponse(JSON.parse(result));\n            this.__internal__stats.active.requests--;\n            return decoded;\n        }\n        catch (e) {\n            this.__internal__stats.active.requests--;\n            this.__internal__stats.total.errors++;\n            throw e;\n        }\n    }\n    /**\n     * @summary Subscriptions are not supported with the HttpProvider, see [[WsProvider]].\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async subscribe(_types, _method, _params, _cb) {\n        l.error(ERROR_SUBSCRIBE);\n        throw new Error(ERROR_SUBSCRIBE);\n    }\n    /**\n     * @summary Subscriptions are not supported with the HttpProvider, see [[WsProvider]].\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async unsubscribe(_type, _method, _id) {\n        l.error(ERROR_SUBSCRIBE);\n        throw new Error(ERROR_SUBSCRIBE);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvaHR0cC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF5RDtBQUNmO0FBQ0c7QUFDUDtBQUNpQjtBQUN2RDtBQUNBLFVBQVUsc0RBQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDJCQUEyQixvREFBUSx1QkFBdUI7QUFDMUQ7QUFDQSw2RkFBNkYsU0FBUztBQUN0RztBQUNBLHFDQUFxQyxxREFBUTtBQUM3QztBQUNBO0FBQ0EseUNBQXlDLDZDQUFRLDRDQUE0QyxxREFBZ0I7QUFDN0csb0ZBQW9GLHFEQUFnQjtBQUNwRztBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdEQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU8sSUFBSSx5REFBUyxTQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3REFBSztBQUN4QztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0NBQW9DLGdCQUFnQixLQUFLLG9CQUFvQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL0Bwb2xrYWRvdCtycGMtcHJvdmlkZXJAMTQuMy4xX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QvcnBjLXByb3ZpZGVyL2h0dHAvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbG9nZ2VyLCBub29wLCBzdHJpbmdpZnkgfSBmcm9tICdAcG9sa2Fkb3QvdXRpbCc7XG5pbXBvcnQgeyBmZXRjaCB9IGZyb20gJ0Bwb2xrYWRvdC94LWZldGNoJztcbmltcG9ydCB7IFJwY0NvZGVyIH0gZnJvbSAnLi4vY29kZXIvaW5kZXguanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzLmpzJztcbmltcG9ydCB7IERFRkFVTFRfQ0FQQUNJVFksIExSVUNhY2hlIH0gZnJvbSAnLi4vbHJ1LmpzJztcbmNvbnN0IEVSUk9SX1NVQlNDUklCRSA9ICdIVFRQIFByb3ZpZGVyIGRvZXMgbm90IGhhdmUgc3Vic2NyaXB0aW9ucywgdXNlIFdlYlNvY2tldHMgaW5zdGVhZCc7XG5jb25zdCBsID0gbG9nZ2VyKCdhcGktaHR0cCcpO1xuLyoqXG4gKiAjIEBwb2xrYWRvdC9ycGMtcHJvdmlkZXJcbiAqXG4gKiBAbmFtZSBIdHRwUHJvdmlkZXJcbiAqXG4gKiBAZGVzY3JpcHRpb24gVGhlIEhUVFAgUHJvdmlkZXIgYWxsb3dzIHNlbmRpbmcgcmVxdWVzdHMgdXNpbmcgSFRUUCB0byBhIEhUVFAgUlBDIHNlcnZlciBUQ1AgcG9ydC4gSXQgZG9lcyBub3Qgc3VwcG9ydCBzdWJzY3JpcHRpb25zIHNvIHlvdSB3b24ndCBiZSBhYmxlIHRvIGxpc3RlbiB0byBldmVudHMgc3VjaCBhcyBuZXcgYmxvY2tzIG9yIGJhbGFuY2UgY2hhbmdlcy4gSXQgaXMgdXN1YWxseSBwcmVmZXJhYmxlIHVzaW5nIHRoZSBbW1dzUHJvdmlkZXJdXS5cbiAqXG4gKiBAZXhhbXBsZVxuICogPEJSPlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCBBcGkgZnJvbSAnQHBvbGthZG90L2FwaS9wcm9taXNlJztcbiAqIGltcG9ydCB7IEh0dHBQcm92aWRlciB9IGZyb20gJ0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXInO1xuICpcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEh0dHBQcm92aWRlcignaHR0cDovLzEyNy4wLjAuMTo5OTMzJyk7XG4gKiBjb25zdCBhcGkgPSBuZXcgQXBpKHByb3ZpZGVyKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUgW1tXc1Byb3ZpZGVyXV1cbiAqL1xuZXhwb3J0IGNsYXNzIEh0dHBQcm92aWRlciB7XG4gICAgX19pbnRlcm5hbF9fY2FsbENhY2hlO1xuICAgIF9faW50ZXJuYWxfX2NhY2hlQ2FwYWNpdHk7XG4gICAgX19pbnRlcm5hbF9fY29kZXI7XG4gICAgX19pbnRlcm5hbF9fZW5kcG9pbnQ7XG4gICAgX19pbnRlcm5hbF9faGVhZGVycztcbiAgICBfX2ludGVybmFsX19zdGF0cztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgVGhlIGVuZHBvaW50IHVybCBzdGFydGluZyB3aXRoIGh0dHA6Ly9cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbmRwb2ludCA9IGRlZmF1bHRzLkhUVFBfVVJMLCBoZWFkZXJzID0ge30sIGNhY2hlQ2FwYWNpdHkpIHtcbiAgICAgICAgaWYgKCEvXihodHRwc3xodHRwKTpcXC9cXC8vLnRlc3QoZW5kcG9pbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVuZHBvaW50IHNob3VsZCBzdGFydCB3aXRoICdodHRwOi8vJyBvciAnaHR0cHM6Ly8nLCByZWNlaXZlZCAnJHtlbmRwb2ludH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19jb2RlciA9IG5ldyBScGNDb2RlcigpO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9faGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fY2FsbENhY2hlID0gbmV3IExSVUNhY2hlKGNhY2hlQ2FwYWNpdHkgPT09IDAgPyAwIDogY2FjaGVDYXBhY2l0eSB8fCBERUZBVUxUX0NBUEFDSVRZKTtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19jYWNoZUNhcGFjaXR5ID0gY2FjaGVDYXBhY2l0eSA9PT0gMCA/IDAgOiBjYWNoZUNhcGFjaXR5IHx8IERFRkFVTFRfQ0FQQUNJVFk7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fc3RhdHMgPSB7XG4gICAgICAgICAgICBhY3RpdmU6IHsgcmVxdWVzdHM6IDAsIHN1YnNjcmlwdGlvbnM6IDAgfSxcbiAgICAgICAgICAgIHRvdGFsOiB7IGJ5dGVzUmVjdjogMCwgYnl0ZXNTZW50OiAwLCBjYWNoZWQ6IDAsIGVycm9yczogMCwgcmVxdWVzdHM6IDAsIHN1YnNjcmlwdGlvbnM6IDAsIHRpbWVvdXQ6IDAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBgdHJ1ZWAgd2hlbiB0aGlzIHByb3ZpZGVyIHN1cHBvcnRzIHN1YnNjcmlwdGlvbnNcbiAgICAgKi9cbiAgICBnZXQgaGFzU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuICEhZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEh0dHBQcm92aWRlcih0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50LCB0aGlzLl9faW50ZXJuYWxfX2hlYWRlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gTWFudWFsbHkgY29ubmVjdCBmcm9tIHRoZSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gTWFudWFsbHkgZGlzY29ubmVjdCBmcm9tIHRoZSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgY29ubmVjdGlvbiBzdGF0c1xuICAgICAqL1xuICAgIGdldCBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbF9fc3RhdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IGB0cnVlYCB3aGVuIHRoaXMgcHJvdmlkZXIgc3VwcG9ydHMgY2xvbmUoKVxuICAgICAqL1xuICAgIGdldCBpc0Nsb25hYmxlKCkge1xuICAgICAgICByZXR1cm4gISF0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBXaGV0aGVyIHRoZSBub2RlIGlzIGNvbm5lY3RlZCBvciBub3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEV2ZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRoZSBIdHRwUHJvdmlkZXIsIHNlZSBbW1dzUHJvdmlkZXJdXS5cbiAgICAgKiBAZGVzY3JpcHRpb24gSFRUUCBQcm92aWRlciBkb2VzIG5vdCBoYXZlICdvbicgZW1pdHRlcnMuIFdlYlNvY2tldHMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBvbihfdHlwZSwgX3N1Yikge1xuICAgICAgICBsLmVycm9yKCdIVFRQIFByb3ZpZGVyIGRvZXMgbm90IGhhdmUgXFwnb25cXCcgZW1pdHRlcnMsIHVzZSBXZWJTb2NrZXRzIGluc3RlYWQnKTtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNlbmQgSFRUUCBQT1NUIFJlcXVlc3Qgd2l0aCBCb2R5IHRvIGNvbmZpZ3VyZWQgSFRUUCBFbmRwb2ludC5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zLCBpc0NhY2hlYWJsZSkge1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N0YXRzLnRvdGFsLnJlcXVlc3RzKys7XG4gICAgICAgIGNvbnN0IFssIGJvZHldID0gdGhpcy5fX2ludGVybmFsX19jb2Rlci5lbmNvZGVKc29uKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHRoaXMuX19pbnRlcm5hbF9fY2FjaGVDYXBhY2l0eSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbF9fc2VuZChib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGlzQ2FjaGVhYmxlID8gYCR7bWV0aG9kfTo6JHtzdHJpbmdpZnkocGFyYW1zKX1gIDogJyc7XG4gICAgICAgIGxldCByZXN1bHRQcm9taXNlID0gaXNDYWNoZWFibGVcbiAgICAgICAgICAgID8gdGhpcy5fX2ludGVybmFsX19jYWxsQ2FjaGUuZ2V0KGNhY2hlS2V5KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoIXJlc3VsdFByb21pc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSB0aGlzLl9faW50ZXJuYWxfX3NlbmQoYm9keSk7XG4gICAgICAgICAgICBpZiAoaXNDYWNoZWFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2NhbGxDYWNoZS5zZXQoY2FjaGVLZXksIHJlc3VsdFByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19zdGF0cy50b3RhbC5jYWNoZWQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgX19pbnRlcm5hbF9fc2VuZChib2R5KSB7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fc3RhdHMuYWN0aXZlLnJlcXVlc3RzKys7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fc3RhdHMudG90YWwuYnl0ZXNTZW50ICs9IGJvZHkubGVuZ3RoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBgJHtib2R5Lmxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLl9faW50ZXJuYWxfX2hlYWRlcnNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFske3Jlc3BvbnNlLnN0YXR1c31dOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N0YXRzLnRvdGFsLmJ5dGVzUmVjdiArPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IHRoaXMuX19pbnRlcm5hbF9fY29kZXIuZGVjb2RlUmVzcG9uc2UoSlNPTi5wYXJzZShyZXN1bHQpKTtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fc3RhdHMuYWN0aXZlLnJlcXVlc3RzLS07XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19zdGF0cy5hY3RpdmUucmVxdWVzdHMtLTtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fc3RhdHMudG90YWwuZXJyb3JzKys7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFN1YnNjcmlwdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0aGUgSHR0cFByb3ZpZGVyLCBzZWUgW1tXc1Byb3ZpZGVyXV0uXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG4gICAgYXN5bmMgc3Vic2NyaWJlKF90eXBlcywgX21ldGhvZCwgX3BhcmFtcywgX2NiKSB7XG4gICAgICAgIGwuZXJyb3IoRVJST1JfU1VCU0NSSUJFKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX1NVQlNDUklCRSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFN1YnNjcmlwdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0aGUgSHR0cFByb3ZpZGVyLCBzZWUgW1tXc1Byb3ZpZGVyXV0uXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG4gICAgYXN5bmMgdW5zdWJzY3JpYmUoX3R5cGUsIF9tZXRob2QsIF9pZCkge1xuICAgICAgICBsLmVycm9yKEVSUk9SX1NVQlNDUklCRSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9TVUJTQ1JJQkUpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/http/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/lru.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/lru.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CAPACITY: () => (/* binding */ DEFAULT_CAPACITY),\n/* harmony export */   LRUCache: () => (/* binding */ LRUCache)\n/* harmony export */ });\nconst DEFAULT_CAPACITY = 1024;\nclass LRUNode {\n    key;\n    __internal__expires;\n    __internal__ttl;\n    createdAt;\n    next;\n    prev;\n    constructor(key, ttl) {\n        this.key = key;\n        this.__internal__ttl = ttl;\n        this.__internal__expires = Date.now() + ttl;\n        this.createdAt = Date.now();\n        this.next = this.prev = this;\n    }\n    refresh() {\n        this.__internal__expires = Date.now() + this.__internal__ttl;\n    }\n    get expiry() {\n        return this.__internal__expires;\n    }\n}\nclass LRUCache {\n    capacity;\n    __internal__data = new Map();\n    __internal__refs = new Map();\n    __internal__length = 0;\n    __internal__head;\n    __internal__tail;\n    __internal__ttl;\n    constructor(capacity = DEFAULT_CAPACITY, ttl = 30000) {\n        this.capacity = capacity;\n        this.__internal__ttl = ttl;\n        this.__internal__head = this.__internal__tail = new LRUNode('<empty>', ttl);\n    }\n    get ttl() {\n        return this.__internal__ttl;\n    }\n    get length() {\n        return this.__internal__length;\n    }\n    get lengthData() {\n        return this.__internal__data.size;\n    }\n    get lengthRefs() {\n        return this.__internal__refs.size;\n    }\n    entries() {\n        const keys = this.keys();\n        const count = keys.length;\n        const entries = new Array(count);\n        for (let i = 0; i < count; i++) {\n            const key = keys[i];\n            entries[i] = [key, this.__internal__data.get(key)];\n        }\n        return entries;\n    }\n    keys() {\n        const keys = [];\n        if (this.__internal__length) {\n            let curr = this.__internal__head;\n            while (curr !== this.__internal__tail) {\n                keys.push(curr.key);\n                curr = curr.next;\n            }\n            keys.push(curr.key);\n        }\n        return keys;\n    }\n    get(key) {\n        const data = this.__internal__data.get(key);\n        if (data) {\n            this.__internal__toHead(key);\n            // Evict TTL once data is refreshed\n            this.__internal__evictTTL();\n            return data;\n        }\n        this.__internal__evictTTL();\n        return null;\n    }\n    set(key, value) {\n        if (this.__internal__data.has(key)) {\n            this.__internal__toHead(key);\n        }\n        else {\n            const node = new LRUNode(key, this.__internal__ttl);\n            this.__internal__refs.set(node.key, node);\n            if (this.length === 0) {\n                this.__internal__head = this.__internal__tail = node;\n            }\n            else {\n                this.__internal__head.prev = node;\n                node.next = this.__internal__head;\n                this.__internal__head = node;\n            }\n            if (this.__internal__length === this.capacity) {\n                this.__internal__data.delete(this.__internal__tail.key);\n                this.__internal__refs.delete(this.__internal__tail.key);\n                this.__internal__tail = this.__internal__tail.prev;\n                this.__internal__tail.next = this.__internal__head;\n            }\n            else {\n                this.__internal__length += 1;\n            }\n        }\n        // Evict TTL once data is refreshed or added\n        this.__internal__evictTTL();\n        this.__internal__data.set(key, value);\n    }\n    __internal__evictTTL() {\n        // Find last node to keep\n        // traverse map to find the expired nodes\n        while (this.__internal__tail.expiry && this.__internal__tail.expiry < Date.now() && this.__internal__length > 0) {\n            this.__internal__refs.delete(this.__internal__tail.key);\n            this.__internal__data.delete(this.__internal__tail.key);\n            this.__internal__length -= 1;\n            this.__internal__tail = this.__internal__tail.prev;\n            this.__internal__tail.next = this.__internal__head;\n        }\n        if (this.__internal__length === 0) {\n            this.__internal__head = this.__internal__tail = new LRUNode('<empty>', this.__internal__ttl);\n        }\n    }\n    __internal__toHead(key) {\n        const ref = this.__internal__refs.get(key);\n        if (ref && ref !== this.__internal__head) {\n            ref.refresh();\n            ref.prev.next = ref.next;\n            ref.next.prev = ref.prev;\n            ref.next = this.__internal__head;\n            this.__internal__head.prev = ref;\n            this.__internal__head = ref;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvbHJ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWJ1YmFrcmppbW9oL0Rlc2t0b3AvQ29kaW5nIFN0dWZmcy9oYWNrYXRob24vc2VjcmV0LW5ldHdvcmsvbWVtZUFpX2NvaW5fY3JlYXRvci9haS1tZW1lLWNvaW4tY3JlYXRvci9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvbHJ1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBERUZBVUxUX0NBUEFDSVRZID0gMTAyNDtcbmNsYXNzIExSVU5vZGUge1xuICAgIGtleTtcbiAgICBfX2ludGVybmFsX19leHBpcmVzO1xuICAgIF9faW50ZXJuYWxfX3R0bDtcbiAgICBjcmVhdGVkQXQ7XG4gICAgbmV4dDtcbiAgICBwcmV2O1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdHRsKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3R0bCA9IHR0bDtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19leHBpcmVzID0gRGF0ZS5ub3coKSArIHR0bDtcbiAgICAgICAgdGhpcy5jcmVhdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLm5leHQgPSB0aGlzLnByZXYgPSB0aGlzO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2V4cGlyZXMgPSBEYXRlLm5vdygpICsgdGhpcy5fX2ludGVybmFsX190dGw7XG4gICAgfVxuICAgIGdldCBleHBpcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWxfX2V4cGlyZXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIExSVUNhY2hlIHtcbiAgICBjYXBhY2l0eTtcbiAgICBfX2ludGVybmFsX19kYXRhID0gbmV3IE1hcCgpO1xuICAgIF9faW50ZXJuYWxfX3JlZnMgPSBuZXcgTWFwKCk7XG4gICAgX19pbnRlcm5hbF9fbGVuZ3RoID0gMDtcbiAgICBfX2ludGVybmFsX19oZWFkO1xuICAgIF9faW50ZXJuYWxfX3RhaWw7XG4gICAgX19pbnRlcm5hbF9fdHRsO1xuICAgIGNvbnN0cnVjdG9yKGNhcGFjaXR5ID0gREVGQVVMVF9DQVBBQ0lUWSwgdHRsID0gMzAwMDApIHtcbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3R0bCA9IHR0bDtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19oZWFkID0gdGhpcy5fX2ludGVybmFsX190YWlsID0gbmV3IExSVU5vZGUoJzxlbXB0eT4nLCB0dGwpO1xuICAgIH1cbiAgICBnZXQgdHRsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsX190dGw7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWxfX2xlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWxfX2RhdGEuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aFJlZnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWxfX3JlZnMuc2l6ZTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cygpO1xuICAgICAgICBjb25zdCBjb3VudCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgZW50cmllc1tpXSA9IFtrZXksIHRoaXMuX19pbnRlcm5hbF9fZGF0YS5nZXQoa2V5KV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX19pbnRlcm5hbF9fbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY3VyciA9IHRoaXMuX19pbnRlcm5hbF9faGVhZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyICE9PSB0aGlzLl9faW50ZXJuYWxfX3RhaWwpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goY3Vyci5rZXkpO1xuICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlzLnB1c2goY3Vyci5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9faW50ZXJuYWxfX2RhdGEuZ2V0KGtleSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3RvSGVhZChrZXkpO1xuICAgICAgICAgICAgLy8gRXZpY3QgVFRMIG9uY2UgZGF0YSBpcyByZWZyZXNoZWRcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fZXZpY3RUVEwoKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fZXZpY3RUVEwoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9faW50ZXJuYWxfX2RhdGEuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fdG9IZWFkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbmV3IExSVU5vZGUoa2V5LCB0aGlzLl9faW50ZXJuYWxfX3R0bCk7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3JlZnMuc2V0KG5vZGUua2V5LCBub2RlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9faGVhZCA9IHRoaXMuX19pbnRlcm5hbF9fdGFpbCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2hlYWQucHJldiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZS5uZXh0ID0gdGhpcy5fX2ludGVybmFsX19oZWFkO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9faGVhZCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fX2ludGVybmFsX19sZW5ndGggPT09IHRoaXMuY2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2RhdGEuZGVsZXRlKHRoaXMuX19pbnRlcm5hbF9fdGFpbC5rZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fcmVmcy5kZWxldGUodGhpcy5fX2ludGVybmFsX190YWlsLmtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX190YWlsID0gdGhpcy5fX2ludGVybmFsX190YWlsLnByZXY7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX190YWlsLm5leHQgPSB0aGlzLl9faW50ZXJuYWxfX2hlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2xlbmd0aCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEV2aWN0IFRUTCBvbmNlIGRhdGEgaXMgcmVmcmVzaGVkIG9yIGFkZGVkXG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fZXZpY3RUVEwoKTtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19kYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgX19pbnRlcm5hbF9fZXZpY3RUVEwoKSB7XG4gICAgICAgIC8vIEZpbmQgbGFzdCBub2RlIHRvIGtlZXBcbiAgICAgICAgLy8gdHJhdmVyc2UgbWFwIHRvIGZpbmQgdGhlIGV4cGlyZWQgbm9kZXNcbiAgICAgICAgd2hpbGUgKHRoaXMuX19pbnRlcm5hbF9fdGFpbC5leHBpcnkgJiYgdGhpcy5fX2ludGVybmFsX190YWlsLmV4cGlyeSA8IERhdGUubm93KCkgJiYgdGhpcy5fX2ludGVybmFsX19sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3JlZnMuZGVsZXRlKHRoaXMuX19pbnRlcm5hbF9fdGFpbC5rZXkpO1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19kYXRhLmRlbGV0ZSh0aGlzLl9faW50ZXJuYWxfX3RhaWwua2V5KTtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fbGVuZ3RoIC09IDE7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3RhaWwgPSB0aGlzLl9faW50ZXJuYWxfX3RhaWwucHJldjtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fdGFpbC5uZXh0ID0gdGhpcy5fX2ludGVybmFsX19oZWFkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9faW50ZXJuYWxfX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19oZWFkID0gdGhpcy5fX2ludGVybmFsX190YWlsID0gbmV3IExSVU5vZGUoJzxlbXB0eT4nLCB0aGlzLl9faW50ZXJuYWxfX3R0bCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19pbnRlcm5hbF9fdG9IZWFkKGtleSkge1xuICAgICAgICBjb25zdCByZWYgPSB0aGlzLl9faW50ZXJuYWxfX3JlZnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZWYgJiYgcmVmICE9PSB0aGlzLl9faW50ZXJuYWxfX2hlYWQpIHtcbiAgICAgICAgICAgIHJlZi5yZWZyZXNoKCk7XG4gICAgICAgICAgICByZWYucHJldi5uZXh0ID0gcmVmLm5leHQ7XG4gICAgICAgICAgICByZWYubmV4dC5wcmV2ID0gcmVmLnByZXY7XG4gICAgICAgICAgICByZWYubmV4dCA9IHRoaXMuX19pbnRlcm5hbF9faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9faGVhZC5wcmV2ID0gcmVmO1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19oZWFkID0gcmVmO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/lru.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/packageInfo.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/packageInfo.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   packageInfo: () => (/* binding */ packageInfo)\n/* harmony export */ });\nconst packageInfo = { name: '@polkadot/rpc-provider', path: ( true) ? new URL(\"file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/packageInfo.js\").pathname.substring(0, new URL(\"file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/packageInfo.js\").pathname.lastIndexOf('/') + 1) : 0, type: 'esm', version: '14.3.1' };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvcGFja2FnZUluZm8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLHNCQUFzQix1Q0FBdUMsS0FBOEIsWUFBWSxnUUFBZSxnQ0FBZ0MsZ1FBQWUsbUNBQW1DLENBQU0iLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL0Bwb2xrYWRvdCtycGMtcHJvdmlkZXJAMTQuMy4xX2J1ZmZlcnV0aWxANC4wLjlfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QvcnBjLXByb3ZpZGVyL3BhY2thZ2VJbmZvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBwYWNrYWdlSW5mbyA9IHsgbmFtZTogJ0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXInLCBwYXRoOiAoaW1wb3J0Lm1ldGEgJiYgaW1wb3J0Lm1ldGEudXJsKSA/IG5ldyBVUkwoaW1wb3J0Lm1ldGEudXJsKS5wYXRobmFtZS5zdWJzdHJpbmcoMCwgbmV3IFVSTChpbXBvcnQubWV0YS51cmwpLnBhdGhuYW1lLmxhc3RJbmRleE9mKCcvJykgKyAxKSA6ICdhdXRvJywgdHlwZTogJ2VzbScsIHZlcnNpb246ICcxNC4zLjEnIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/packageInfo.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/substrate-connect/Health.js":
/*!*****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/substrate-connect/Health.js ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthCheckError: () => (/* binding */ HealthCheckError),\n/* harmony export */   healthChecker: () => (/* binding */ healthChecker)\n/* harmony export */ });\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/stringify.js\");\n\n/*\n * Creates a new health checker.\n *\n * The role of the health checker is to report to the user the health of a smoldot chain.\n *\n * In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the\n * way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use\n * `start()` in order to start the health checks. The `start()` function must be passed a callback called\n * when an update to the health of the node is available.\n *\n * In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function\n * of the health checker. The health checker rewrites the `id` of the requests it receives.\n *\n * When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This\n * function intercepts the responses destined to the requests that have been emitted by the health\n * checker and returns `null`. If the response doesn't concern the health checker, the response is\n * simply returned by the function.\n *\n * # How it works\n *\n * The health checker periodically calls the `system_health` JSON-RPC call in order to determine\n * the health of the chain.\n *\n * In addition to this, as long as the health check reports that `isSyncing` is `true`, the\n * health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.\n * Whenever a new block is notified, a health check is performed immediately in order to determine\n * whether `isSyncing` has changed to `false`.\n *\n * Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to\n * `isSyncing: false` is very low.\n *\n */\nfunction healthChecker() {\n    // `null` if health checker is not started.\n    let checker = null;\n    let sendJsonRpc = null;\n    return {\n        responsePassThrough: (jsonRpcResponse) => {\n            if (checker === null) {\n                return jsonRpcResponse;\n            }\n            return checker.responsePassThrough(jsonRpcResponse);\n        },\n        sendJsonRpc: (request) => {\n            if (!sendJsonRpc) {\n                throw new Error('setSendJsonRpc must be called before sending requests');\n            }\n            if (checker === null) {\n                sendJsonRpc(request);\n            }\n            else {\n                checker.sendJsonRpc(request);\n            }\n        },\n        setSendJsonRpc: (cb) => {\n            sendJsonRpc = cb;\n        },\n        start: (healthCallback) => {\n            if (checker !== null) {\n                throw new Error(\"Can't start the health checker multiple times in parallel\");\n            }\n            else if (!sendJsonRpc) {\n                throw new Error('setSendJsonRpc must be called before starting the health checks');\n            }\n            checker = new InnerChecker(healthCallback, sendJsonRpc);\n            checker.update(true);\n        },\n        stop: () => {\n            if (checker === null) {\n                return;\n            } // Already stopped.\n            checker.destroy();\n            checker = null;\n        }\n    };\n}\nclass InnerChecker {\n    __internal__healthCallback;\n    __internal__currentHealthCheckId = null;\n    __internal__currentHealthTimeout = null;\n    __internal__currentSubunsubRequestId = null;\n    __internal__currentSubscriptionId = null;\n    __internal__requestToSmoldot;\n    __internal__isSyncing = false;\n    __internal__nextRequestId = 0;\n    constructor(healthCallback, requestToSmoldot) {\n        this.__internal__healthCallback = healthCallback;\n        this.__internal__requestToSmoldot = (request) => requestToSmoldot((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.stringify)(request));\n    }\n    sendJsonRpc = (request) => {\n        // Replace the `id` in the request to prefix the request ID with `extern:`.\n        let parsedRequest;\n        try {\n            parsedRequest = JSON.parse(request);\n        }\n        catch {\n            return;\n        }\n        if (parsedRequest.id) {\n            const newId = 'extern:' + (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.stringify)(parsedRequest.id);\n            parsedRequest.id = newId;\n        }\n        this.__internal__requestToSmoldot(parsedRequest);\n    };\n    responsePassThrough = (jsonRpcResponse) => {\n        let parsedResponse;\n        try {\n            parsedResponse = JSON.parse(jsonRpcResponse);\n        }\n        catch {\n            return jsonRpcResponse;\n        }\n        // Check whether response is a response to `system_health`.\n        if (parsedResponse.id && this.__internal__currentHealthCheckId === parsedResponse.id) {\n            this.__internal__currentHealthCheckId = null;\n            // Check whether query was successful. It is possible for queries to fail for\n            // various reasons, such as the client being overloaded.\n            if (!parsedResponse.result) {\n                this.update(false);\n                return null;\n            }\n            this.__internal__healthCallback(parsedResponse.result);\n            this.__internal__isSyncing = parsedResponse.result.isSyncing;\n            this.update(false);\n            return null;\n        }\n        // Check whether response is a response to the subscription or unsubscription.\n        if (parsedResponse.id &&\n            this.__internal__currentSubunsubRequestId === parsedResponse.id) {\n            this.__internal__currentSubunsubRequestId = null;\n            // Check whether query was successful. It is possible for queries to fail for\n            // various reasons, such as the client being overloaded.\n            if (!parsedResponse.result) {\n                this.update(false);\n                return null;\n            }\n            if (this.__internal__currentSubscriptionId) {\n                this.__internal__currentSubscriptionId = null;\n            }\n            else {\n                this.__internal__currentSubscriptionId = parsedResponse.result;\n            }\n            this.update(false);\n            return null;\n        }\n        // Check whether response is a notification to a subscription.\n        if (parsedResponse.params &&\n            this.__internal__currentSubscriptionId &&\n            parsedResponse.params.subscription === this.__internal__currentSubscriptionId) {\n            // Note that after a successful subscription, a notification containing\n            // the current best block is always returned. Considering that a\n            // subscription is performed in response to a health check, calling\n            // `startHealthCheck()` here will lead to a second health check.\n            // It might seem redundant to perform two health checks in a quick\n            // succession, but doing so doesn't lead to any problem, and it is\n            // actually possible for the health to have changed in between as the\n            // current best block might have been updated during the subscription\n            // request.\n            this.update(true);\n            return null;\n        }\n        // Response doesn't concern us.\n        if (parsedResponse.id) {\n            const id = parsedResponse.id;\n            // Need to remove the `extern:` prefix.\n            if (!id.startsWith('extern:')) {\n                throw new Error('State inconsistency in health checker');\n            }\n            const newId = JSON.parse(id.slice('extern:'.length));\n            parsedResponse.id = newId;\n        }\n        return (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.stringify)(parsedResponse);\n    };\n    update = (startNow) => {\n        // If `startNow`, clear `#currentHealthTimeout` so that it is set below.\n        if (startNow && this.__internal__currentHealthTimeout) {\n            clearTimeout(this.__internal__currentHealthTimeout);\n            this.__internal__currentHealthTimeout = null;\n        }\n        if (!this.__internal__currentHealthTimeout) {\n            const startHealthRequest = () => {\n                this.__internal__currentHealthTimeout = null;\n                // No matter what, don't start a health request if there is already one in progress.\n                // This is sane to do because receiving a response to a health request calls `update()`.\n                if (this.__internal__currentHealthCheckId) {\n                    return;\n                }\n                // Actual request starting.\n                this.__internal__currentHealthCheckId = `health-checker:${this.__internal__nextRequestId}`;\n                this.__internal__nextRequestId += 1;\n                this.__internal__requestToSmoldot({\n                    id: this.__internal__currentHealthCheckId,\n                    jsonrpc: '2.0',\n                    method: 'system_health',\n                    params: []\n                });\n            };\n            if (startNow) {\n                startHealthRequest();\n            }\n            else {\n                this.__internal__currentHealthTimeout = setTimeout(startHealthRequest, 1000);\n            }\n        }\n        if (this.__internal__isSyncing &&\n            !this.__internal__currentSubscriptionId &&\n            !this.__internal__currentSubunsubRequestId) {\n            this.startSubscription();\n        }\n        if (!this.__internal__isSyncing &&\n            this.__internal__currentSubscriptionId &&\n            !this.__internal__currentSubunsubRequestId) {\n            this.endSubscription();\n        }\n    };\n    startSubscription = () => {\n        if (this.__internal__currentSubunsubRequestId || this.__internal__currentSubscriptionId) {\n            throw new Error('Internal error in health checker');\n        }\n        this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;\n        this.__internal__nextRequestId += 1;\n        this.__internal__requestToSmoldot({\n            id: this.__internal__currentSubunsubRequestId,\n            jsonrpc: '2.0',\n            method: 'chain_subscribeNewHeads',\n            params: []\n        });\n    };\n    endSubscription = () => {\n        if (this.__internal__currentSubunsubRequestId || !this.__internal__currentSubscriptionId) {\n            throw new Error('Internal error in health checker');\n        }\n        this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;\n        this.__internal__nextRequestId += 1;\n        this.__internal__requestToSmoldot({\n            id: this.__internal__currentSubunsubRequestId,\n            jsonrpc: '2.0',\n            method: 'chain_unsubscribeNewHeads',\n            params: [this.__internal__currentSubscriptionId]\n        });\n    };\n    destroy = () => {\n        if (this.__internal__currentHealthTimeout) {\n            clearTimeout(this.__internal__currentHealthTimeout);\n            this.__internal__currentHealthTimeout = null;\n        }\n    };\n}\nclass HealthCheckError extends Error {\n    __internal__cause;\n    getCause() {\n        return this.__internal__cause;\n    }\n    constructor(response, message = 'Got error response asking for system health') {\n        super(message);\n        this.__internal__cause = response;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvc3Vic3RyYXRlLWNvbm5lY3QvSGVhbHRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHlEQUFTO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseURBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsK0JBQStCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLCtCQUErQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwrQkFBK0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWJ1YmFrcmppbW9oL0Rlc2t0b3AvQ29kaW5nIFN0dWZmcy9oYWNrYXRob24vc2VjcmV0LW5ldHdvcmsvbWVtZUFpX2NvaW5fY3JlYXRvci9haS1tZW1lLWNvaW4tY3JlYXRvci9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvc3Vic3RyYXRlLWNvbm5lY3QvSGVhbHRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJ0Bwb2xrYWRvdC91dGlsJztcbi8qXG4gKiBDcmVhdGVzIGEgbmV3IGhlYWx0aCBjaGVja2VyLlxuICpcbiAqIFRoZSByb2xlIG9mIHRoZSBoZWFsdGggY2hlY2tlciBpcyB0byByZXBvcnQgdG8gdGhlIHVzZXIgdGhlIGhlYWx0aCBvZiBhIHNtb2xkb3QgY2hhaW4uXG4gKlxuICogSW4gb3JkZXIgdG8gdXNlIGl0LCBzdGFydCBieSBjcmVhdGluZyBhIGhlYWx0aCBjaGVja2VyLCBhbmQgY2FsbCBgc2V0U2VuZEpzb25ScGNgIHRvIHNldCB0aGVcbiAqIHdheSB0byBzZW5kIGEgSlNPTi1SUEMgcmVxdWVzdCB0byBhIGNoYWluLiBUaGUgaGVhbHRoIGNoZWNrZXIgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdC4gVXNlXG4gKiBgc3RhcnQoKWAgaW4gb3JkZXIgdG8gc3RhcnQgdGhlIGhlYWx0aCBjaGVja3MuIFRoZSBgc3RhcnQoKWAgZnVuY3Rpb24gbXVzdCBiZSBwYXNzZWQgYSBjYWxsYmFjayBjYWxsZWRcbiAqIHdoZW4gYW4gdXBkYXRlIHRvIHRoZSBoZWFsdGggb2YgdGhlIG5vZGUgaXMgYXZhaWxhYmxlLlxuICpcbiAqIEluIG9yZGVyIHRvIHNlbmQgYSBKU09OLVJQQyByZXF1ZXN0IHRvIHRoZSBjaGFpbiwgeW91ICoqbXVzdCoqIHVzZSB0aGUgYHNlbmRKc29uUnBjYCBmdW5jdGlvblxuICogb2YgdGhlIGhlYWx0aCBjaGVja2VyLiBUaGUgaGVhbHRoIGNoZWNrZXIgcmV3cml0ZXMgdGhlIGBpZGAgb2YgdGhlIHJlcXVlc3RzIGl0IHJlY2VpdmVzLlxuICpcbiAqIFdoZW4gdGhlIGNoYWluIHNlbmQgYSBKU09OLVJQQyByZXNwb25zZSwgaXQgbXVzdCBiZSBwYXNzZWQgdG8gYHJlc3BvbnNlUGFzc1Rocm91Z2goKWAuIFRoaXNcbiAqIGZ1bmN0aW9uIGludGVyY2VwdHMgdGhlIHJlc3BvbnNlcyBkZXN0aW5lZCB0byB0aGUgcmVxdWVzdHMgdGhhdCBoYXZlIGJlZW4gZW1pdHRlZCBieSB0aGUgaGVhbHRoXG4gKiBjaGVja2VyIGFuZCByZXR1cm5zIGBudWxsYC4gSWYgdGhlIHJlc3BvbnNlIGRvZXNuJ3QgY29uY2VybiB0aGUgaGVhbHRoIGNoZWNrZXIsIHRoZSByZXNwb25zZSBpc1xuICogc2ltcGx5IHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbi5cbiAqXG4gKiAjIEhvdyBpdCB3b3Jrc1xuICpcbiAqIFRoZSBoZWFsdGggY2hlY2tlciBwZXJpb2RpY2FsbHkgY2FsbHMgdGhlIGBzeXN0ZW1faGVhbHRoYCBKU09OLVJQQyBjYWxsIGluIG9yZGVyIHRvIGRldGVybWluZVxuICogdGhlIGhlYWx0aCBvZiB0aGUgY2hhaW4uXG4gKlxuICogSW4gYWRkaXRpb24gdG8gdGhpcywgYXMgbG9uZyBhcyB0aGUgaGVhbHRoIGNoZWNrIHJlcG9ydHMgdGhhdCBgaXNTeW5jaW5nYCBpcyBgdHJ1ZWAsIHRoZVxuICogaGVhbHRoIGNoZWNrZXIgYWxzbyBtYWludGFpbnMgYSBzdWJzY3JpcHRpb24gdG8gbmV3IGJlc3QgYmxvY2tzIHVzaW5nIGBjaGFpbl9zdWJzY3JpYmVOZXdIZWFkc2AuXG4gKiBXaGVuZXZlciBhIG5ldyBibG9jayBpcyBub3RpZmllZCwgYSBoZWFsdGggY2hlY2sgaXMgcGVyZm9ybWVkIGltbWVkaWF0ZWx5IGluIG9yZGVyIHRvIGRldGVybWluZVxuICogd2hldGhlciBgaXNTeW5jaW5nYCBoYXMgY2hhbmdlZCB0byBgZmFsc2VgLlxuICpcbiAqIFRoYW5rcyB0byB0aGlzIHN1YnNjcmlwdGlvbiwgdGhlIGxhdGVuY3kgb2YgdGhlIHJlcG9ydCBvZiB0aGUgc3dpdGNoIGZyb20gYGlzU3luY2luZzogdHJ1ZWAgdG9cbiAqIGBpc1N5bmNpbmc6IGZhbHNlYCBpcyB2ZXJ5IGxvdy5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWFsdGhDaGVja2VyKCkge1xuICAgIC8vIGBudWxsYCBpZiBoZWFsdGggY2hlY2tlciBpcyBub3Qgc3RhcnRlZC5cbiAgICBsZXQgY2hlY2tlciA9IG51bGw7XG4gICAgbGV0IHNlbmRKc29uUnBjID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXNwb25zZVBhc3NUaHJvdWdoOiAoanNvblJwY1Jlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uUnBjUmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tlci5yZXNwb25zZVBhc3NUaHJvdWdoKGpzb25ScGNSZXNwb25zZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbmRKc29uUnBjOiAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZW5kSnNvblJwYykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0U2VuZEpzb25ScGMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNlbmRpbmcgcmVxdWVzdHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGVja2VyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VuZEpzb25ScGMocmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVja2VyLnNlbmRKc29uUnBjKHJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRTZW5kSnNvblJwYzogKGNiKSA9PiB7XG4gICAgICAgICAgICBzZW5kSnNvblJwYyA9IGNiO1xuICAgICAgICB9LFxuICAgICAgICBzdGFydDogKGhlYWx0aENhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHRoZSBoZWFsdGggY2hlY2tlciBtdWx0aXBsZSB0aW1lcyBpbiBwYXJhbGxlbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFzZW5kSnNvblJwYykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0U2VuZEpzb25ScGMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHN0YXJ0aW5nIHRoZSBoZWFsdGggY2hlY2tzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja2VyID0gbmV3IElubmVyQ2hlY2tlcihoZWFsdGhDYWxsYmFjaywgc2VuZEpzb25ScGMpO1xuICAgICAgICAgICAgY2hlY2tlci51cGRhdGUodHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSAvLyBBbHJlYWR5IHN0b3BwZWQuXG4gICAgICAgICAgICBjaGVja2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGNoZWNrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNsYXNzIElubmVyQ2hlY2tlciB7XG4gICAgX19pbnRlcm5hbF9faGVhbHRoQ2FsbGJhY2s7XG4gICAgX19pbnRlcm5hbF9fY3VycmVudEhlYWx0aENoZWNrSWQgPSBudWxsO1xuICAgIF9faW50ZXJuYWxfX2N1cnJlbnRIZWFsdGhUaW1lb3V0ID0gbnVsbDtcbiAgICBfX2ludGVybmFsX19jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQgPSBudWxsO1xuICAgIF9faW50ZXJuYWxfX2N1cnJlbnRTdWJzY3JpcHRpb25JZCA9IG51bGw7XG4gICAgX19pbnRlcm5hbF9fcmVxdWVzdFRvU21vbGRvdDtcbiAgICBfX2ludGVybmFsX19pc1N5bmNpbmcgPSBmYWxzZTtcbiAgICBfX2ludGVybmFsX19uZXh0UmVxdWVzdElkID0gMDtcbiAgICBjb25zdHJ1Y3RvcihoZWFsdGhDYWxsYmFjaywgcmVxdWVzdFRvU21vbGRvdCkge1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2hlYWx0aENhbGxiYWNrID0gaGVhbHRoQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fcmVxdWVzdFRvU21vbGRvdCA9IChyZXF1ZXN0KSA9PiByZXF1ZXN0VG9TbW9sZG90KHN0cmluZ2lmeShyZXF1ZXN0KSk7XG4gICAgfVxuICAgIHNlbmRKc29uUnBjID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgYGlkYCBpbiB0aGUgcmVxdWVzdCB0byBwcmVmaXggdGhlIHJlcXVlc3QgSUQgd2l0aCBgZXh0ZXJuOmAuXG4gICAgICAgIGxldCBwYXJzZWRSZXF1ZXN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkUmVxdWVzdCA9IEpTT04ucGFyc2UocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRSZXF1ZXN0LmlkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdJZCA9ICdleHRlcm46JyArIHN0cmluZ2lmeShwYXJzZWRSZXF1ZXN0LmlkKTtcbiAgICAgICAgICAgIHBhcnNlZFJlcXVlc3QuaWQgPSBuZXdJZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3JlcXVlc3RUb1Ntb2xkb3QocGFyc2VkUmVxdWVzdCk7XG4gICAgfTtcbiAgICByZXNwb25zZVBhc3NUaHJvdWdoID0gKGpzb25ScGNSZXNwb25zZSkgPT4ge1xuICAgICAgICBsZXQgcGFyc2VkUmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IEpTT04ucGFyc2UoanNvblJwY1Jlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4ganNvblJwY1Jlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgcmVzcG9uc2UgaXMgYSByZXNwb25zZSB0byBgc3lzdGVtX2hlYWx0aGAuXG4gICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5pZCAmJiB0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRIZWFsdGhDaGVja0lkID09PSBwYXJzZWRSZXNwb25zZS5pZCkge1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19jdXJyZW50SGVhbHRoQ2hlY2tJZCA9IG51bGw7XG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHF1ZXJ5IHdhcyBzdWNjZXNzZnVsLiBJdCBpcyBwb3NzaWJsZSBmb3IgcXVlcmllcyB0byBmYWlsIGZvclxuICAgICAgICAgICAgLy8gdmFyaW91cyByZWFzb25zLCBzdWNoIGFzIHRoZSBjbGllbnQgYmVpbmcgb3ZlcmxvYWRlZC5cbiAgICAgICAgICAgIGlmICghcGFyc2VkUmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19oZWFsdGhDYWxsYmFjayhwYXJzZWRSZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19pc1N5bmNpbmcgPSBwYXJzZWRSZXNwb25zZS5yZXN1bHQuaXNTeW5jaW5nO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciByZXNwb25zZSBpcyBhIHJlc3BvbnNlIHRvIHRoZSBzdWJzY3JpcHRpb24gb3IgdW5zdWJzY3JpcHRpb24uXG4gICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5pZCAmJlxuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQgPT09IHBhcnNlZFJlc3BvbnNlLmlkKSB7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHF1ZXJ5IHdhcyBzdWNjZXNzZnVsLiBJdCBpcyBwb3NzaWJsZSBmb3IgcXVlcmllcyB0byBmYWlsIGZvclxuICAgICAgICAgICAgLy8gdmFyaW91cyByZWFzb25zLCBzdWNoIGFzIHRoZSBjbGllbnQgYmVpbmcgb3ZlcmxvYWRlZC5cbiAgICAgICAgICAgIGlmICghcGFyc2VkUmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX19pbnRlcm5hbF9fY3VycmVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19jdXJyZW50U3Vic2NyaXB0aW9uSWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19jdXJyZW50U3Vic2NyaXB0aW9uSWQgPSBwYXJzZWRSZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHJlc3BvbnNlIGlzIGEgbm90aWZpY2F0aW9uIHRvIGEgc3Vic2NyaXB0aW9uLlxuICAgICAgICBpZiAocGFyc2VkUmVzcG9uc2UucGFyYW1zICYmXG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRTdWJzY3JpcHRpb25JZCAmJlxuICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UucGFyYW1zLnN1YnNjcmlwdGlvbiA9PT0gdGhpcy5fX2ludGVybmFsX19jdXJyZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBhZnRlciBhIHN1Y2Nlc3NmdWwgc3Vic2NyaXB0aW9uLCBhIG5vdGlmaWNhdGlvbiBjb250YWluaW5nXG4gICAgICAgICAgICAvLyB0aGUgY3VycmVudCBiZXN0IGJsb2NrIGlzIGFsd2F5cyByZXR1cm5lZC4gQ29uc2lkZXJpbmcgdGhhdCBhXG4gICAgICAgICAgICAvLyBzdWJzY3JpcHRpb24gaXMgcGVyZm9ybWVkIGluIHJlc3BvbnNlIHRvIGEgaGVhbHRoIGNoZWNrLCBjYWxsaW5nXG4gICAgICAgICAgICAvLyBgc3RhcnRIZWFsdGhDaGVjaygpYCBoZXJlIHdpbGwgbGVhZCB0byBhIHNlY29uZCBoZWFsdGggY2hlY2suXG4gICAgICAgICAgICAvLyBJdCBtaWdodCBzZWVtIHJlZHVuZGFudCB0byBwZXJmb3JtIHR3byBoZWFsdGggY2hlY2tzIGluIGEgcXVpY2tcbiAgICAgICAgICAgIC8vIHN1Y2Nlc3Npb24sIGJ1dCBkb2luZyBzbyBkb2Vzbid0IGxlYWQgdG8gYW55IHByb2JsZW0sIGFuZCBpdCBpc1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgcG9zc2libGUgZm9yIHRoZSBoZWFsdGggdG8gaGF2ZSBjaGFuZ2VkIGluIGJldHdlZW4gYXMgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGJlc3QgYmxvY2sgbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgZHVyaW5nIHRoZSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHJlcXVlc3QuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3BvbnNlIGRvZXNuJ3QgY29uY2VybiB1cy5cbiAgICAgICAgaWYgKHBhcnNlZFJlc3BvbnNlLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHBhcnNlZFJlc3BvbnNlLmlkO1xuICAgICAgICAgICAgLy8gTmVlZCB0byByZW1vdmUgdGhlIGBleHRlcm46YCBwcmVmaXguXG4gICAgICAgICAgICBpZiAoIWlkLnN0YXJ0c1dpdGgoJ2V4dGVybjonKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGUgaW5jb25zaXN0ZW5jeSBpbiBoZWFsdGggY2hlY2tlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3SWQgPSBKU09OLnBhcnNlKGlkLnNsaWNlKCdleHRlcm46Jy5sZW5ndGgpKTtcbiAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlLmlkID0gbmV3SWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJzZWRSZXNwb25zZSk7XG4gICAgfTtcbiAgICB1cGRhdGUgPSAoc3RhcnROb3cpID0+IHtcbiAgICAgICAgLy8gSWYgYHN0YXJ0Tm93YCwgY2xlYXIgYCNjdXJyZW50SGVhbHRoVGltZW91dGAgc28gdGhhdCBpdCBpcyBzZXQgYmVsb3cuXG4gICAgICAgIGlmIChzdGFydE5vdyAmJiB0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRIZWFsdGhUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fX2ludGVybmFsX19jdXJyZW50SGVhbHRoVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRIZWFsdGhUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX19pbnRlcm5hbF9fY3VycmVudEhlYWx0aFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SGVhbHRoUmVxdWVzdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRIZWFsdGhUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBObyBtYXR0ZXIgd2hhdCwgZG9uJ3Qgc3RhcnQgYSBoZWFsdGggcmVxdWVzdCBpZiB0aGVyZSBpcyBhbHJlYWR5IG9uZSBpbiBwcm9ncmVzcy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHNhbmUgdG8gZG8gYmVjYXVzZSByZWNlaXZpbmcgYSByZXNwb25zZSB0byBhIGhlYWx0aCByZXF1ZXN0IGNhbGxzIGB1cGRhdGUoKWAuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pbnRlcm5hbF9fY3VycmVudEhlYWx0aENoZWNrSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBY3R1YWwgcmVxdWVzdCBzdGFydGluZy5cbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRIZWFsdGhDaGVja0lkID0gYGhlYWx0aC1jaGVja2VyOiR7dGhpcy5fX2ludGVybmFsX19uZXh0UmVxdWVzdElkfWA7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19uZXh0UmVxdWVzdElkICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19yZXF1ZXN0VG9TbW9sZG90KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuX19pbnRlcm5hbF9fY3VycmVudEhlYWx0aENoZWNrSWQsXG4gICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdzeXN0ZW1faGVhbHRoJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzdGFydE5vdykge1xuICAgICAgICAgICAgICAgIHN0YXJ0SGVhbHRoUmVxdWVzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19jdXJyZW50SGVhbHRoVGltZW91dCA9IHNldFRpbWVvdXQoc3RhcnRIZWFsdGhSZXF1ZXN0LCAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX2ludGVybmFsX19pc1N5bmNpbmcgJiZcbiAgICAgICAgICAgICF0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRTdWJzY3JpcHRpb25JZCAmJlxuICAgICAgICAgICAgIXRoaXMuX19pbnRlcm5hbF9fY3VycmVudFN1YnVuc3ViUmVxdWVzdElkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9faW50ZXJuYWxfX2lzU3luY2luZyAmJlxuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19jdXJyZW50U3Vic2NyaXB0aW9uSWQgJiZcbiAgICAgICAgICAgICF0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCkge1xuICAgICAgICAgICAgdGhpcy5lbmRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc3RhcnRTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCB8fCB0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRTdWJzY3JpcHRpb25JZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvciBpbiBoZWFsdGggY2hlY2tlcicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fY3VycmVudFN1YnVuc3ViUmVxdWVzdElkID0gYGhlYWx0aC1jaGVja2VyOiR7dGhpcy5fX2ludGVybmFsX19uZXh0UmVxdWVzdElkfWA7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fbmV4dFJlcXVlc3RJZCArPSAxO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3JlcXVlc3RUb1Ntb2xkb3Qoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuX19pbnRlcm5hbF9fY3VycmVudFN1YnVuc3ViUmVxdWVzdElkLFxuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBtZXRob2Q6ICdjaGFpbl9zdWJzY3JpYmVOZXdIZWFkcycsXG4gICAgICAgICAgICBwYXJhbXM6IFtdXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZW5kU3Vic2NyaXB0aW9uID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fX2ludGVybmFsX19jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQgfHwgIXRoaXMuX19pbnRlcm5hbF9fY3VycmVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yIGluIGhlYWx0aCBjaGVja2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQgPSBgaGVhbHRoLWNoZWNrZXI6JHt0aGlzLl9faW50ZXJuYWxfX25leHRSZXF1ZXN0SWR9YDtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19uZXh0UmVxdWVzdElkICs9IDE7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fcmVxdWVzdFRvU21vbGRvdCh7XG4gICAgICAgICAgICBpZDogdGhpcy5fX2ludGVybmFsX19jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQsXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ2NoYWluX3Vuc3Vic2NyaWJlTmV3SGVhZHMnLFxuICAgICAgICAgICAgcGFyYW1zOiBbdGhpcy5fX2ludGVybmFsX19jdXJyZW50U3Vic2NyaXB0aW9uSWRdXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX19pbnRlcm5hbF9fY3VycmVudEhlYWx0aFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9faW50ZXJuYWxfX2N1cnJlbnRIZWFsdGhUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fY3VycmVudEhlYWx0aFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBjbGFzcyBIZWFsdGhDaGVja0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIF9faW50ZXJuYWxfX2NhdXNlO1xuICAgIGdldENhdXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsX19jYXVzZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UsIG1lc3NhZ2UgPSAnR290IGVycm9yIHJlc3BvbnNlIGFza2luZyBmb3Igc3lzdGVtIGhlYWx0aCcpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fY2F1c2UgPSByZXNwb25zZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/substrate-connect/Health.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/substrate-connect/index.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/substrate-connect/index.js ***!
  \****************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScProvider: () => (/* binding */ ScProvider)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"(rsc)/./node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/logger.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/is/object.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/is/function.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/noop.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/object/spread.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/is/error.js\");\n/* harmony import */ var _coder_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coder/index.js */ \"(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/coder/index.js\");\n/* harmony import */ var _Health_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Health.js */ \"(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/substrate-connect/Health.js\");\n\n\n\n\nconst l = (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_1__.logger)('api-substrate-connect');\nconst subscriptionUnsubscriptionMethods = new Map([\n    ['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'],\n    ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'],\n    ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'],\n    ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'],\n    ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'],\n    ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'],\n    ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'],\n    ['subscribe_newHead', 'unsubscribe_newHead'],\n    ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'],\n    ['state_subscribeStorage', 'state_unsubscribeStorage']\n]);\nconst scClients = new WeakMap();\nclass ScProvider {\n    __internal__Sc;\n    __internal__coder = new _coder_index_js__WEBPACK_IMPORTED_MODULE_2__.RpcCoder();\n    __internal__spec;\n    __internal__sharedSandbox;\n    __internal__subscriptions = new Map();\n    __internal__resubscribeMethods = new Map();\n    __internal__requests = new Map();\n    __internal__wellKnownChains;\n    __internal__eventemitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n    __internal__chain = null;\n    __internal__isChainReady = false;\n    constructor(Sc, spec, sharedSandbox) {\n        if (!(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_3__.isObject)(Sc) || !(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_3__.isObject)(Sc.WellKnownChain) || !(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_4__.isFunction)(Sc.createScClient)) {\n            throw new Error('Expected an @substrate/connect interface as first parameter to ScProvider');\n        }\n        this.__internal__Sc = Sc;\n        this.__internal__spec = spec;\n        this.__internal__sharedSandbox = sharedSandbox;\n        this.__internal__wellKnownChains = new Set(Object.values(Sc.WellKnownChain));\n    }\n    get hasSubscriptions() {\n        // Indicates that subscriptions are supported\n        return !!true;\n    }\n    get isClonable() {\n        return !!false;\n    }\n    get isConnected() {\n        return !!this.__internal__chain && this.__internal__isChainReady;\n    }\n    clone() {\n        throw new Error('clone() is not supported.');\n    }\n    // Config details can be found in @substrate/connect repo following the link:\n    // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts\n    async connect(config, checkerFactory = _Health_js__WEBPACK_IMPORTED_MODULE_5__.healthChecker) {\n        if (this.isConnected) {\n            throw new Error('Already connected!');\n        }\n        // it could happen that after emitting `disconnected` due to the fact that\n        // smoldot is syncing, the consumer tries to reconnect after a certain amount\n        // of time... In which case we want to make sure that we don't create a new\n        // chain.\n        if (this.__internal__chain) {\n            await this.__internal__chain;\n            return;\n        }\n        if (this.__internal__sharedSandbox && !this.__internal__sharedSandbox.isConnected) {\n            await this.__internal__sharedSandbox.connect();\n        }\n        const client = this.__internal__sharedSandbox\n            ? scClients.get(this.__internal__sharedSandbox)\n            : this.__internal__Sc.createScClient(config);\n        if (!client) {\n            throw new Error('Unknown ScProvider!');\n        }\n        scClients.set(this, client);\n        const hc = checkerFactory();\n        const onResponse = (res) => {\n            const hcRes = hc.responsePassThrough(res);\n            if (!hcRes) {\n                return;\n            }\n            const response = JSON.parse(hcRes);\n            let decodedResponse;\n            try {\n                decodedResponse = this.__internal__coder.decodeResponse(response);\n            }\n            catch (e) {\n                decodedResponse = e;\n            }\n            // It's not a subscription message, but rather a standar RPC response\n            if (response.params?.subscription === undefined || !response.method) {\n                return this.__internal__requests.get(response.id)?.(decodedResponse);\n            }\n            // We are dealing with a subscription message\n            const subscriptionId = `${response.method}::${response.params.subscription}`;\n            const callback = this.__internal__subscriptions.get(subscriptionId)?.[0];\n            callback?.(decodedResponse);\n        };\n        const addChain = this.__internal__sharedSandbox\n            ? (async (...args) => {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const source = this.__internal__sharedSandbox;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                return (await source.__internal__chain).addChain(...args);\n            })\n            : this.__internal__wellKnownChains.has(this.__internal__spec)\n                ? client.addWellKnownChain\n                : client.addChain;\n        this.__internal__chain = addChain(this.__internal__spec, onResponse).then((chain) => {\n            hc.setSendJsonRpc(chain.sendJsonRpc);\n            this.__internal__isChainReady = false;\n            const cleanup = () => {\n                // If there are any callbacks left, we have to reject/error them.\n                // Otherwise, that would cause a memory leak.\n                const disconnectionError = new Error('Disconnected');\n                this.__internal__requests.forEach((cb) => cb(disconnectionError));\n                this.__internal__subscriptions.forEach(([cb]) => cb(disconnectionError));\n                this.__internal__subscriptions.clear();\n            };\n            const staleSubscriptions = [];\n            const killStaleSubscriptions = () => {\n                if (staleSubscriptions.length === 0) {\n                    return;\n                }\n                const stale = staleSubscriptions.pop();\n                if (!stale) {\n                    throw new Error('Unable to get stale subscription');\n                }\n                const { id, unsubscribeMethod } = stale;\n                Promise\n                    .race([\n                    this.send(unsubscribeMethod, [id]).catch(_polkadot_util__WEBPACK_IMPORTED_MODULE_6__.noop),\n                    new Promise((resolve) => setTimeout(resolve, 500))\n                ])\n                    .then(killStaleSubscriptions)\n                    .catch(_polkadot_util__WEBPACK_IMPORTED_MODULE_6__.noop);\n            };\n            hc.start((health) => {\n                const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);\n                // if it's the same as before, then nothing has changed and we are done\n                if (this.__internal__isChainReady === isReady) {\n                    return;\n                }\n                this.__internal__isChainReady = isReady;\n                if (!isReady) {\n                    // If we've reached this point, that means that the chain used to be \"ready\"\n                    // and now we are about to emit `disconnected`.\n                    //\n                    // This will cause the PolkadotJs API think that the connection is\n                    // actually dead. In reality the smoldot chain is not dead, of course.\n                    // However, we have to cleanup all the existing callbacks because when\n                    // the smoldot chain stops syncing, then we will emit `connected` and\n                    // the PolkadotJs API will try to re-create the previous\n                    // subscriptions and requests. Although, now is not a good moment\n                    // to be sending unsubscription messages to the smoldot chain, we\n                    // should wait until is no longer syncing to send the unsubscription\n                    // messages from the stale subscriptions of the previous connection.\n                    //\n                    // That's why -before we perform the cleanup of `this.__internal__subscriptions`-\n                    // we keep the necessary information that we will need later on to\n                    // kill the stale subscriptions.\n                    [...this.__internal__subscriptions.values()].forEach((s) => {\n                        staleSubscriptions.push(s[1]);\n                    });\n                    cleanup();\n                    this.__internal__eventemitter.emit('disconnected');\n                }\n                else {\n                    killStaleSubscriptions();\n                    this.__internal__eventemitter.emit('connected');\n                    if (this.__internal__resubscribeMethods.size) {\n                        this.__internal__resubscribe();\n                    }\n                }\n            });\n            return (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_7__.objectSpread)({}, chain, {\n                remove: () => {\n                    hc.stop();\n                    chain.remove();\n                    cleanup();\n                },\n                sendJsonRpc: hc.sendJsonRpc.bind(hc)\n            });\n        });\n        try {\n            await this.__internal__chain;\n        }\n        catch (e) {\n            this.__internal__chain = null;\n            this.__internal__eventemitter.emit('error', e);\n            throw e;\n        }\n    }\n    __internal__resubscribe = () => {\n        const promises = [];\n        this.__internal__resubscribeMethods.forEach((subDetails) => {\n            // only re-create subscriptions which are not in author (only area where\n            // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n            // are not included (and will not be re-broadcast)\n            if (subDetails.type.startsWith('author_')) {\n                return;\n            }\n            try {\n                const promise = new Promise((resolve) => {\n                    this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch((error) => console.log(error));\n                    resolve();\n                });\n                promises.push(promise);\n            }\n            catch (error) {\n                l.error(error);\n            }\n        });\n        Promise.all(promises).catch((err) => l.log(err));\n    };\n    async disconnect() {\n        if (!this.__internal__chain) {\n            return;\n        }\n        const chain = await this.__internal__chain;\n        this.__internal__chain = null;\n        this.__internal__isChainReady = false;\n        try {\n            chain.remove();\n        }\n        catch (_) { }\n        this.__internal__eventemitter.emit('disconnected');\n    }\n    on(type, sub) {\n        // It's possible. Although, quite unlikely, that by the time that polkadot\n        // subscribes to the `connected` event, the Provider is already connected.\n        // In that case, we must emit to let the consumer know that we are connected.\n        if (type === 'connected' && this.isConnected) {\n            sub();\n        }\n        this.__internal__eventemitter.on(type, sub);\n        return () => {\n            this.__internal__eventemitter.removeListener(type, sub);\n        };\n    }\n    async send(method, params) {\n        if (!this.isConnected || !this.__internal__chain) {\n            throw new Error('Provider is not connected');\n        }\n        const chain = await this.__internal__chain;\n        const [id, json] = this.__internal__coder.encodeJson(method, params);\n        const result = new Promise((resolve, reject) => {\n            this.__internal__requests.set(id, (response) => {\n                ((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_8__.isError)(response) ? reject : resolve)(response);\n            });\n            try {\n                chain.sendJsonRpc(json);\n            }\n            catch (e) {\n                this.__internal__chain = null;\n                try {\n                    chain.remove();\n                }\n                catch (_) { }\n                this.__internal__eventemitter.emit('error', e);\n            }\n        });\n        try {\n            return await result;\n        }\n        finally {\n            // let's ensure that once the Promise is resolved/rejected, then we remove\n            // remove its entry from the internal #requests\n            this.__internal__requests.delete(id);\n        }\n    }\n    async subscribe(type, method, params, callback) {\n        if (!subscriptionUnsubscriptionMethods.has(method)) {\n            throw new Error(`Unsupported subscribe method: ${method}`);\n        }\n        const id = await this.send(method, params);\n        const subscriptionId = `${type}::${id}`;\n        const cb = (response) => {\n            if (response instanceof Error) {\n                callback(response, undefined);\n            }\n            else {\n                callback(null, response);\n            }\n        };\n        const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);\n        if (!unsubscribeMethod) {\n            throw new Error('Invalid unsubscribe method found');\n        }\n        this.__internal__resubscribeMethods.set(subscriptionId, { callback, method, params, type });\n        this.__internal__subscriptions.set(subscriptionId, [cb, { id, unsubscribeMethod }]);\n        return id;\n    }\n    unsubscribe(type, method, id) {\n        if (!this.isConnected) {\n            throw new Error('Provider is not connected');\n        }\n        const subscriptionId = `${type}::${id}`;\n        if (!this.__internal__subscriptions.has(subscriptionId)) {\n            return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));\n        }\n        this.__internal__resubscribeMethods.delete(subscriptionId);\n        this.__internal__subscriptions.delete(subscriptionId);\n        return this.send(method, [id]);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvc3Vic3RyYXRlLWNvbm5lY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE2QztBQUM4QztBQUM5QztBQUNEO0FBQzVDLFVBQVUsc0RBQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNEJBQTRCLHFEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxhQUFhLHdEQUFRLFNBQVMsd0RBQVEsd0JBQXdCLDBEQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHFEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixJQUFJLDZCQUE2QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBLDZEQUE2RCxnREFBSTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1CQUFtQiw0REFBWSxHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdURBQU87QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxPQUFPO0FBQ3BFO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSyxJQUFJLEdBQUc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdDQUFnQztBQUNsRyxrRUFBa0UsdUJBQXVCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxLQUFLLElBQUksR0FBRztBQUM5QztBQUNBLGtGQUFrRixlQUFlO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWJ1YmFrcmppbW9oL0Rlc2t0b3AvQ29kaW5nIFN0dWZmcy9oYWNrYXRob24vc2VjcmV0LW5ldHdvcmsvbWVtZUFpX2NvaW5fY3JlYXRvci9haS1tZW1lLWNvaW4tY3JlYXRvci9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvc3Vic3RyYXRlLWNvbm5lY3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBpc0Vycm9yLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgbG9nZ2VyLCBub29wLCBvYmplY3RTcHJlYWQgfSBmcm9tICdAcG9sa2Fkb3QvdXRpbCc7XG5pbXBvcnQgeyBScGNDb2RlciB9IGZyb20gJy4uL2NvZGVyL2luZGV4LmpzJztcbmltcG9ydCB7IGhlYWx0aENoZWNrZXIgfSBmcm9tICcuL0hlYWx0aC5qcyc7XG5jb25zdCBsID0gbG9nZ2VyKCdhcGktc3Vic3RyYXRlLWNvbm5lY3QnKTtcbmNvbnN0IHN1YnNjcmlwdGlvblVuc3Vic2NyaXB0aW9uTWV0aG9kcyA9IG5ldyBNYXAoW1xuICAgIFsnYXV0aG9yX3N1Ym1pdEFuZFdhdGNoRXh0cmluc2ljJywgJ2F1dGhvcl91bndhdGNoRXh0cmluc2ljJ10sXG4gICAgWydjaGFpbl9zdWJzY3JpYmVBbGxIZWFkcycsICdjaGFpbl91bnN1YnNjcmliZUFsbEhlYWRzJ10sXG4gICAgWydjaGFpbl9zdWJzY3JpYmVGaW5hbGl6ZWRIZWFkcycsICdjaGFpbl91bnN1YnNjcmliZUZpbmFsaXplZEhlYWRzJ10sXG4gICAgWydjaGFpbl9zdWJzY3JpYmVGaW5hbGlzZWRIZWFkcycsICdjaGFpbl9zdWJzY3JpYmVGaW5hbGlzZWRIZWFkcyddLFxuICAgIFsnY2hhaW5fc3Vic2NyaWJlTmV3SGVhZHMnLCAnY2hhaW5fdW5zdWJzY3JpYmVOZXdIZWFkcyddLFxuICAgIFsnY2hhaW5fc3Vic2NyaWJlTmV3SGVhZCcsICdjaGFpbl91bnN1YnNjcmliZU5ld0hlYWQnXSxcbiAgICBbJ2NoYWluX3N1YnNjcmliZVJ1bnRpbWVWZXJzaW9uJywgJ2NoYWluX3Vuc3Vic2NyaWJlUnVudGltZVZlcnNpb24nXSxcbiAgICBbJ3N1YnNjcmliZV9uZXdIZWFkJywgJ3Vuc3Vic2NyaWJlX25ld0hlYWQnXSxcbiAgICBbJ3N0YXRlX3N1YnNjcmliZVJ1bnRpbWVWZXJzaW9uJywgJ3N0YXRlX3Vuc3Vic2NyaWJlUnVudGltZVZlcnNpb24nXSxcbiAgICBbJ3N0YXRlX3N1YnNjcmliZVN0b3JhZ2UnLCAnc3RhdGVfdW5zdWJzY3JpYmVTdG9yYWdlJ11cbl0pO1xuY29uc3Qgc2NDbGllbnRzID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBTY1Byb3ZpZGVyIHtcbiAgICBfX2ludGVybmFsX19TYztcbiAgICBfX2ludGVybmFsX19jb2RlciA9IG5ldyBScGNDb2RlcigpO1xuICAgIF9faW50ZXJuYWxfX3NwZWM7XG4gICAgX19pbnRlcm5hbF9fc2hhcmVkU2FuZGJveDtcbiAgICBfX2ludGVybmFsX19zdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xuICAgIF9faW50ZXJuYWxfX3Jlc3Vic2NyaWJlTWV0aG9kcyA9IG5ldyBNYXAoKTtcbiAgICBfX2ludGVybmFsX19yZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICBfX2ludGVybmFsX193ZWxsS25vd25DaGFpbnM7XG4gICAgX19pbnRlcm5hbF9fZXZlbnRlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIF9faW50ZXJuYWxfX2NoYWluID0gbnVsbDtcbiAgICBfX2ludGVybmFsX19pc0NoYWluUmVhZHkgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3RvcihTYywgc3BlYywgc2hhcmVkU2FuZGJveCkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KFNjKSB8fCAhaXNPYmplY3QoU2MuV2VsbEtub3duQ2hhaW4pIHx8ICFpc0Z1bmN0aW9uKFNjLmNyZWF0ZVNjQ2xpZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBAc3Vic3RyYXRlL2Nvbm5lY3QgaW50ZXJmYWNlIGFzIGZpcnN0IHBhcmFtZXRlciB0byBTY1Byb3ZpZGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19TYyA9IFNjO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3NwZWMgPSBzcGVjO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3NoYXJlZFNhbmRib3ggPSBzaGFyZWRTYW5kYm94O1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3dlbGxLbm93bkNoYWlucyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhTYy5XZWxsS25vd25DaGFpbikpO1xuICAgIH1cbiAgICBnZXQgaGFzU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHRoYXQgc3Vic2NyaXB0aW9ucyBhcmUgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybiAhIXRydWU7XG4gICAgfVxuICAgIGdldCBpc0Nsb25hYmxlKCkge1xuICAgICAgICByZXR1cm4gISFmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9faW50ZXJuYWxfX2NoYWluICYmIHRoaXMuX19pbnRlcm5hbF9faXNDaGFpblJlYWR5O1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbG9uZSgpIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIC8vIENvbmZpZyBkZXRhaWxzIGNhbiBiZSBmb3VuZCBpbiBAc3Vic3RyYXRlL2Nvbm5lY3QgcmVwbyBmb2xsb3dpbmcgdGhlIGxpbms6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bhcml0eXRlY2gvc3Vic3RyYXRlLWNvbm5lY3QvYmxvYi9tYWluL3BhY2thZ2VzL2Nvbm5lY3Qvc3JjL2Nvbm5lY3Rvci9pbmRleC50c1xuICAgIGFzeW5jIGNvbm5lY3QoY29uZmlnLCBjaGVja2VyRmFjdG9yeSA9IGhlYWx0aENoZWNrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxyZWFkeSBjb25uZWN0ZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQgY291bGQgaGFwcGVuIHRoYXQgYWZ0ZXIgZW1pdHRpbmcgYGRpc2Nvbm5lY3RlZGAgZHVlIHRvIHRoZSBmYWN0IHRoYXRcbiAgICAgICAgLy8gc21vbGRvdCBpcyBzeW5jaW5nLCB0aGUgY29uc3VtZXIgdHJpZXMgdG8gcmVjb25uZWN0IGFmdGVyIGEgY2VydGFpbiBhbW91bnRcbiAgICAgICAgLy8gb2YgdGltZS4uLiBJbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgY3JlYXRlIGEgbmV3XG4gICAgICAgIC8vIGNoYWluLlxuICAgICAgICBpZiAodGhpcy5fX2ludGVybmFsX19jaGFpbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fX2ludGVybmFsX19jaGFpbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX2ludGVybmFsX19zaGFyZWRTYW5kYm94ICYmICF0aGlzLl9faW50ZXJuYWxfX3NoYXJlZFNhbmRib3guaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX19pbnRlcm5hbF9fc2hhcmVkU2FuZGJveC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5fX2ludGVybmFsX19zaGFyZWRTYW5kYm94XG4gICAgICAgICAgICA/IHNjQ2xpZW50cy5nZXQodGhpcy5fX2ludGVybmFsX19zaGFyZWRTYW5kYm94KVxuICAgICAgICAgICAgOiB0aGlzLl9faW50ZXJuYWxfX1NjLmNyZWF0ZVNjQ2xpZW50KGNvbmZpZyk7XG4gICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gU2NQcm92aWRlciEnKTtcbiAgICAgICAgfVxuICAgICAgICBzY0NsaWVudHMuc2V0KHRoaXMsIGNsaWVudCk7XG4gICAgICAgIGNvbnN0IGhjID0gY2hlY2tlckZhY3RvcnkoKTtcbiAgICAgICAgY29uc3Qgb25SZXNwb25zZSA9IChyZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhjUmVzID0gaGMucmVzcG9uc2VQYXNzVGhyb3VnaChyZXMpO1xuICAgICAgICAgICAgaWYgKCFoY1Jlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gSlNPTi5wYXJzZShoY1Jlcyk7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZFJlc3BvbnNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWNvZGVkUmVzcG9uc2UgPSB0aGlzLl9faW50ZXJuYWxfX2NvZGVyLmRlY29kZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlZFJlc3BvbnNlID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEl0J3Mgbm90IGEgc3Vic2NyaXB0aW9uIG1lc3NhZ2UsIGJ1dCByYXRoZXIgYSBzdGFuZGFyIFJQQyByZXNwb25zZVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnBhcmFtcz8uc3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQgfHwgIXJlc3BvbnNlLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWxfX3JlcXVlc3RzLmdldChyZXNwb25zZS5pZCk/LihkZWNvZGVkUmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXJlIGRlYWxpbmcgd2l0aCBhIHN1YnNjcmlwdGlvbiBtZXNzYWdlXG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25JZCA9IGAke3Jlc3BvbnNlLm1ldGhvZH06OiR7cmVzcG9uc2UucGFyYW1zLnN1YnNjcmlwdGlvbn1gO1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9faW50ZXJuYWxfX3N1YnNjcmlwdGlvbnMuZ2V0KHN1YnNjcmlwdGlvbklkKT8uWzBdO1xuICAgICAgICAgICAgY2FsbGJhY2s/LihkZWNvZGVkUmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZGRDaGFpbiA9IHRoaXMuX19pbnRlcm5hbF9fc2hhcmVkU2FuZGJveFxuICAgICAgICAgICAgPyAoYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuX19pbnRlcm5hbF9fc2hhcmVkU2FuZGJveDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgc291cmNlLl9faW50ZXJuYWxfX2NoYWluKS5hZGRDaGFpbiguLi5hcmdzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHRoaXMuX19pbnRlcm5hbF9fd2VsbEtub3duQ2hhaW5zLmhhcyh0aGlzLl9faW50ZXJuYWxfX3NwZWMpXG4gICAgICAgICAgICAgICAgPyBjbGllbnQuYWRkV2VsbEtub3duQ2hhaW5cbiAgICAgICAgICAgICAgICA6IGNsaWVudC5hZGRDaGFpbjtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19jaGFpbiA9IGFkZENoYWluKHRoaXMuX19pbnRlcm5hbF9fc3BlYywgb25SZXNwb25zZSkudGhlbigoY2hhaW4pID0+IHtcbiAgICAgICAgICAgIGhjLnNldFNlbmRKc29uUnBjKGNoYWluLnNlbmRKc29uUnBjKTtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9faXNDaGFpblJlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgY2FsbGJhY2tzIGxlZnQsIHdlIGhhdmUgdG8gcmVqZWN0L2Vycm9yIHRoZW0uXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGF0IHdvdWxkIGNhdXNlIGEgbWVtb3J5IGxlYWsuXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKCdEaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3JlcXVlc3RzLmZvckVhY2goKGNiKSA9PiBjYihkaXNjb25uZWN0aW9uRXJyb3IpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N1YnNjcmlwdGlvbnMuZm9yRWFjaCgoW2NiXSkgPT4gY2IoZGlzY29ubmVjdGlvbkVycm9yKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19zdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3RhbGVTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgICAgICBjb25zdCBraWxsU3RhbGVTdWJzY3JpcHRpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdGFsZVN1YnNjcmlwdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhbGUgPSBzdGFsZVN1YnNjcmlwdGlvbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgc3RhbGUgc3Vic2NyaXB0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIHVuc3Vic2NyaWJlTWV0aG9kIH0gPSBzdGFsZTtcbiAgICAgICAgICAgICAgICBQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIC5yYWNlKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKHVuc3Vic2NyaWJlTWV0aG9kLCBbaWRdKS5jYXRjaChub29wKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihraWxsU3RhbGVTdWJzY3JpcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gobm9vcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaGMuc3RhcnQoKGhlYWx0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZHkgPSAhaGVhbHRoLmlzU3luY2luZyAmJiAoaGVhbHRoLnBlZXJzID4gMCB8fCAhaGVhbHRoLnNob3VsZEhhdmVQZWVycyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoZW4gbm90aGluZyBoYXMgY2hhbmdlZCBhbmQgd2UgYXJlIGRvbmVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2ludGVybmFsX19pc0NoYWluUmVhZHkgPT09IGlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2lzQ2hhaW5SZWFkeSA9IGlzUmVhZHk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhpcyBwb2ludCwgdGhhdCBtZWFucyB0aGF0IHRoZSBjaGFpbiB1c2VkIHRvIGJlIFwicmVhZHlcIlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbm93IHdlIGFyZSBhYm91dCB0byBlbWl0IGBkaXNjb25uZWN0ZWRgLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgY2F1c2UgdGhlIFBvbGthZG90SnMgQVBJIHRoaW5rIHRoYXQgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGVhZC4gSW4gcmVhbGl0eSB0aGUgc21vbGRvdCBjaGFpbiBpcyBub3QgZGVhZCwgb2YgY291cnNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBoYXZlIHRvIGNsZWFudXAgYWxsIHRoZSBleGlzdGluZyBjYWxsYmFja3MgYmVjYXVzZSB3aGVuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzbW9sZG90IGNoYWluIHN0b3BzIHN5bmNpbmcsIHRoZW4gd2Ugd2lsbCBlbWl0IGBjb25uZWN0ZWRgIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgUG9sa2Fkb3RKcyBBUEkgd2lsbCB0cnkgdG8gcmUtY3JlYXRlIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgICAgICAvLyBzdWJzY3JpcHRpb25zIGFuZCByZXF1ZXN0cy4gQWx0aG91Z2gsIG5vdyBpcyBub3QgYSBnb29kIG1vbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSBzZW5kaW5nIHVuc3Vic2NyaXB0aW9uIG1lc3NhZ2VzIHRvIHRoZSBzbW9sZG90IGNoYWluLCB3ZVxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgd2FpdCB1bnRpbCBpcyBubyBsb25nZXIgc3luY2luZyB0byBzZW5kIHRoZSB1bnN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlcyBmcm9tIHRoZSBzdGFsZSBzdWJzY3JpcHRpb25zIG9mIHRoZSBwcmV2aW91cyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGF0J3Mgd2h5IC1iZWZvcmUgd2UgcGVyZm9ybSB0aGUgY2xlYW51cCBvZiBgdGhpcy5fX2ludGVybmFsX19zdWJzY3JpcHRpb25zYC1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2Uga2VlcCB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRoYXQgd2Ugd2lsbCBuZWVkIGxhdGVyIG9uIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGtpbGwgdGhlIHN0YWxlIHN1YnNjcmlwdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIFsuLi50aGlzLl9faW50ZXJuYWxfX3N1YnNjcmlwdGlvbnMudmFsdWVzKCldLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxlU3Vic2NyaXB0aW9ucy5wdXNoKHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2V2ZW50ZW1pdHRlci5lbWl0KCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbGxTdGFsZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19ldmVudGVtaXR0ZXIuZW1pdCgnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faW50ZXJuYWxfX3Jlc3Vic2NyaWJlTWV0aG9kcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3Jlc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RTcHJlYWQoe30sIGNoYWluLCB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhjLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbmRKc29uUnBjOiBoYy5zZW5kSnNvblJwYy5iaW5kKGhjKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fX2ludGVybmFsX19jaGFpbjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19jaGFpbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2V2ZW50ZW1pdHRlci5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfX2ludGVybmFsX19yZXN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19yZXN1YnNjcmliZU1ldGhvZHMuZm9yRWFjaCgoc3ViRGV0YWlscykgPT4ge1xuICAgICAgICAgICAgLy8gb25seSByZS1jcmVhdGUgc3Vic2NyaXB0aW9ucyB3aGljaCBhcmUgbm90IGluIGF1dGhvciAob25seSBhcmVhIHdoZXJlXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbnMgYXJlIGNyZWF0ZWQsIGkuZS4gc3VibWlzc2lvbnMgc3VjaCBhcyAnYXV0aG9yX3N1Ym1pdEFuZFdhdGNoRXh0cmluc2ljJ1xuICAgICAgICAgICAgLy8gYXJlIG5vdCBpbmNsdWRlZCAoYW5kIHdpbGwgbm90IGJlIHJlLWJyb2FkY2FzdClcbiAgICAgICAgICAgIGlmIChzdWJEZXRhaWxzLnR5cGUuc3RhcnRzV2l0aCgnYXV0aG9yXycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoc3ViRGV0YWlscy50eXBlLCBzdWJEZXRhaWxzLm1ldGhvZCwgc3ViRGV0YWlscy5wYXJhbXMsIHN1YkRldGFpbHMuY2FsbGJhY2spLmNhdGNoKChlcnJvcikgPT4gY29uc29sZS5sb2coZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS5jYXRjaCgoZXJyKSA9PiBsLmxvZyhlcnIpKTtcbiAgICB9O1xuICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2ludGVybmFsX19jaGFpbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWluID0gYXdhaXQgdGhpcy5fX2ludGVybmFsX19jaGFpbjtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19jaGFpbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9faXNDaGFpblJlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGFpbi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fZXZlbnRlbWl0dGVyLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgIH1cbiAgICBvbih0eXBlLCBzdWIpIHtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZS4gQWx0aG91Z2gsIHF1aXRlIHVubGlrZWx5LCB0aGF0IGJ5IHRoZSB0aW1lIHRoYXQgcG9sa2Fkb3RcbiAgICAgICAgLy8gc3Vic2NyaWJlcyB0byB0aGUgYGNvbm5lY3RlZGAgZXZlbnQsIHRoZSBQcm92aWRlciBpcyBhbHJlYWR5IGNvbm5lY3RlZC5cbiAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSBtdXN0IGVtaXQgdG8gbGV0IHRoZSBjb25zdW1lciBrbm93IHRoYXQgd2UgYXJlIGNvbm5lY3RlZC5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb25uZWN0ZWQnICYmIHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHN1YigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fZXZlbnRlbWl0dGVyLm9uKHR5cGUsIHN1Yik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2V2ZW50ZW1pdHRlci5yZW1vdmVMaXN0ZW5lcih0eXBlLCBzdWIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCB8fCAhdGhpcy5fX2ludGVybmFsX19jaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlciBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhaW4gPSBhd2FpdCB0aGlzLl9faW50ZXJuYWxfX2NoYWluO1xuICAgICAgICBjb25zdCBbaWQsIGpzb25dID0gdGhpcy5fX2ludGVybmFsX19jb2Rlci5lbmNvZGVKc29uKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19yZXF1ZXN0cy5zZXQoaWQsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIChpc0Vycm9yKHJlc3BvbnNlKSA/IHJlamVjdCA6IHJlc29sdmUpKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGFpbi5zZW5kSnNvblJwYyhqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19jaGFpbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2V2ZW50ZW1pdHRlci5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBsZXQncyBlbnN1cmUgdGhhdCBvbmNlIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkL3JlamVjdGVkLCB0aGVuIHdlIHJlbW92ZVxuICAgICAgICAgICAgLy8gcmVtb3ZlIGl0cyBlbnRyeSBmcm9tIHRoZSBpbnRlcm5hbCAjcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fcmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzdWJzY3JpYmUodHlwZSwgbWV0aG9kLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uVW5zdWJzY3JpcHRpb25NZXRob2RzLmhhcyhtZXRob2QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHN1YnNjcmliZSBtZXRob2Q6ICR7bWV0aG9kfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gYXdhaXQgdGhpcy5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uSWQgPSBgJHt0eXBlfTo6JHtpZH1gO1xuICAgICAgICBjb25zdCBjYiA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVNZXRob2QgPSBzdWJzY3JpcHRpb25VbnN1YnNjcmlwdGlvbk1ldGhvZHMuZ2V0KG1ldGhvZCk7XG4gICAgICAgIGlmICghdW5zdWJzY3JpYmVNZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bnN1YnNjcmliZSBtZXRob2QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3Jlc3Vic2NyaWJlTWV0aG9kcy5zZXQoc3Vic2NyaXB0aW9uSWQsIHsgY2FsbGJhY2ssIG1ldGhvZCwgcGFyYW1zLCB0eXBlIH0pO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N1YnNjcmlwdGlvbnMuc2V0KHN1YnNjcmlwdGlvbklkLCBbY2IsIHsgaWQsIHVuc3Vic2NyaWJlTWV0aG9kIH1dKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZSh0eXBlLCBtZXRob2QsIGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlciBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uSWQgPSBgJHt0eXBlfTo6JHtpZH1gO1xuICAgICAgICBpZiAoIXRoaXMuX19pbnRlcm5hbF9fc3Vic2NyaXB0aW9ucy5oYXMoc3Vic2NyaXB0aW9uSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBhY3RpdmUgc3Vic2NyaXB0aW9uPSR7c3Vic2NyaXB0aW9uSWR9YCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fcmVzdWJzY3JpYmVNZXRob2RzLmRlbGV0ZShzdWJzY3JpcHRpb25JZCk7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fc3Vic2NyaXB0aW9ucy5kZWxldGUoc3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKG1ldGhvZCwgW2lkXSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/substrate-connect/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/ws/errors.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/ws/errors.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWSErrorString: () => (/* binding */ getWSErrorString)\n/* harmony export */ });\nconst known = {\n    1000: 'Normal Closure',\n    1001: 'Going Away',\n    1002: 'Protocol Error',\n    1003: 'Unsupported Data',\n    1004: '(For future)',\n    1005: 'No Status Received',\n    1006: 'Abnormal Closure',\n    1007: 'Invalid frame payload data',\n    1008: 'Policy Violation',\n    1009: 'Message too big',\n    1010: 'Missing Extension',\n    1011: 'Internal Error',\n    1012: 'Service Restart',\n    1013: 'Try Again Later',\n    1014: 'Bad Gateway',\n    1015: 'TLS Handshake'\n};\nfunction getWSErrorString(code) {\n    if (code >= 0 && code <= 999) {\n        return '(Unused)';\n    }\n    else if (code >= 1016) {\n        if (code <= 1999) {\n            return '(For WebSocket standard)';\n        }\n        else if (code <= 2999) {\n            return '(For WebSocket extensions)';\n        }\n        else if (code <= 3999) {\n            return '(For libraries and frameworks)';\n        }\n        else if (code <= 4999) {\n            return '(For applications)';\n        }\n    }\n    return known[code] || '(Unknown)';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvd3MvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hYnViYWtyamltb2gvRGVza3RvcC9Db2RpbmcgU3R1ZmZzL2hhY2thdGhvbi9zZWNyZXQtbmV0d29yay9tZW1lQWlfY29pbl9jcmVhdG9yL2FpLW1lbWUtY29pbi1jcmVhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS9AcG9sa2Fkb3QrcnBjLXByb3ZpZGVyQDE0LjMuMV9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvQHBvbGthZG90L3JwYy1wcm92aWRlci93cy9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qga25vd24gPSB7XG4gICAgMTAwMDogJ05vcm1hbCBDbG9zdXJlJyxcbiAgICAxMDAxOiAnR29pbmcgQXdheScsXG4gICAgMTAwMjogJ1Byb3RvY29sIEVycm9yJyxcbiAgICAxMDAzOiAnVW5zdXBwb3J0ZWQgRGF0YScsXG4gICAgMTAwNDogJyhGb3IgZnV0dXJlKScsXG4gICAgMTAwNTogJ05vIFN0YXR1cyBSZWNlaXZlZCcsXG4gICAgMTAwNjogJ0Fibm9ybWFsIENsb3N1cmUnLFxuICAgIDEwMDc6ICdJbnZhbGlkIGZyYW1lIHBheWxvYWQgZGF0YScsXG4gICAgMTAwODogJ1BvbGljeSBWaW9sYXRpb24nLFxuICAgIDEwMDk6ICdNZXNzYWdlIHRvbyBiaWcnLFxuICAgIDEwMTA6ICdNaXNzaW5nIEV4dGVuc2lvbicsXG4gICAgMTAxMTogJ0ludGVybmFsIEVycm9yJyxcbiAgICAxMDEyOiAnU2VydmljZSBSZXN0YXJ0JyxcbiAgICAxMDEzOiAnVHJ5IEFnYWluIExhdGVyJyxcbiAgICAxMDE0OiAnQmFkIEdhdGV3YXknLFxuICAgIDEwMTU6ICdUTFMgSGFuZHNoYWtlJ1xufTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRXU0Vycm9yU3RyaW5nKGNvZGUpIHtcbiAgICBpZiAoY29kZSA+PSAwICYmIGNvZGUgPD0gOTk5KSB7XG4gICAgICAgIHJldHVybiAnKFVudXNlZCknO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID49IDEwMTYpIHtcbiAgICAgICAgaWYgKGNvZGUgPD0gMTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuICcoRm9yIFdlYlNvY2tldCBzdGFuZGFyZCknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGUgPD0gMjk5OSkge1xuICAgICAgICAgICAgcmV0dXJuICcoRm9yIFdlYlNvY2tldCBleHRlbnNpb25zKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZSA8PSAzOTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gJyhGb3IgbGlicmFyaWVzIGFuZCBmcmFtZXdvcmtzKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZSA8PSA0OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gJyhGb3IgYXBwbGljYXRpb25zKSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duW2NvZGVdIHx8ICcoVW5rbm93biknO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/ws/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/ws/index.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/ws/index.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WsProvider: () => (/* binding */ WsProvider)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"(rsc)/./node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/logger.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/noop.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/is/childClass.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/stringify.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/is/undefined.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/is/null.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @polkadot/util */ \"(rsc)/./node_modules/.pnpm/@polkadot+util@13.4.3/node_modules/@polkadot/util/object/spread.js\");\n/* harmony import */ var _polkadot_x_global__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polkadot/x-global */ \"(rsc)/./node_modules/.pnpm/@polkadot+x-global@13.4.3/node_modules/@polkadot/x-global/index.js\");\n/* harmony import */ var _polkadot_x_ws__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @polkadot/x-ws */ \"(rsc)/./node_modules/.pnpm/@polkadot+x-ws@13.4.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/x-ws/node.js\");\n/* harmony import */ var _coder_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../coder/index.js */ \"(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/coder/index.js\");\n/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../defaults.js */ \"(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/defaults.js\");\n/* harmony import */ var _lru_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lru.js */ \"(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/lru.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/ws/errors.js\");\n\n\n\n\n\n\n\n\nconst ALIASES = {\n    chain_finalisedHead: 'chain_finalizedHead',\n    chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n    chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 2_500;\nconst DEFAULT_TIMEOUT_MS = 60 * 1000;\nconst TIMEOUT_INTERVAL = 5_000;\nconst l = (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_1__.logger)('api-ws');\n/** @internal Clears a Record<*> of all keys, optionally with all callback on clear */\nfunction eraseRecord(record, cb) {\n    Object.keys(record).forEach((key) => {\n        if (cb) {\n            cb(record[key]);\n        }\n        delete record[key];\n    });\n}\n/** @internal Creates a default/empty stats object */\nfunction defaultEndpointStats() {\n    return { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 };\n}\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\nclass WsProvider {\n    __internal__callCache;\n    __internal__coder;\n    __internal__endpoints;\n    __internal__headers;\n    __internal__eventemitter;\n    __internal__handlers = {};\n    __internal__isReadyPromise;\n    __internal__stats;\n    __internal__waitingForId = {};\n    __internal__cacheCapacity;\n    __internal__autoConnectMs;\n    __internal__endpointIndex;\n    __internal__endpointStats;\n    __internal__isConnected = false;\n    __internal__subscriptions = {};\n    __internal__timeoutId = null;\n    __internal__websocket;\n    __internal__timeout;\n    /**\n     * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n     * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.\n     * @param {Record<string, string>} headers The headers provided to the underlying WebSocket\n     * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`\n     */\n    constructor(endpoint = _defaults_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout, cacheCapacity) {\n        const endpoints = Array.isArray(endpoint)\n            ? endpoint\n            : [endpoint];\n        if (endpoints.length === 0) {\n            throw new Error('WsProvider requires at least one Endpoint');\n        }\n        endpoints.forEach((endpoint) => {\n            if (!/^(wss|ws):\\/\\//.test(endpoint)) {\n                throw new Error(`Endpoint should start with 'ws://', received '${endpoint}'`);\n            }\n        });\n        this.__internal__callCache = new _lru_js__WEBPACK_IMPORTED_MODULE_3__.LRUCache(cacheCapacity || _lru_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CAPACITY);\n        this.__internal__cacheCapacity = cacheCapacity || _lru_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CAPACITY;\n        this.__internal__eventemitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n        this.__internal__autoConnectMs = autoConnectMs || 0;\n        this.__internal__coder = new _coder_index_js__WEBPACK_IMPORTED_MODULE_4__.RpcCoder();\n        this.__internal__endpointIndex = -1;\n        this.__internal__endpoints = endpoints;\n        this.__internal__headers = headers;\n        this.__internal__websocket = null;\n        this.__internal__stats = {\n            active: { requests: 0, subscriptions: 0 },\n            total: defaultEndpointStats()\n        };\n        this.__internal__endpointStats = defaultEndpointStats();\n        this.__internal__timeout = timeout || DEFAULT_TIMEOUT_MS;\n        if (autoConnectMs && autoConnectMs > 0) {\n            this.connectWithRetry().catch(_polkadot_util__WEBPACK_IMPORTED_MODULE_5__.noop);\n        }\n        this.__internal__isReadyPromise = new Promise((resolve) => {\n            this.__internal__eventemitter.once('connected', () => {\n                resolve(this);\n            });\n        });\n    }\n    /**\n     * @summary `true` when this provider supports subscriptions\n     */\n    get hasSubscriptions() {\n        return !!true;\n    }\n    /**\n     * @summary `true` when this provider supports clone()\n     */\n    get isClonable() {\n        return !!true;\n    }\n    /**\n     * @summary Whether the node is connected or not.\n     * @return {boolean} true if connected\n     */\n    get isConnected() {\n        return this.__internal__isConnected;\n    }\n    /**\n     * @description Promise that resolves the first time we are connected and loaded\n     */\n    get isReady() {\n        return this.__internal__isReadyPromise;\n    }\n    get endpoint() {\n        return this.__internal__endpoints[this.__internal__endpointIndex];\n    }\n    /**\n     * @description Returns a clone of the object\n     */\n    clone() {\n        return new WsProvider(this.__internal__endpoints);\n    }\n    selectEndpointIndex(endpoints) {\n        return (this.__internal__endpointIndex + 1) % endpoints.length;\n    }\n    /**\n     * @summary Manually connect\n     * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n     * connect manually using this method.\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async connect() {\n        if (this.__internal__websocket) {\n            throw new Error('WebSocket is already connected');\n        }\n        try {\n            this.__internal__endpointIndex = this.selectEndpointIndex(this.__internal__endpoints);\n            // the as here is Deno-specific - not available on the globalThis\n            this.__internal__websocket = typeof _polkadot_x_global__WEBPACK_IMPORTED_MODULE_6__.xglobal.WebSocket !== 'undefined' && (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_7__.isChildClass)(_polkadot_x_global__WEBPACK_IMPORTED_MODULE_6__.xglobal.WebSocket, _polkadot_x_ws__WEBPACK_IMPORTED_MODULE_8__.WebSocket)\n                ? new _polkadot_x_ws__WEBPACK_IMPORTED_MODULE_8__.WebSocket(this.endpoint)\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore - WS may be an instance of ws, which supports options\n                : new _polkadot_x_ws__WEBPACK_IMPORTED_MODULE_8__.WebSocket(this.endpoint, undefined, {\n                    headers: this.__internal__headers\n                });\n            if (this.__internal__websocket) {\n                this.__internal__websocket.onclose = this.__internal__onSocketClose;\n                this.__internal__websocket.onerror = this.__internal__onSocketError;\n                this.__internal__websocket.onmessage = this.__internal__onSocketMessage;\n                this.__internal__websocket.onopen = this.__internal__onSocketOpen;\n            }\n            // timeout any handlers that have not had a response\n            this.__internal__timeoutId = setInterval(() => this.__internal__timeoutHandlers(), TIMEOUT_INTERVAL);\n        }\n        catch (error) {\n            l.error(error);\n            this.__internal__emit('error', error);\n            throw error;\n        }\n    }\n    /**\n     * @description Connect, never throwing an error, but rather forcing a retry\n     */\n    async connectWithRetry() {\n        if (this.__internal__autoConnectMs > 0) {\n            try {\n                await this.connect();\n            }\n            catch {\n                setTimeout(() => {\n                    this.connectWithRetry().catch(_polkadot_util__WEBPACK_IMPORTED_MODULE_5__.noop);\n                }, this.__internal__autoConnectMs);\n            }\n        }\n    }\n    /**\n     * @description Manually disconnect from the connection, clearing auto-connect logic\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async disconnect() {\n        // switch off autoConnect, we are in manual mode now\n        this.__internal__autoConnectMs = 0;\n        try {\n            if (this.__internal__websocket) {\n                // 1000 - Normal closure; the connection successfully completed\n                this.__internal__websocket.close(1000);\n            }\n        }\n        catch (error) {\n            l.error(error);\n            this.__internal__emit('error', error);\n            throw error;\n        }\n    }\n    /**\n     * @description Returns the connection stats\n     */\n    get stats() {\n        return {\n            active: {\n                requests: Object.keys(this.__internal__handlers).length,\n                subscriptions: Object.keys(this.__internal__subscriptions).length\n            },\n            total: this.__internal__stats.total\n        };\n    }\n    get endpointStats() {\n        return this.__internal__endpointStats;\n    }\n    /**\n     * @summary Listens on events after having subscribed using the [[subscribe]] function.\n     * @param  {ProviderInterfaceEmitted} type Event\n     * @param  {ProviderInterfaceEmitCb}  sub  Callback\n     * @return unsubscribe function\n     */\n    on(type, sub) {\n        this.__internal__eventemitter.on(type, sub);\n        return () => {\n            this.__internal__eventemitter.removeListener(type, sub);\n        };\n    }\n    /**\n     * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n     * @param method The RPC methods to execute\n     * @param params Encoded parameters as applicable for the method\n     * @param subscription Subscription details (internally used)\n     */\n    send(method, params, isCacheable, subscription) {\n        this.__internal__endpointStats.requests++;\n        this.__internal__stats.total.requests++;\n        const [id, body] = this.__internal__coder.encodeJson(method, params);\n        if (this.__internal__cacheCapacity === 0) {\n            return this.__internal__send(id, body, method, params, subscription);\n        }\n        const cacheKey = isCacheable ? `${method}::${(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_9__.stringify)(params)}` : '';\n        let resultPromise = isCacheable\n            ? this.__internal__callCache.get(cacheKey)\n            : null;\n        if (!resultPromise) {\n            resultPromise = this.__internal__send(id, body, method, params, subscription);\n            if (isCacheable) {\n                this.__internal__callCache.set(cacheKey, resultPromise);\n            }\n        }\n        else {\n            this.__internal__endpointStats.cached++;\n            this.__internal__stats.total.cached++;\n        }\n        return resultPromise;\n    }\n    async __internal__send(id, body, method, params, subscription) {\n        return new Promise((resolve, reject) => {\n            try {\n                if (!this.isConnected || this.__internal__websocket === null) {\n                    throw new Error('WebSocket is not connected');\n                }\n                const callback = (error, result) => {\n                    error\n                        ? reject(error)\n                        : resolve(result);\n                };\n                l.debug(() => ['calling', method, body]);\n                this.__internal__handlers[id] = {\n                    callback,\n                    method,\n                    params,\n                    start: Date.now(),\n                    subscription\n                };\n                const bytesSent = body.length;\n                this.__internal__endpointStats.bytesSent += bytesSent;\n                this.__internal__stats.total.bytesSent += bytesSent;\n                this.__internal__websocket.send(body);\n            }\n            catch (error) {\n                this.__internal__endpointStats.errors++;\n                this.__internal__stats.total.errors++;\n                reject(error);\n            }\n        });\n    }\n    /**\n     * @name subscribe\n     * @summary Allows subscribing to a specific event.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * const provider = new WsProvider('ws://127.0.0.1:9944');\n     * const rpc = new Rpc(provider);\n     *\n     * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n     *   console.log(values)\n     * }).then((subscriptionId) => {\n     *   console.log('balance changes subscription id: ', subscriptionId)\n     * })\n     * ```\n     */\n    subscribe(type, method, params, callback) {\n        this.__internal__endpointStats.subscriptions++;\n        this.__internal__stats.total.subscriptions++;\n        // subscriptions are not cached, LRU applies to .at(<blockHash>) only\n        return this.send(method, params, false, { callback, type });\n    }\n    /**\n     * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n     */\n    async unsubscribe(type, method, id) {\n        const subscription = `${type}::${id}`;\n        // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n        // the assigned id now does not match what the API user originally received. It has\n        // a slight complication in solving - since we cannot rely on the send id, but rather\n        // need to find the actual subscription id to map it\n        if ((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_10__.isUndefined)(this.__internal__subscriptions[subscription])) {\n            l.debug(() => `Unable to find active subscription=${subscription}`);\n            return false;\n        }\n        delete this.__internal__subscriptions[subscription];\n        try {\n            return this.isConnected && !(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_11__.isNull)(this.__internal__websocket)\n                ? this.send(method, [id])\n                : true;\n        }\n        catch {\n            return false;\n        }\n    }\n    __internal__emit = (type, ...args) => {\n        this.__internal__eventemitter.emit(type, ...args);\n    };\n    __internal__onSocketClose = (event) => {\n        const error = new Error(`disconnected from ${this.endpoint}: ${event.code}:: ${event.reason || (0,_errors_js__WEBPACK_IMPORTED_MODULE_12__.getWSErrorString)(event.code)}`);\n        if (this.__internal__autoConnectMs > 0) {\n            l.error(error.message);\n        }\n        this.__internal__isConnected = false;\n        if (this.__internal__websocket) {\n            this.__internal__websocket.onclose = null;\n            this.__internal__websocket.onerror = null;\n            this.__internal__websocket.onmessage = null;\n            this.__internal__websocket.onopen = null;\n            this.__internal__websocket = null;\n        }\n        if (this.__internal__timeoutId) {\n            clearInterval(this.__internal__timeoutId);\n            this.__internal__timeoutId = null;\n        }\n        // reject all hanging requests\n        eraseRecord(this.__internal__handlers, (h) => {\n            try {\n                h.callback(error, undefined);\n            }\n            catch (err) {\n                // does not throw\n                l.error(err);\n            }\n        });\n        eraseRecord(this.__internal__waitingForId);\n        // Reset stats for active endpoint\n        this.__internal__endpointStats = defaultEndpointStats();\n        this.__internal__emit('disconnected');\n        if (this.__internal__autoConnectMs > 0) {\n            setTimeout(() => {\n                this.connectWithRetry().catch(_polkadot_util__WEBPACK_IMPORTED_MODULE_5__.noop);\n            }, this.__internal__autoConnectMs);\n        }\n    };\n    __internal__onSocketError = (error) => {\n        l.debug(() => ['socket error', error]);\n        this.__internal__emit('error', error);\n    };\n    __internal__onSocketMessage = (message) => {\n        l.debug(() => ['received', message.data]);\n        const bytesRecv = message.data.length;\n        this.__internal__endpointStats.bytesRecv += bytesRecv;\n        this.__internal__stats.total.bytesRecv += bytesRecv;\n        const response = JSON.parse(message.data);\n        return (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_10__.isUndefined)(response.method)\n            ? this.__internal__onSocketMessageResult(response)\n            : this.__internal__onSocketMessageSubscribe(response);\n    };\n    __internal__onSocketMessageResult = (response) => {\n        const handler = this.__internal__handlers[response.id];\n        if (!handler) {\n            l.debug(() => `Unable to find handler for id=${response.id}`);\n            return;\n        }\n        try {\n            const { method, params, subscription } = handler;\n            const result = this.__internal__coder.decodeResponse(response);\n            // first send the result - in case of subs, we may have an update\n            // immediately if we have some queued results already\n            handler.callback(null, result);\n            if (subscription) {\n                const subId = `${subscription.type}::${result}`;\n                this.__internal__subscriptions[subId] = (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_13__.objectSpread)({}, subscription, {\n                    method,\n                    params\n                });\n                // if we have a result waiting for this subscription already\n                if (this.__internal__waitingForId[subId]) {\n                    this.__internal__onSocketMessageSubscribe(this.__internal__waitingForId[subId]);\n                }\n            }\n        }\n        catch (error) {\n            this.__internal__endpointStats.errors++;\n            this.__internal__stats.total.errors++;\n            handler.callback(error, undefined);\n        }\n        delete this.__internal__handlers[response.id];\n    };\n    __internal__onSocketMessageSubscribe = (response) => {\n        if (!response.method) {\n            throw new Error('No method found in JSONRPC response');\n        }\n        const method = ALIASES[response.method] || response.method;\n        const subId = `${method}::${response.params.subscription}`;\n        const handler = this.__internal__subscriptions[subId];\n        if (!handler) {\n            // store the JSON, we could have out-of-order subid coming in\n            this.__internal__waitingForId[subId] = response;\n            l.debug(() => `Unable to find handler for subscription=${subId}`);\n            return;\n        }\n        // housekeeping\n        delete this.__internal__waitingForId[subId];\n        try {\n            const result = this.__internal__coder.decodeResponse(response);\n            handler.callback(null, result);\n        }\n        catch (error) {\n            this.__internal__endpointStats.errors++;\n            this.__internal__stats.total.errors++;\n            handler.callback(error, undefined);\n        }\n    };\n    __internal__onSocketOpen = () => {\n        if (this.__internal__websocket === null) {\n            throw new Error('WebSocket cannot be null in onOpen');\n        }\n        l.debug(() => ['connected to', this.endpoint]);\n        this.__internal__isConnected = true;\n        this.__internal__resubscribe();\n        this.__internal__emit('connected');\n        return true;\n    };\n    __internal__resubscribe = () => {\n        const subscriptions = this.__internal__subscriptions;\n        this.__internal__subscriptions = {};\n        Promise.all(Object.keys(subscriptions).map(async (id) => {\n            const { callback, method, params, type } = subscriptions[id];\n            // only re-create subscriptions which are not in author (only area where\n            // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n            // are not included (and will not be re-broadcast)\n            if (type.startsWith('author_')) {\n                return;\n            }\n            try {\n                await this.subscribe(type, method, params, callback);\n            }\n            catch (error) {\n                l.error(error);\n            }\n        })).catch(l.error);\n    };\n    __internal__timeoutHandlers = () => {\n        const now = Date.now();\n        const ids = Object.keys(this.__internal__handlers);\n        for (let i = 0, count = ids.length; i < count; i++) {\n            const handler = this.__internal__handlers[ids[i]];\n            if ((now - handler.start) > this.__internal__timeout) {\n                try {\n                    handler.callback(new Error(`No response received from RPC endpoint in ${this.__internal__timeout / 1000}s`), undefined);\n                }\n                catch {\n                    // ignore\n                }\n                this.__internal__endpointStats.timeout++;\n                this.__internal__stats.total.timeout++;\n                delete this.__internal__handlers[ids[i]];\n            }\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBvbGthZG90K3JwYy1wcm92aWRlckAxNC4zLjFfYnVmZmVydXRpbEA0LjAuOV91dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvd3MvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQzZEO0FBQzdEO0FBQ0Y7QUFDRTtBQUNQO0FBQ2lCO0FBQ1I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsd0JBQXdCO0FBQ3ZDLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDJCQUEyQixvREFBUSxrREFBa0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixTQUFTO0FBQzFGO0FBQ0EsU0FBUztBQUNULHlDQUF5Qyw2Q0FBUSxrQkFBa0IscURBQWdCO0FBQ25GLDBEQUEwRCxxREFBZ0I7QUFDMUUsNENBQTRDLHVEQUFZO0FBQ3hEO0FBQ0EscUNBQXFDLHFEQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0RBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdURBQU8sOEJBQThCLDREQUFZLENBQUMsdURBQU8sWUFBWSxxREFBUztBQUM5SCxzQkFBc0IscURBQVM7QUFDL0I7QUFDQTtBQUNBLHNCQUFzQixxREFBUztBQUMvQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnREFBSTtBQUN0RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUMsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTyxJQUFJLHlEQUFTLFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLLElBQUksR0FBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQVc7QUFDdkIsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdURBQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjLElBQUksV0FBVyxLQUFLLGdCQUFnQiw2REFBZ0IsYUFBYTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdEQUFJO0FBQ2xELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDREQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0IsSUFBSSxPQUFPO0FBQzlELHdEQUF3RCw2REFBWSxHQUFHO0FBQ3ZFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sSUFBSSw2QkFBNkI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsTUFBTTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGdDQUFnQztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hYnViYWtyamltb2gvRGVza3RvcC9Db2RpbmcgU3R1ZmZzL2hhY2thdGhvbi9zZWNyZXQtbmV0d29yay9tZW1lQWlfY29pbl9jcmVhdG9yL2FpLW1lbWUtY29pbi1jcmVhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS9AcG9sa2Fkb3QrcnBjLXByb3ZpZGVyQDE0LjMuMV9idWZmZXJ1dGlsQDQuMC45X3V0Zi04LXZhbGlkYXRlQDUuMC4xMC9ub2RlX21vZHVsZXMvQHBvbGthZG90L3JwYy1wcm92aWRlci93cy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IGlzQ2hpbGRDbGFzcywgaXNOdWxsLCBpc1VuZGVmaW5lZCwgbG9nZ2VyLCBub29wLCBvYmplY3RTcHJlYWQsIHN0cmluZ2lmeSB9IGZyb20gJ0Bwb2xrYWRvdC91dGlsJztcbmltcG9ydCB7IHhnbG9iYWwgfSBmcm9tICdAcG9sa2Fkb3QveC1nbG9iYWwnO1xuaW1wb3J0IHsgV2ViU29ja2V0IH0gZnJvbSAnQHBvbGthZG90L3gtd3MnO1xuaW1wb3J0IHsgUnBjQ29kZXIgfSBmcm9tICcuLi9jb2Rlci9pbmRleC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMuanMnO1xuaW1wb3J0IHsgREVGQVVMVF9DQVBBQ0lUWSwgTFJVQ2FjaGUgfSBmcm9tICcuLi9scnUuanMnO1xuaW1wb3J0IHsgZ2V0V1NFcnJvclN0cmluZyB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmNvbnN0IEFMSUFTRVMgPSB7XG4gICAgY2hhaW5fZmluYWxpc2VkSGVhZDogJ2NoYWluX2ZpbmFsaXplZEhlYWQnLFxuICAgIGNoYWluX3N1YnNjcmliZUZpbmFsaXNlZEhlYWRzOiAnY2hhaW5fc3Vic2NyaWJlRmluYWxpemVkSGVhZHMnLFxuICAgIGNoYWluX3Vuc3Vic2NyaWJlRmluYWxpc2VkSGVhZHM6ICdjaGFpbl91bnN1YnNjcmliZUZpbmFsaXplZEhlYWRzJ1xufTtcbmNvbnN0IFJFVFJZX0RFTEFZID0gMl81MDA7XG5jb25zdCBERUZBVUxUX1RJTUVPVVRfTVMgPSA2MCAqIDEwMDA7XG5jb25zdCBUSU1FT1VUX0lOVEVSVkFMID0gNV8wMDA7XG5jb25zdCBsID0gbG9nZ2VyKCdhcGktd3MnKTtcbi8qKiBAaW50ZXJuYWwgQ2xlYXJzIGEgUmVjb3JkPCo+IG9mIGFsbCBrZXlzLCBvcHRpb25hbGx5IHdpdGggYWxsIGNhbGxiYWNrIG9uIGNsZWFyICovXG5mdW5jdGlvbiBlcmFzZVJlY29yZChyZWNvcmQsIGNiKSB7XG4gICAgT2JqZWN0LmtleXMocmVjb3JkKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYihyZWNvcmRba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHJlY29yZFtrZXldO1xuICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCBDcmVhdGVzIGEgZGVmYXVsdC9lbXB0eSBzdGF0cyBvYmplY3QgKi9cbmZ1bmN0aW9uIGRlZmF1bHRFbmRwb2ludFN0YXRzKCkge1xuICAgIHJldHVybiB7IGJ5dGVzUmVjdjogMCwgYnl0ZXNTZW50OiAwLCBjYWNoZWQ6IDAsIGVycm9yczogMCwgcmVxdWVzdHM6IDAsIHN1YnNjcmlwdGlvbnM6IDAsIHRpbWVvdXQ6IDAgfTtcbn1cbi8qKlxuICogIyBAcG9sa2Fkb3QvcnBjLXByb3ZpZGVyL3dzXG4gKlxuICogQG5hbWUgV3NQcm92aWRlclxuICpcbiAqIEBkZXNjcmlwdGlvbiBUaGUgV2ViU29ja2V0IFByb3ZpZGVyIGFsbG93cyBzZW5kaW5nIHJlcXVlc3RzIHVzaW5nIFdlYlNvY2tldCB0byBhIFdlYlNvY2tldCBSUEMgc2VydmVyIFRDUCBwb3J0LiBVbmxpa2UgdGhlIFtbSHR0cFByb3ZpZGVyXV0sIGl0IGRvZXMgc3VwcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBhbGxvd3MgbGlzdGVuaW5nIHRvIGV2ZW50cyBzdWNoIGFzIG5ldyBibG9ja3Mgb3IgYmFsYW5jZSBjaGFuZ2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiA8QlI+XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IEFwaSBmcm9tICdAcG9sa2Fkb3QvYXBpL3Byb21pc2UnO1xuICogaW1wb3J0IHsgV3NQcm92aWRlciB9IGZyb20gJ0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvd3MnO1xuICpcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IFdzUHJvdmlkZXIoJ3dzOi8vMTI3LjAuMC4xOjk5NDQnKTtcbiAqIGNvbnN0IGFwaSA9IG5ldyBBcGkocHJvdmlkZXIpO1xuICogYGBgXG4gKlxuICogQHNlZSBbW0h0dHBQcm92aWRlcl1dXG4gKi9cbmV4cG9ydCBjbGFzcyBXc1Byb3ZpZGVyIHtcbiAgICBfX2ludGVybmFsX19jYWxsQ2FjaGU7XG4gICAgX19pbnRlcm5hbF9fY29kZXI7XG4gICAgX19pbnRlcm5hbF9fZW5kcG9pbnRzO1xuICAgIF9faW50ZXJuYWxfX2hlYWRlcnM7XG4gICAgX19pbnRlcm5hbF9fZXZlbnRlbWl0dGVyO1xuICAgIF9faW50ZXJuYWxfX2hhbmRsZXJzID0ge307XG4gICAgX19pbnRlcm5hbF9faXNSZWFkeVByb21pc2U7XG4gICAgX19pbnRlcm5hbF9fc3RhdHM7XG4gICAgX19pbnRlcm5hbF9fd2FpdGluZ0ZvcklkID0ge307XG4gICAgX19pbnRlcm5hbF9fY2FjaGVDYXBhY2l0eTtcbiAgICBfX2ludGVybmFsX19hdXRvQ29ubmVjdE1zO1xuICAgIF9faW50ZXJuYWxfX2VuZHBvaW50SW5kZXg7XG4gICAgX19pbnRlcm5hbF9fZW5kcG9pbnRTdGF0cztcbiAgICBfX2ludGVybmFsX19pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIF9faW50ZXJuYWxfX3N1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICBfX2ludGVybmFsX190aW1lb3V0SWQgPSBudWxsO1xuICAgIF9faW50ZXJuYWxfX3dlYnNvY2tldDtcbiAgICBfX2ludGVybmFsX190aW1lb3V0O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119ICBlbmRwb2ludCAgICBUaGUgZW5kcG9pbnQgdXJsLiBVc3VhbGx5IGB3czovL2lwOjk5NDRgIG9yIGB3c3M6Ly9pcDo5OTQ0YCwgbWF5IHByb3ZpZGUgYW4gYXJyYXkgb2YgZW5kcG9pbnQgc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge251bWJlciB8IGZhbHNlfSBhdXRvQ29ubmVjdE1zIFdoZXRoZXIgdG8gY29ubmVjdCBhdXRvbWF0aWNhbGx5IG9yIG5vdCAoZGVmYXVsdCkuIFByb3ZpZGVkIHZhbHVlIGlzIHVzZWQgYXMgYSBkZWxheSBiZXR3ZWVuIHJldHJpZXMuXG4gICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzIFRoZSBoZWFkZXJzIHByb3ZpZGVkIHRvIHRoZSB1bmRlcmx5aW5nIFdlYlNvY2tldFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dF0gQ3VzdG9tIHRpbWVvdXQgdmFsdWUgdXNlZCBwZXIgcmVxdWVzdCAuIERlZmF1bHRzIHRvIGBERUZBVUxUX1RJTUVPVVRfTVNgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW5kcG9pbnQgPSBkZWZhdWx0cy5XU19VUkwsIGF1dG9Db25uZWN0TXMgPSBSRVRSWV9ERUxBWSwgaGVhZGVycyA9IHt9LCB0aW1lb3V0LCBjYWNoZUNhcGFjaXR5KSB7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50cyA9IEFycmF5LmlzQXJyYXkoZW5kcG9pbnQpXG4gICAgICAgICAgICA/IGVuZHBvaW50XG4gICAgICAgICAgICA6IFtlbmRwb2ludF07XG4gICAgICAgIGlmIChlbmRwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dzUHJvdmlkZXIgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIEVuZHBvaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZW5kcG9pbnRzLmZvckVhY2goKGVuZHBvaW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIS9eKHdzc3x3cyk6XFwvXFwvLy50ZXN0KGVuZHBvaW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRW5kcG9pbnQgc2hvdWxkIHN0YXJ0IHdpdGggJ3dzOi8vJywgcmVjZWl2ZWQgJyR7ZW5kcG9pbnR9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19jYWxsQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoY2FjaGVDYXBhY2l0eSB8fCBERUZBVUxUX0NBUEFDSVRZKTtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19jYWNoZUNhcGFjaXR5ID0gY2FjaGVDYXBhY2l0eSB8fCBERUZBVUxUX0NBUEFDSVRZO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2V2ZW50ZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19hdXRvQ29ubmVjdE1zID0gYXV0b0Nvbm5lY3RNcyB8fCAwO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2NvZGVyID0gbmV3IFJwY0NvZGVyKCk7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fZW5kcG9pbnRJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50cyA9IGVuZHBvaW50cztcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX193ZWJzb2NrZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N0YXRzID0ge1xuICAgICAgICAgICAgYWN0aXZlOiB7IHJlcXVlc3RzOiAwLCBzdWJzY3JpcHRpb25zOiAwIH0sXG4gICAgICAgICAgICB0b3RhbDogZGVmYXVsdEVuZHBvaW50U3RhdHMoKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50U3RhdHMgPSBkZWZhdWx0RW5kcG9pbnRTdGF0cygpO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3RpbWVvdXQgPSB0aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVF9NUztcbiAgICAgICAgaWYgKGF1dG9Db25uZWN0TXMgJiYgYXV0b0Nvbm5lY3RNcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFdpdGhSZXRyeSgpLmNhdGNoKG5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9faXNSZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19ldmVudGVtaXR0ZXIub25jZSgnY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IGB0cnVlYCB3aGVuIHRoaXMgcHJvdmlkZXIgc3VwcG9ydHMgc3Vic2NyaXB0aW9uc1xuICAgICAqL1xuICAgIGdldCBoYXNTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gISF0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBgdHJ1ZWAgd2hlbiB0aGlzIHByb3ZpZGVyIHN1cHBvcnRzIGNsb25lKClcbiAgICAgKi9cbiAgICBnZXQgaXNDbG9uYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgV2hldGhlciB0aGUgbm9kZSBpcyBjb25uZWN0ZWQgb3Igbm90LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgY29ubmVjdGVkXG4gICAgICovXG4gICAgZ2V0IGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsX19pc0Nvbm5lY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFByb21pc2UgdGhhdCByZXNvbHZlcyB0aGUgZmlyc3QgdGltZSB3ZSBhcmUgY29ubmVjdGVkIGFuZCBsb2FkZWRcbiAgICAgKi9cbiAgICBnZXQgaXNSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbF9faXNSZWFkeVByb21pc2U7XG4gICAgfVxuICAgIGdldCBlbmRwb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbF9fZW5kcG9pbnRzW3RoaXMuX19pbnRlcm5hbF9fZW5kcG9pbnRJbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFdzUHJvdmlkZXIodGhpcy5fX2ludGVybmFsX19lbmRwb2ludHMpO1xuICAgIH1cbiAgICBzZWxlY3RFbmRwb2ludEluZGV4KGVuZHBvaW50cykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX19pbnRlcm5hbF9fZW5kcG9pbnRJbmRleCArIDEpICUgZW5kcG9pbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTWFudWFsbHkgY29ubmVjdFxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgW1tXc1Byb3ZpZGVyXV0gY29ubmVjdHMgYXV0b21hdGljYWxseSBieSBkZWZhdWx0LCBob3dldmVyIGlmIHlvdSBkZWNpZGVkIG90aGVyd2lzZSwgeW91IG1heVxuICAgICAqIGNvbm5lY3QgbWFudWFsbHkgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX19pbnRlcm5hbF9fd2Vic29ja2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBhbHJlYWR5IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50SW5kZXggPSB0aGlzLnNlbGVjdEVuZHBvaW50SW5kZXgodGhpcy5fX2ludGVybmFsX19lbmRwb2ludHMpO1xuICAgICAgICAgICAgLy8gdGhlIGFzIGhlcmUgaXMgRGVuby1zcGVjaWZpYyAtIG5vdCBhdmFpbGFibGUgb24gdGhlIGdsb2JhbFRoaXNcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fd2Vic29ja2V0ID0gdHlwZW9mIHhnbG9iYWwuV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc0NoaWxkQ2xhc3MoeGdsb2JhbC5XZWJTb2NrZXQsIFdlYlNvY2tldClcbiAgICAgICAgICAgICAgICA/IG5ldyBXZWJTb2NrZXQodGhpcy5lbmRwb2ludClcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIFdTIG1heSBiZSBhbiBpbnN0YW5jZSBvZiB3cywgd2hpY2ggc3VwcG9ydHMgb3B0aW9uc1xuICAgICAgICAgICAgICAgIDogbmV3IFdlYlNvY2tldCh0aGlzLmVuZHBvaW50LCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5fX2ludGVybmFsX19oZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fX2ludGVybmFsX193ZWJzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3dlYnNvY2tldC5vbmNsb3NlID0gdGhpcy5fX2ludGVybmFsX19vblNvY2tldENsb3NlO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fd2Vic29ja2V0Lm9uZXJyb3IgPSB0aGlzLl9faW50ZXJuYWxfX29uU29ja2V0RXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX193ZWJzb2NrZXQub25tZXNzYWdlID0gdGhpcy5fX2ludGVybmFsX19vblNvY2tldE1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX193ZWJzb2NrZXQub25vcGVuID0gdGhpcy5fX2ludGVybmFsX19vblNvY2tldE9wZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aW1lb3V0IGFueSBoYW5kbGVycyB0aGF0IGhhdmUgbm90IGhhZCBhIHJlc3BvbnNlXG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3RpbWVvdXRJZCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX19pbnRlcm5hbF9fdGltZW91dEhhbmRsZXJzKCksIFRJTUVPVVRfSU5URVJWQUwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbC5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIENvbm5lY3QsIG5ldmVyIHRocm93aW5nIGFuIGVycm9yLCBidXQgcmF0aGVyIGZvcmNpbmcgYSByZXRyeVxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3RXaXRoUmV0cnkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9faW50ZXJuYWxfX2F1dG9Db25uZWN0TXMgPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RXaXRoUmV0cnkoKS5jYXRjaChub29wKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLl9faW50ZXJuYWxfX2F1dG9Db25uZWN0TXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBNYW51YWxseSBkaXNjb25uZWN0IGZyb20gdGhlIGNvbm5lY3Rpb24sIGNsZWFyaW5nIGF1dG8tY29ubmVjdCBsb2dpY1xuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxuICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIC8vIHN3aXRjaCBvZmYgYXV0b0Nvbm5lY3QsIHdlIGFyZSBpbiBtYW51YWwgbW9kZSBub3dcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19hdXRvQ29ubmVjdE1zID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9faW50ZXJuYWxfX3dlYnNvY2tldCkge1xuICAgICAgICAgICAgICAgIC8vIDEwMDAgLSBOb3JtYWwgY2xvc3VyZTsgdGhlIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxuICAgICAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fd2Vic29ja2V0LmNsb3NlKDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbC5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGNvbm5lY3Rpb24gc3RhdHNcbiAgICAgKi9cbiAgICBnZXQgc3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0czogT2JqZWN0LmtleXModGhpcy5fX2ludGVybmFsX19oYW5kbGVycykubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnM6IE9iamVjdC5rZXlzKHRoaXMuX19pbnRlcm5hbF9fc3Vic2NyaXB0aW9ucykubGVuZ3RoXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG90YWw6IHRoaXMuX19pbnRlcm5hbF9fc3RhdHMudG90YWxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGVuZHBvaW50U3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50U3RhdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IExpc3RlbnMgb24gZXZlbnRzIGFmdGVyIGhhdmluZyBzdWJzY3JpYmVkIHVzaW5nIHRoZSBbW3N1YnNjcmliZV1dIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSAge1Byb3ZpZGVySW50ZXJmYWNlRW1pdHRlZH0gdHlwZSBFdmVudFxuICAgICAqIEBwYXJhbSAge1Byb3ZpZGVySW50ZXJmYWNlRW1pdENifSAgc3ViICBDYWxsYmFja1xuICAgICAqIEByZXR1cm4gdW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbih0eXBlLCBzdWIpIHtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19ldmVudGVtaXR0ZXIub24odHlwZSwgc3ViKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fZXZlbnRlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKHR5cGUsIHN1Yik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNlbmQgSlNPTiBkYXRhIHVzaW5nIFdlYlNvY2tldHMgdG8gY29uZmlndXJlZCBIVFRQIEVuZHBvaW50IG9yIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIFJQQyBtZXRob2RzIHRvIGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0gcGFyYW1zIEVuY29kZWQgcGFyYW1ldGVycyBhcyBhcHBsaWNhYmxlIGZvciB0aGUgbWV0aG9kXG4gICAgICogQHBhcmFtIHN1YnNjcmlwdGlvbiBTdWJzY3JpcHRpb24gZGV0YWlscyAoaW50ZXJuYWxseSB1c2VkKVxuICAgICAqL1xuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMsIGlzQ2FjaGVhYmxlLCBzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgdGhpcy5fX2ludGVybmFsX19lbmRwb2ludFN0YXRzLnJlcXVlc3RzKys7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fc3RhdHMudG90YWwucmVxdWVzdHMrKztcbiAgICAgICAgY29uc3QgW2lkLCBib2R5XSA9IHRoaXMuX19pbnRlcm5hbF9fY29kZXIuZW5jb2RlSnNvbihtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIGlmICh0aGlzLl9faW50ZXJuYWxfX2NhY2hlQ2FwYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWxfX3NlbmQoaWQsIGJvZHksIG1ldGhvZCwgcGFyYW1zLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gaXNDYWNoZWFibGUgPyBgJHttZXRob2R9Ojoke3N0cmluZ2lmeShwYXJhbXMpfWAgOiAnJztcbiAgICAgICAgbGV0IHJlc3VsdFByb21pc2UgPSBpc0NhY2hlYWJsZVxuICAgICAgICAgICAgPyB0aGlzLl9faW50ZXJuYWxfX2NhbGxDYWNoZS5nZXQoY2FjaGVLZXkpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICghcmVzdWx0UHJvbWlzZSkge1xuICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IHRoaXMuX19pbnRlcm5hbF9fc2VuZChpZCwgYm9keSwgbWV0aG9kLCBwYXJhbXMsIHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBpZiAoaXNDYWNoZWFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2NhbGxDYWNoZS5zZXQoY2FjaGVLZXksIHJlc3VsdFByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19lbmRwb2ludFN0YXRzLmNhY2hlZCsrO1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19zdGF0cy50b3RhbC5jYWNoZWQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgX19pbnRlcm5hbF9fc2VuZChpZCwgYm9keSwgbWV0aG9kLCBwYXJhbXMsIHN1YnNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQgfHwgdGhpcy5fX2ludGVybmFsX193ZWJzb2NrZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlamVjdChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbC5kZWJ1ZygoKSA9PiBbJ2NhbGxpbmcnLCBtZXRob2QsIGJvZHldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2hhbmRsZXJzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlc1NlbnQgPSBib2R5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50U3RhdHMuYnl0ZXNTZW50ICs9IGJ5dGVzU2VudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N0YXRzLnRvdGFsLmJ5dGVzU2VudCArPSBieXRlc1NlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX193ZWJzb2NrZXQuc2VuZChib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fZW5kcG9pbnRTdGF0cy5lcnJvcnMrKztcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N0YXRzLnRvdGFsLmVycm9ycysrO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzdWJzY3JpYmVcbiAgICAgKiBAc3VtbWFyeSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gYSBzcGVjaWZpYyBldmVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogPEJSPlxuICAgICAqXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IFdzUHJvdmlkZXIoJ3dzOi8vMTI3LjAuMC4xOjk5NDQnKTtcbiAgICAgKiBjb25zdCBycGMgPSBuZXcgUnBjKHByb3ZpZGVyKTtcbiAgICAgKlxuICAgICAqIHJwYy5zdGF0ZS5zdWJzY3JpYmVTdG9yYWdlKFtbc3RvcmFnZS5zeXN0ZW0uYWNjb3VudCwgPEFkZHJlc3M+XV0sIChfLCB2YWx1ZXMpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlcylcbiAgICAgKiB9KS50aGVuKChzdWJzY3JpcHRpb25JZCkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ2JhbGFuY2UgY2hhbmdlcyBzdWJzY3JpcHRpb24gaWQ6ICcsIHN1YnNjcmlwdGlvbklkKVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3Vic2NyaWJlKHR5cGUsIG1ldGhvZCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50U3RhdHMuc3Vic2NyaXB0aW9ucysrO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N0YXRzLnRvdGFsLnN1YnNjcmlwdGlvbnMrKztcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9ucyBhcmUgbm90IGNhY2hlZCwgTFJVIGFwcGxpZXMgdG8gLmF0KDxibG9ja0hhc2g+KSBvbmx5XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQobWV0aG9kLCBwYXJhbXMsIGZhbHNlLCB7IGNhbGxiYWNrLCB0eXBlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBbGxvd3MgdW5zdWJzY3JpYmluZyB0byBzdWJzY3JpcHRpb25zIG1hZGUgd2l0aCBbW3N1YnNjcmliZV1dLlxuICAgICAqL1xuICAgIGFzeW5jIHVuc3Vic2NyaWJlKHR5cGUsIG1ldGhvZCwgaWQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYCR7dHlwZX06OiR7aWR9YDtcbiAgICAgICAgLy8gRklYTUUgVGhpcyBub3cgY291bGQgaGFwcGVuIHdpdGggcmUtc3Vic2NyaXB0aW9ucy4gVGhlIGlzc3VlIGlzIHRoYXQgd2l0aCBhIHJlLXN1YlxuICAgICAgICAvLyB0aGUgYXNzaWduZWQgaWQgbm93IGRvZXMgbm90IG1hdGNoIHdoYXQgdGhlIEFQSSB1c2VyIG9yaWdpbmFsbHkgcmVjZWl2ZWQuIEl0IGhhc1xuICAgICAgICAvLyBhIHNsaWdodCBjb21wbGljYXRpb24gaW4gc29sdmluZyAtIHNpbmNlIHdlIGNhbm5vdCByZWx5IG9uIHRoZSBzZW5kIGlkLCBidXQgcmF0aGVyXG4gICAgICAgIC8vIG5lZWQgdG8gZmluZCB0aGUgYWN0dWFsIHN1YnNjcmlwdGlvbiBpZCB0byBtYXAgaXRcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuX19pbnRlcm5hbF9fc3Vic2NyaXB0aW9uc1tzdWJzY3JpcHRpb25dKSkge1xuICAgICAgICAgICAgbC5kZWJ1ZygoKSA9PiBgVW5hYmxlIHRvIGZpbmQgYWN0aXZlIHN1YnNjcmlwdGlvbj0ke3N1YnNjcmlwdGlvbn1gKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fX2ludGVybmFsX19zdWJzY3JpcHRpb25zW3N1YnNjcmlwdGlvbl07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Nvbm5lY3RlZCAmJiAhaXNOdWxsKHRoaXMuX19pbnRlcm5hbF9fd2Vic29ja2V0KVxuICAgICAgICAgICAgICAgID8gdGhpcy5zZW5kKG1ldGhvZCwgW2lkXSlcbiAgICAgICAgICAgICAgICA6IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9faW50ZXJuYWxfX2VtaXQgPSAodHlwZSwgLi4uYXJncykgPT4ge1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2V2ZW50ZW1pdHRlci5lbWl0KHR5cGUsIC4uLmFyZ3MpO1xuICAgIH07XG4gICAgX19pbnRlcm5hbF9fb25Tb2NrZXRDbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZGlzY29ubmVjdGVkIGZyb20gJHt0aGlzLmVuZHBvaW50fTogJHtldmVudC5jb2RlfTo6ICR7ZXZlbnQucmVhc29uIHx8IGdldFdTRXJyb3JTdHJpbmcoZXZlbnQuY29kZSl9YCk7XG4gICAgICAgIGlmICh0aGlzLl9faW50ZXJuYWxfX2F1dG9Db25uZWN0TXMgPiAwKSB7XG4gICAgICAgICAgICBsLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9faXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX19pbnRlcm5hbF9fd2Vic29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3dlYnNvY2tldC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fd2Vic29ja2V0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX193ZWJzb2NrZXQub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fd2Vic29ja2V0Lm9ub3BlbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3dlYnNvY2tldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX19pbnRlcm5hbF9fdGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX19pbnRlcm5hbF9fdGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fdGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWplY3QgYWxsIGhhbmdpbmcgcmVxdWVzdHNcbiAgICAgICAgZXJhc2VSZWNvcmQodGhpcy5fX2ludGVybmFsX19oYW5kbGVycywgKGgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaC5jYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvd1xuICAgICAgICAgICAgICAgIGwuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVyYXNlUmVjb3JkKHRoaXMuX19pbnRlcm5hbF9fd2FpdGluZ0ZvcklkKTtcbiAgICAgICAgLy8gUmVzZXQgc3RhdHMgZm9yIGFjdGl2ZSBlbmRwb2ludFxuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50U3RhdHMgPSBkZWZhdWx0RW5kcG9pbnRTdGF0cygpO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VtaXQoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICBpZiAodGhpcy5fX2ludGVybmFsX19hdXRvQ29ubmVjdE1zID4gMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0V2l0aFJldHJ5KCkuY2F0Y2gobm9vcCk7XG4gICAgICAgICAgICB9LCB0aGlzLl9faW50ZXJuYWxfX2F1dG9Db25uZWN0TXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2ludGVybmFsX19vblNvY2tldEVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIGwuZGVidWcoKCkgPT4gWydzb2NrZXQgZXJyb3InLCBlcnJvcl0pO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH07XG4gICAgX19pbnRlcm5hbF9fb25Tb2NrZXRNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgbC5kZWJ1ZygoKSA9PiBbJ3JlY2VpdmVkJywgbWVzc2FnZS5kYXRhXSk7XG4gICAgICAgIGNvbnN0IGJ5dGVzUmVjdiA9IG1lc3NhZ2UuZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fZW5kcG9pbnRTdGF0cy5ieXRlc1JlY3YgKz0gYnl0ZXNSZWN2O1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N0YXRzLnRvdGFsLmJ5dGVzUmVjdiArPSBieXRlc1JlY3Y7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQocmVzcG9uc2UubWV0aG9kKVxuICAgICAgICAgICAgPyB0aGlzLl9faW50ZXJuYWxfX29uU29ja2V0TWVzc2FnZVJlc3VsdChyZXNwb25zZSlcbiAgICAgICAgICAgIDogdGhpcy5fX2ludGVybmFsX19vblNvY2tldE1lc3NhZ2VTdWJzY3JpYmUocmVzcG9uc2UpO1xuICAgIH07XG4gICAgX19pbnRlcm5hbF9fb25Tb2NrZXRNZXNzYWdlUmVzdWx0ID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9faW50ZXJuYWxfX2hhbmRsZXJzW3Jlc3BvbnNlLmlkXTtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICBsLmRlYnVnKCgpID0+IGBVbmFibGUgdG8gZmluZCBoYW5kbGVyIGZvciBpZD0ke3Jlc3BvbnNlLmlkfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zLCBzdWJzY3JpcHRpb24gfSA9IGhhbmRsZXI7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9faW50ZXJuYWxfX2NvZGVyLmRlY29kZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vIGZpcnN0IHNlbmQgdGhlIHJlc3VsdCAtIGluIGNhc2Ugb2Ygc3Vicywgd2UgbWF5IGhhdmUgYW4gdXBkYXRlXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBpZiB3ZSBoYXZlIHNvbWUgcXVldWVkIHJlc3VsdHMgYWxyZWFkeVxuICAgICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YklkID0gYCR7c3Vic2NyaXB0aW9uLnR5cGV9Ojoke3Jlc3VsdH1gO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fc3Vic2NyaXB0aW9uc1tzdWJJZF0gPSBvYmplY3RTcHJlYWQoe30sIHN1YnNjcmlwdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSByZXN1bHQgd2FpdGluZyBmb3IgdGhpcyBzdWJzY3JpcHRpb24gYWxyZWFkeVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faW50ZXJuYWxfX3dhaXRpbmdGb3JJZFtzdWJJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2ludGVybmFsX19vblNvY2tldE1lc3NhZ2VTdWJzY3JpYmUodGhpcy5fX2ludGVybmFsX193YWl0aW5nRm9ySWRbc3ViSWRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50U3RhdHMuZXJyb3JzKys7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N0YXRzLnRvdGFsLmVycm9ycysrO1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fX2ludGVybmFsX19oYW5kbGVyc1tyZXNwb25zZS5pZF07XG4gICAgfTtcbiAgICBfX2ludGVybmFsX19vblNvY2tldE1lc3NhZ2VTdWJzY3JpYmUgPSAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5tZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIGZvdW5kIGluIEpTT05SUEMgcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSBBTElBU0VTW3Jlc3BvbnNlLm1ldGhvZF0gfHwgcmVzcG9uc2UubWV0aG9kO1xuICAgICAgICBjb25zdCBzdWJJZCA9IGAke21ldGhvZH06OiR7cmVzcG9uc2UucGFyYW1zLnN1YnNjcmlwdGlvbn1gO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fX2ludGVybmFsX19zdWJzY3JpcHRpb25zW3N1YklkXTtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgSlNPTiwgd2UgY291bGQgaGF2ZSBvdXQtb2Ytb3JkZXIgc3ViaWQgY29taW5nIGluXG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3dhaXRpbmdGb3JJZFtzdWJJZF0gPSByZXNwb25zZTtcbiAgICAgICAgICAgIGwuZGVidWcoKCkgPT4gYFVuYWJsZSB0byBmaW5kIGhhbmRsZXIgZm9yIHN1YnNjcmlwdGlvbj0ke3N1YklkfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhvdXNla2VlcGluZ1xuICAgICAgICBkZWxldGUgdGhpcy5fX2ludGVybmFsX193YWl0aW5nRm9ySWRbc3ViSWRdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fX2ludGVybmFsX19jb2Rlci5kZWNvZGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50U3RhdHMuZXJyb3JzKys7XG4gICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3N0YXRzLnRvdGFsLmVycm9ycysrO1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19pbnRlcm5hbF9fb25Tb2NrZXRPcGVuID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fX2ludGVybmFsX193ZWJzb2NrZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGNhbm5vdCBiZSBudWxsIGluIG9uT3BlbicpO1xuICAgICAgICB9XG4gICAgICAgIGwuZGVidWcoKCkgPT4gWydjb25uZWN0ZWQgdG8nLCB0aGlzLmVuZHBvaW50XSk7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9faXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9faW50ZXJuYWxfX3Jlc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fZW1pdCgnY29ubmVjdGVkJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX19pbnRlcm5hbF9fcmVzdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9faW50ZXJuYWxfX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIHRoaXMuX19pbnRlcm5hbF9fc3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgICAgICBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhzdWJzY3JpcHRpb25zKS5tYXAoYXN5bmMgKGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNhbGxiYWNrLCBtZXRob2QsIHBhcmFtcywgdHlwZSB9ID0gc3Vic2NyaXB0aW9uc1tpZF07XG4gICAgICAgICAgICAvLyBvbmx5IHJlLWNyZWF0ZSBzdWJzY3JpcHRpb25zIHdoaWNoIGFyZSBub3QgaW4gYXV0aG9yIChvbmx5IGFyZWEgd2hlcmVcbiAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9ucyBhcmUgY3JlYXRlZCwgaS5lLiBzdWJtaXNzaW9ucyBzdWNoIGFzICdhdXRob3Jfc3VibWl0QW5kV2F0Y2hFeHRyaW5zaWMnXG4gICAgICAgICAgICAvLyBhcmUgbm90IGluY2x1ZGVkIChhbmQgd2lsbCBub3QgYmUgcmUtYnJvYWRjYXN0KVxuICAgICAgICAgICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYXV0aG9yXycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN1YnNjcmliZSh0eXBlLCBtZXRob2QsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbC5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKS5jYXRjaChsLmVycm9yKTtcbiAgICB9O1xuICAgIF9faW50ZXJuYWxfX3RpbWVvdXRIYW5kbGVycyA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgaWRzID0gT2JqZWN0LmtleXModGhpcy5fX2ludGVybmFsX19oYW5kbGVycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb3VudCA9IGlkcy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fX2ludGVybmFsX19oYW5kbGVyc1tpZHNbaV1dO1xuICAgICAgICAgICAgaWYgKChub3cgLSBoYW5kbGVyLnN0YXJ0KSA+IHRoaXMuX19pbnRlcm5hbF9fdGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbGJhY2sobmV3IEVycm9yKGBObyByZXNwb25zZSByZWNlaXZlZCBmcm9tIFJQQyBlbmRwb2ludCBpbiAke3RoaXMuX19pbnRlcm5hbF9fdGltZW91dCAvIDEwMDB9c2ApLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJuYWxfX2VuZHBvaW50U3RhdHMudGltZW91dCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnRlcm5hbF9fc3RhdHMudG90YWwudGltZW91dCsrO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9faW50ZXJuYWxfX2hhbmRsZXJzW2lkc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@polkadot+rpc-provider@14.3.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@polkadot/rpc-provider/ws/index.js\n");

/***/ })

};
;