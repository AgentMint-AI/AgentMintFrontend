"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cosmjs-types@0.9.0";
exports.ids = ["vendor-chunks/cosmjs-types@0.9.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* eslint-disable */\n/**\n * This file and any referenced files were automatically generated by @cosmology/telescope@1.0.7\n * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain\n * and run the transpile command or yarn proto command to regenerate this bundle.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BinaryWriter = exports.BinaryReader = exports.WireType = void 0;\n// Copyright (c) 2016, Daniel Wirtz  All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// * Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n// * Neither the name of its author, nor the names of its contributors\n//   may be used to endorse or promote products derived from this software\n//   without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// ---\n// Code generated by the command line utilities is owned by the owner\n// of the input file used when generating it. This code is not\n// standalone and requires a support library to be linked with it. This\n// support library is itself covered by the above license.\nconst utf8_1 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/utf8.js\");\nconst varint_1 = __webpack_require__(/*! ./varint */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/varint.js\");\nvar WireType;\n(function (WireType) {\n    WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    WireType[WireType[\"Fixed64\"] = 1] = \"Fixed64\";\n    WireType[WireType[\"Bytes\"] = 2] = \"Bytes\";\n    WireType[WireType[\"Fixed32\"] = 5] = \"Fixed32\";\n})(WireType || (exports.WireType = WireType = {}));\nclass BinaryReader {\n    assertBounds() {\n        if (this.pos > this.len)\n            throw new RangeError(\"premature EOF\");\n    }\n    constructor(buf) {\n        this.buf = buf ? new Uint8Array(buf) : new Uint8Array(0);\n        this.pos = 0;\n        this.type = 0;\n        this.len = this.buf.length;\n    }\n    tag() {\n        const tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5)\n            throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [fieldNo, wireType, tag];\n    }\n    skip(length) {\n        if (typeof length === \"number\") {\n            if (this.pos + length > this.len)\n                throw indexOutOfRange(this, length);\n            this.pos += length;\n        }\n        else {\n            do {\n                if (this.pos >= this.len)\n                    throw indexOutOfRange(this);\n            } while (this.buf[this.pos++] & 128);\n        }\n        return this;\n    }\n    skipType(wireType) {\n        switch (wireType) {\n            case WireType.Varint:\n                this.skip();\n                break;\n            case WireType.Fixed64:\n                this.skip(8);\n                break;\n            case WireType.Bytes:\n                this.skip(this.uint32());\n                break;\n            case 3:\n                while ((wireType = this.uint32() & 7) !== 4) {\n                    this.skipType(wireType);\n                }\n                break;\n            case WireType.Fixed32:\n                this.skip(4);\n                break;\n            /* istanbul ignore next */\n            default:\n                throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n        }\n        return this;\n    }\n    uint32() {\n        return varint_1.varint32read.bind(this)();\n    }\n    int32() {\n        return this.uint32() | 0;\n    }\n    sint32() {\n        const num = this.uint32();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    }\n    fixed32() {\n        const val = (0, varint_1.readUInt32)(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    }\n    sfixed32() {\n        const val = (0, varint_1.readInt32)(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    }\n    int64() {\n        const [lo, hi] = varint_1.varint64read.bind(this)();\n        return BigInt((0, varint_1.int64ToString)(lo, hi));\n    }\n    uint64() {\n        const [lo, hi] = varint_1.varint64read.bind(this)();\n        return BigInt((0, varint_1.uInt64ToString)(lo, hi));\n    }\n    sint64() {\n        let [lo, hi] = varint_1.varint64read.bind(this)();\n        // zig zag\n        [lo, hi] = (0, varint_1.zzDecode)(lo, hi);\n        return BigInt((0, varint_1.int64ToString)(lo, hi));\n    }\n    fixed64() {\n        const lo = this.sfixed32();\n        const hi = this.sfixed32();\n        return BigInt((0, varint_1.uInt64ToString)(lo, hi));\n    }\n    sfixed64() {\n        const lo = this.sfixed32();\n        const hi = this.sfixed32();\n        return BigInt((0, varint_1.int64ToString)(lo, hi));\n    }\n    float() {\n        throw new Error(\"float not supported\");\n    }\n    double() {\n        throw new Error(\"double not supported\");\n    }\n    bool() {\n        const [lo, hi] = varint_1.varint64read.bind(this)();\n        return lo !== 0 || hi !== 0;\n    }\n    bytes() {\n        const len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    string() {\n        const bytes = this.bytes();\n        return (0, utf8_1.utf8Read)(bytes, 0, bytes.length);\n    }\n}\nexports.BinaryReader = BinaryReader;\nclass Op {\n    constructor(fn, len, val) {\n        this.fn = fn;\n        this.len = len;\n        this.val = val;\n    }\n    proceed(buf, pos) {\n        if (this.fn) {\n            this.fn(this.val, buf, pos);\n        }\n    }\n}\nclass State {\n    constructor(writer) {\n        this.head = writer.head;\n        this.tail = writer.tail;\n        this.len = writer.len;\n        this.next = writer.states;\n    }\n}\nclass BinaryWriter {\n    constructor() {\n        this.len = 0;\n        // uint64 is the same with int64\n        this.uint64 = BinaryWriter.prototype.int64;\n        // sfixed64 is the same with fixed64\n        this.sfixed64 = BinaryWriter.prototype.fixed64;\n        // sfixed32 is the same with fixed32\n        this.sfixed32 = BinaryWriter.prototype.fixed32;\n        this.head = new Op(null, 0, 0);\n        this.tail = this.head;\n        this.states = null;\n    }\n    static create() {\n        return new BinaryWriter();\n    }\n    static alloc(size) {\n        if (typeof Uint8Array !== \"undefined\") {\n            return pool((size) => new Uint8Array(size), Uint8Array.prototype.subarray)(size);\n        }\n        else {\n            return new Array(size);\n        }\n    }\n    _push(fn, len, val) {\n        this.tail = this.tail.next = new Op(fn, len, val);\n        this.len += len;\n        return this;\n    }\n    finish() {\n        let head = this.head.next, pos = 0;\n        const buf = BinaryWriter.alloc(this.len);\n        while (head) {\n            head.proceed(buf, pos);\n            pos += head.len;\n            head = head.next;\n        }\n        return buf;\n    }\n    fork() {\n        this.states = new State(this);\n        this.head = this.tail = new Op(null, 0, 0);\n        this.len = 0;\n        return this;\n    }\n    reset() {\n        if (this.states) {\n            this.head = this.states.head;\n            this.tail = this.states.tail;\n            this.len = this.states.len;\n            this.states = this.states.next;\n        }\n        else {\n            this.head = this.tail = new Op(null, 0, 0);\n            this.len = 0;\n        }\n        return this;\n    }\n    ldelim() {\n        const head = this.head, tail = this.tail, len = this.len;\n        this.reset().uint32(len);\n        if (len) {\n            this.tail.next = head.next; // skip noop\n            this.tail = tail;\n            this.len += len;\n        }\n        return this;\n    }\n    tag(fieldNo, type) {\n        return this.uint32(((fieldNo << 3) | type) >>> 0);\n    }\n    uint32(value) {\n        this.len += (this.tail = this.tail.next =\n            new Op(varint_1.writeVarint32, (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n        return this;\n    }\n    int32(value) {\n        return value < 0\n            ? this._push(varint_1.writeVarint64, 10, (0, varint_1.int64FromString)(value.toString())) // 10 bytes per spec\n            : this.uint32(value);\n    }\n    sint32(value) {\n        return this.uint32(((value << 1) ^ (value >> 31)) >>> 0);\n    }\n    int64(value) {\n        const { lo, hi } = (0, varint_1.int64FromString)(value.toString());\n        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo, hi), { lo, hi });\n    }\n    sint64(value) {\n        let { lo, hi } = (0, varint_1.int64FromString)(value.toString());\n        // zig zag\n        [lo, hi] = (0, varint_1.zzEncode)(lo, hi);\n        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo, hi), { lo, hi });\n    }\n    fixed64(value) {\n        const { lo, hi } = (0, varint_1.int64FromString)(value.toString());\n        return this._push(varint_1.writeFixed32, 4, lo)._push(varint_1.writeFixed32, 4, hi);\n    }\n    bool(value) {\n        return this._push(varint_1.writeByte, 1, value ? 1 : 0);\n    }\n    fixed32(value) {\n        return this._push(varint_1.writeFixed32, 4, value >>> 0);\n    }\n    float(value) {\n        throw new Error(\"float not supported\" + value);\n    }\n    double(value) {\n        throw new Error(\"double not supported\" + value);\n    }\n    bytes(value) {\n        const len = value.length >>> 0;\n        if (!len)\n            return this._push(varint_1.writeByte, 1, 0);\n        return this.uint32(len)._push(writeBytes, len, value);\n    }\n    string(value) {\n        const len = (0, utf8_1.utf8Length)(value);\n        return len ? this.uint32(len)._push(utf8_1.utf8Write, len, value) : this._push(varint_1.writeByte, 1, 0);\n    }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction writeBytes(val, buf, pos) {\n    if (typeof Uint8Array !== \"undefined\") {\n        buf.set(val, pos);\n    }\n    else {\n        for (let i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    }\n}\nfunction pool(alloc, slice, size) {\n    const SIZE = size || 8192;\n    const MAX = SIZE >>> 1;\n    let slab = null;\n    let offset = SIZE;\n    return function pool_alloc(size) {\n        if (size < 1 || size > MAX)\n            return alloc(size);\n        if (offset + size > SIZE) {\n            slab = alloc(SIZE);\n            offset = 0;\n        }\n        const buf = slice.call(slab, offset, (offset += size));\n        if (offset & 7)\n            // align to 32 bit\n            offset = (offset | 7) + 1;\n        return buf;\n    };\n}\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n//# sourceMappingURL=binary.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvYmluYXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsK0ZBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsbUdBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxlQUFlLGdCQUFnQixnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsdUZBQXVGLFFBQVE7QUFDL0Y7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsdUZBQXVGLFFBQVE7QUFDL0Y7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL2Nvc21qcy10eXBlc0AwLjkuMC9ub2RlX21vZHVsZXMvY29zbWpzLXR5cGVzL2JpbmFyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFRoaXMgZmlsZSBhbmQgYW55IHJlZmVyZW5jZWQgZmlsZXMgd2VyZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBAY29zbW9sb2d5L3RlbGVzY29wZUAxLjAuN1xuICogRE8gTk9UIE1PRElGWSBCWSBIQU5ELiBJbnN0ZWFkLCBkb3dubG9hZCB0aGUgbGF0ZXN0IHByb3RvIGZpbGVzIGZvciB5b3VyIGNoYWluXG4gKiBhbmQgcnVuIHRoZSB0cmFuc3BpbGUgY29tbWFuZCBvciB5YXJuIHByb3RvIGNvbW1hbmQgdG8gcmVnZW5lcmF0ZSB0aGlzIGJ1bmRsZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaW5hcnlXcml0ZXIgPSBleHBvcnRzLkJpbmFyeVJlYWRlciA9IGV4cG9ydHMuV2lyZVR5cGUgPSB2b2lkIDA7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYsIERhbmllbCBXaXJ0eiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBpdHMgYXV0aG9yLCBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbi8vICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4vLyAgIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy8gLS0tXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgY29tbWFuZCBsaW5lIHV0aWxpdGllcyBpcyBvd25lZCBieSB0aGUgb3duZXJcbi8vIG9mIHRoZSBpbnB1dCBmaWxlIHVzZWQgd2hlbiBnZW5lcmF0aW5nIGl0LiBUaGlzIGNvZGUgaXMgbm90XG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gVGhpc1xuLy8gc3VwcG9ydCBsaWJyYXJ5IGlzIGl0c2VsZiBjb3ZlcmVkIGJ5IHRoZSBhYm92ZSBsaWNlbnNlLlxuY29uc3QgdXRmOF8xID0gcmVxdWlyZShcIi4vdXRmOFwiKTtcbmNvbnN0IHZhcmludF8xID0gcmVxdWlyZShcIi4vdmFyaW50XCIpO1xudmFyIFdpcmVUeXBlO1xuKGZ1bmN0aW9uIChXaXJlVHlwZSkge1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiVmFyaW50XCJdID0gMF0gPSBcIlZhcmludFwiO1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiRml4ZWQ2NFwiXSA9IDFdID0gXCJGaXhlZDY0XCI7XG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCeXRlc1wiXSA9IDJdID0gXCJCeXRlc1wiO1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiRml4ZWQzMlwiXSA9IDVdID0gXCJGaXhlZDMyXCI7XG59KShXaXJlVHlwZSB8fCAoZXhwb3J0cy5XaXJlVHlwZSA9IFdpcmVUeXBlID0ge30pKTtcbmNsYXNzIEJpbmFyeVJlYWRlciB7XG4gICAgYXNzZXJ0Qm91bmRzKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwicHJlbWF0dXJlIEVPRlwiKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYnVmKSB7XG4gICAgICAgIHRoaXMuYnVmID0gYnVmID8gbmV3IFVpbnQ4QXJyYXkoYnVmKSA6IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMudHlwZSA9IDA7XG4gICAgICAgIHRoaXMubGVuID0gdGhpcy5idWYubGVuZ3RoO1xuICAgIH1cbiAgICB0YWcoKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRoaXMudWludDMyKCksIGZpZWxkTm8gPSB0YWcgPj4+IDMsIHdpcmVUeXBlID0gdGFnICYgNztcbiAgICAgICAgaWYgKGZpZWxkTm8gPD0gMCB8fCB3aXJlVHlwZSA8IDAgfHwgd2lyZVR5cGUgPiA1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0YWc6IGZpZWxkIG5vIFwiICsgZmllbGRObyArIFwiIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcbiAgICAgICAgcmV0dXJuIFtmaWVsZE5vLCB3aXJlVHlwZSwgdGFnXTtcbiAgICB9XG4gICAgc2tpcChsZW5ndGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBza2lwVHlwZSh3aXJlVHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLlZhcmludDpcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuRml4ZWQ2NDpcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAoOCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkJ5dGVzOlxuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuRml4ZWQzMjpcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAoNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVpbnQzMigpIHtcbiAgICAgICAgcmV0dXJuIHZhcmludF8xLnZhcmludDMycmVhZC5iaW5kKHRoaXMpKCk7XG4gICAgfVxuICAgIGludDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG4gICAgfVxuICAgIHNpbnQzMigpIHtcbiAgICAgICAgY29uc3QgbnVtID0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH1cbiAgICBmaXhlZDMyKCkge1xuICAgICAgICBjb25zdCB2YWwgPSAoMCwgdmFyaW50XzEucmVhZFVJbnQzMikodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgc2ZpeGVkMzIoKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9ICgwLCB2YXJpbnRfMS5yZWFkSW50MzIpKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGludDY0KCkge1xuICAgICAgICBjb25zdCBbbG8sIGhpXSA9IHZhcmludF8xLnZhcmludDY0cmVhZC5iaW5kKHRoaXMpKCk7XG4gICAgICAgIHJldHVybiBCaWdJbnQoKDAsIHZhcmludF8xLmludDY0VG9TdHJpbmcpKGxvLCBoaSkpO1xuICAgIH1cbiAgICB1aW50NjQoKSB7XG4gICAgICAgIGNvbnN0IFtsbywgaGldID0gdmFyaW50XzEudmFyaW50NjRyZWFkLmJpbmQodGhpcykoKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCgoMCwgdmFyaW50XzEudUludDY0VG9TdHJpbmcpKGxvLCBoaSkpO1xuICAgIH1cbiAgICBzaW50NjQoKSB7XG4gICAgICAgIGxldCBbbG8sIGhpXSA9IHZhcmludF8xLnZhcmludDY0cmVhZC5iaW5kKHRoaXMpKCk7XG4gICAgICAgIC8vIHppZyB6YWdcbiAgICAgICAgW2xvLCBoaV0gPSAoMCwgdmFyaW50XzEuenpEZWNvZGUpKGxvLCBoaSk7XG4gICAgICAgIHJldHVybiBCaWdJbnQoKDAsIHZhcmludF8xLmludDY0VG9TdHJpbmcpKGxvLCBoaSkpO1xuICAgIH1cbiAgICBmaXhlZDY0KCkge1xuICAgICAgICBjb25zdCBsbyA9IHRoaXMuc2ZpeGVkMzIoKTtcbiAgICAgICAgY29uc3QgaGkgPSB0aGlzLnNmaXhlZDMyKCk7XG4gICAgICAgIHJldHVybiBCaWdJbnQoKDAsIHZhcmludF8xLnVJbnQ2NFRvU3RyaW5nKShsbywgaGkpKTtcbiAgICB9XG4gICAgc2ZpeGVkNjQoKSB7XG4gICAgICAgIGNvbnN0IGxvID0gdGhpcy5zZml4ZWQzMigpO1xuICAgICAgICBjb25zdCBoaSA9IHRoaXMuc2ZpeGVkMzIoKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCgoMCwgdmFyaW50XzEuaW50NjRUb1N0cmluZykobG8sIGhpKSk7XG4gICAgfVxuICAgIGZsb2F0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmbG9hdCBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImRvdWJsZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBib29sKCkge1xuICAgICAgICBjb25zdCBbbG8sIGhpXSA9IHZhcmludF8xLnZhcmludDY0cmVhZC5iaW5kKHRoaXMpKCk7XG4gICAgICAgIHJldHVybiBsbyAhPT0gMCB8fCBoaSAhPT0gMDtcbiAgICB9XG4gICAgYnl0ZXMoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMudWludDMyKCksIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbik7XG4gICAgfVxuICAgIHN0cmluZygpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XG4gICAgICAgIHJldHVybiAoMCwgdXRmOF8xLnV0ZjhSZWFkKShieXRlcywgMCwgYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG59XG5leHBvcnRzLkJpbmFyeVJlYWRlciA9IEJpbmFyeVJlYWRlcjtcbmNsYXNzIE9wIHtcbiAgICBjb25zdHJ1Y3RvcihmbiwgbGVuLCB2YWwpIHtcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgfVxuICAgIHByb2NlZWQoYnVmLCBwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZm4pIHtcbiAgICAgICAgICAgIHRoaXMuZm4odGhpcy52YWwsIGJ1ZiwgcG9zKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZXIpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCA9IHdyaXRlci50YWlsO1xuICAgICAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG4gICAgICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG4gICAgfVxufVxuY2xhc3MgQmluYXJ5V3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sZW4gPSAwO1xuICAgICAgICAvLyB1aW50NjQgaXMgdGhlIHNhbWUgd2l0aCBpbnQ2NFxuICAgICAgICB0aGlzLnVpbnQ2NCA9IEJpbmFyeVdyaXRlci5wcm90b3R5cGUuaW50NjQ7XG4gICAgICAgIC8vIHNmaXhlZDY0IGlzIHRoZSBzYW1lIHdpdGggZml4ZWQ2NFxuICAgICAgICB0aGlzLnNmaXhlZDY0ID0gQmluYXJ5V3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuICAgICAgICAvLyBzZml4ZWQzMiBpcyB0aGUgc2FtZSB3aXRoIGZpeGVkMzJcbiAgICAgICAgdGhpcy5zZml4ZWQzMiA9IEJpbmFyeVdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcbiAgICAgICAgdGhpcy5oZWFkID0gbmV3IE9wKG51bGwsIDAsIDApO1xuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlXcml0ZXIoKTtcbiAgICB9XG4gICAgc3RhdGljIGFsbG9jKHNpemUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9vbCgoc2l6ZSkgPT4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSksIFVpbnQ4QXJyYXkucHJvdG90eXBlLnN1YmFycmF5KShzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3B1c2goZm4sIGxlbiwgdmFsKSB7XG4gICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgbGV0IGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgcG9zID0gMDtcbiAgICAgICAgY29uc3QgYnVmID0gQmluYXJ5V3JpdGVyLmFsbG9jKHRoaXMubGVuKTtcbiAgICAgICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgICAgIGhlYWQucHJvY2VlZChidWYsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3AobnVsbCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICAgICAgdGhpcy5sZW4gPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgICAgICB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3AobnVsbCwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxkZWxpbSgpIHtcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuaGVhZCwgdGFpbCA9IHRoaXMudGFpbCwgbGVuID0gdGhpcy5sZW47XG4gICAgICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxuICAgICAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKCgoZmllbGRObyA8PCAzKSB8IHR5cGUpID4+PiAwKTtcbiAgICB9XG4gICAgdWludDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9XG4gICAgICAgICAgICBuZXcgT3AodmFyaW50XzEud3JpdGVWYXJpbnQzMiwgKHZhbHVlID0gdmFsdWUgPj4+IDApIDwgMTI4ID8gMSA6IHZhbHVlIDwgMTYzODQgPyAyIDogdmFsdWUgPCAyMDk3MTUyID8gMyA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNCA6IDUsIHZhbHVlKSkubGVuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaW50MzIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMFxuICAgICAgICAgICAgPyB0aGlzLl9wdXNoKHZhcmludF8xLndyaXRlVmFyaW50NjQsIDEwLCAoMCwgdmFyaW50XzEuaW50NjRGcm9tU3RyaW5nKSh2YWx1ZS50b1N0cmluZygpKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcbiAgICAgICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xuICAgIH1cbiAgICBzaW50MzIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKCgodmFsdWUgPDwgMSkgXiAodmFsdWUgPj4gMzEpKSA+Pj4gMCk7XG4gICAgfVxuICAgIGludDY0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgbG8sIGhpIH0gPSAoMCwgdmFyaW50XzEuaW50NjRGcm9tU3RyaW5nKSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2godmFyaW50XzEud3JpdGVWYXJpbnQ2NCwgKDAsIHZhcmludF8xLmludDY0TGVuZ3RoKShsbywgaGkpLCB7IGxvLCBoaSB9KTtcbiAgICB9XG4gICAgc2ludDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCB7IGxvLCBoaSB9ID0gKDAsIHZhcmludF8xLmludDY0RnJvbVN0cmluZykodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIC8vIHppZyB6YWdcbiAgICAgICAgW2xvLCBoaV0gPSAoMCwgdmFyaW50XzEuenpFbmNvZGUpKGxvLCBoaSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHZhcmludF8xLndyaXRlVmFyaW50NjQsICgwLCB2YXJpbnRfMS5pbnQ2NExlbmd0aCkobG8sIGhpKSwgeyBsbywgaGkgfSk7XG4gICAgfVxuICAgIGZpeGVkNjQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBsbywgaGkgfSA9ICgwLCB2YXJpbnRfMS5pbnQ2NEZyb21TdHJpbmcpKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh2YXJpbnRfMS53cml0ZUZpeGVkMzIsIDQsIGxvKS5fcHVzaCh2YXJpbnRfMS53cml0ZUZpeGVkMzIsIDQsIGhpKTtcbiAgICB9XG4gICAgYm9vbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh2YXJpbnRfMS53cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xuICAgIH1cbiAgICBmaXhlZDMyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHZhcmludF8xLndyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xuICAgIH1cbiAgICBmbG9hdCh2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmbG9hdCBub3Qgc3VwcG9ydGVkXCIgKyB2YWx1ZSk7XG4gICAgfVxuICAgIGRvdWJsZSh2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkb3VibGUgbm90IHN1cHBvcnRlZFwiICsgdmFsdWUpO1xuICAgIH1cbiAgICBieXRlcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgICAgIGlmICghbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2godmFyaW50XzEud3JpdGVCeXRlLCAxLCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsZW4gPSAoMCwgdXRmOF8xLnV0ZjhMZW5ndGgpKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxlbiA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOF8xLnV0ZjhXcml0ZSwgbGVuLCB2YWx1ZSkgOiB0aGlzLl9wdXNoKHZhcmludF8xLndyaXRlQnl0ZSwgMSwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5CaW5hcnlXcml0ZXIgPSBCaW5hcnlXcml0ZXI7XG5mdW5jdGlvbiB3cml0ZUJ5dGVzKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xuICAgIGNvbnN0IFNJWkUgPSBzaXplIHx8IDgxOTI7XG4gICAgY29uc3QgTUFYID0gU0laRSA+Pj4gMTtcbiAgICBsZXQgc2xhYiA9IG51bGw7XG4gICAgbGV0IG9mZnNldCA9IFNJWkU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBvb2xfYWxsb2Moc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcbiAgICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplKTtcbiAgICAgICAgaWYgKG9mZnNldCArIHNpemUgPiBTSVpFKSB7XG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHNsaWNlLmNhbGwoc2xhYiwgb2Zmc2V0LCAob2Zmc2V0ICs9IHNpemUpKTtcbiAgICAgICAgaWYgKG9mZnNldCAmIDcpXG4gICAgICAgICAgICAvLyBhbGlnbiB0byAzMiBiaXRcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShyZWFkZXIsIHdyaXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5hcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Metadata = exports.DenomUnit = exports.Supply = exports.Output = exports.Input = exports.SendEnabled = exports.Params = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst coin_1 = __webpack_require__(/*! ../../base/v1beta1/coin */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js\");\nconst binary_1 = __webpack_require__(/*! ../../../binary */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\");\nconst helpers_1 = __webpack_require__(/*! ../../../helpers */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\");\nexports.protobufPackage = \"cosmos.bank.v1beta1\";\nfunction createBaseParams() {\n    return {\n        sendEnabled: [],\n        defaultSendEnabled: false,\n    };\n}\nexports.Params = {\n    typeUrl: \"/cosmos.bank.v1beta1.Params\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        for (const v of message.sendEnabled) {\n            exports.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.defaultSendEnabled === true) {\n            writer.uint32(16).bool(message.defaultSendEnabled);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseParams();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sendEnabled.push(exports.SendEnabled.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.defaultSendEnabled = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseParams();\n        if (Array.isArray(object?.sendEnabled))\n            obj.sendEnabled = object.sendEnabled.map((e) => exports.SendEnabled.fromJSON(e));\n        if ((0, helpers_1.isSet)(object.defaultSendEnabled))\n            obj.defaultSendEnabled = Boolean(object.defaultSendEnabled);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.sendEnabled) {\n            obj.sendEnabled = message.sendEnabled.map((e) => (e ? exports.SendEnabled.toJSON(e) : undefined));\n        }\n        else {\n            obj.sendEnabled = [];\n        }\n        message.defaultSendEnabled !== undefined && (obj.defaultSendEnabled = message.defaultSendEnabled);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseParams();\n        message.sendEnabled = object.sendEnabled?.map((e) => exports.SendEnabled.fromPartial(e)) || [];\n        message.defaultSendEnabled = object.defaultSendEnabled ?? false;\n        return message;\n    },\n};\nfunction createBaseSendEnabled() {\n    return {\n        denom: \"\",\n        enabled: false,\n    };\n}\nexports.SendEnabled = {\n    typeUrl: \"/cosmos.bank.v1beta1.SendEnabled\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.denom !== \"\") {\n            writer.uint32(10).string(message.denom);\n        }\n        if (message.enabled === true) {\n            writer.uint32(16).bool(message.enabled);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendEnabled();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.denom = reader.string();\n                    break;\n                case 2:\n                    message.enabled = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseSendEnabled();\n        if ((0, helpers_1.isSet)(object.denom))\n            obj.denom = String(object.denom);\n        if ((0, helpers_1.isSet)(object.enabled))\n            obj.enabled = Boolean(object.enabled);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.denom !== undefined && (obj.denom = message.denom);\n        message.enabled !== undefined && (obj.enabled = message.enabled);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSendEnabled();\n        message.denom = object.denom ?? \"\";\n        message.enabled = object.enabled ?? false;\n        return message;\n    },\n};\nfunction createBaseInput() {\n    return {\n        address: \"\",\n        coins: [],\n    };\n}\nexports.Input = {\n    typeUrl: \"/cosmos.bank.v1beta1.Input\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.address !== \"\") {\n            writer.uint32(10).string(message.address);\n        }\n        for (const v of message.coins) {\n            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInput();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                case 2:\n                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseInput();\n        if ((0, helpers_1.isSet)(object.address))\n            obj.address = String(object.address);\n        if (Array.isArray(object?.coins))\n            obj.coins = object.coins.map((e) => coin_1.Coin.fromJSON(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        if (message.coins) {\n            obj.coins = message.coins.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.coins = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseInput();\n        message.address = object.address ?? \"\";\n        message.coins = object.coins?.map((e) => coin_1.Coin.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseOutput() {\n    return {\n        address: \"\",\n        coins: [],\n    };\n}\nexports.Output = {\n    typeUrl: \"/cosmos.bank.v1beta1.Output\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.address !== \"\") {\n            writer.uint32(10).string(message.address);\n        }\n        for (const v of message.coins) {\n            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOutput();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                case 2:\n                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseOutput();\n        if ((0, helpers_1.isSet)(object.address))\n            obj.address = String(object.address);\n        if (Array.isArray(object?.coins))\n            obj.coins = object.coins.map((e) => coin_1.Coin.fromJSON(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        if (message.coins) {\n            obj.coins = message.coins.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.coins = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseOutput();\n        message.address = object.address ?? \"\";\n        message.coins = object.coins?.map((e) => coin_1.Coin.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseSupply() {\n    return {\n        total: [],\n    };\n}\nexports.Supply = {\n    typeUrl: \"/cosmos.bank.v1beta1.Supply\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        for (const v of message.total) {\n            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSupply();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.total.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseSupply();\n        if (Array.isArray(object?.total))\n            obj.total = object.total.map((e) => coin_1.Coin.fromJSON(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.total) {\n            obj.total = message.total.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.total = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSupply();\n        message.total = object.total?.map((e) => coin_1.Coin.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseDenomUnit() {\n    return {\n        denom: \"\",\n        exponent: 0,\n        aliases: [],\n    };\n}\nexports.DenomUnit = {\n    typeUrl: \"/cosmos.bank.v1beta1.DenomUnit\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.denom !== \"\") {\n            writer.uint32(10).string(message.denom);\n        }\n        if (message.exponent !== 0) {\n            writer.uint32(16).uint32(message.exponent);\n        }\n        for (const v of message.aliases) {\n            writer.uint32(26).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDenomUnit();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.denom = reader.string();\n                    break;\n                case 2:\n                    message.exponent = reader.uint32();\n                    break;\n                case 3:\n                    message.aliases.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseDenomUnit();\n        if ((0, helpers_1.isSet)(object.denom))\n            obj.denom = String(object.denom);\n        if ((0, helpers_1.isSet)(object.exponent))\n            obj.exponent = Number(object.exponent);\n        if (Array.isArray(object?.aliases))\n            obj.aliases = object.aliases.map((e) => String(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.denom !== undefined && (obj.denom = message.denom);\n        message.exponent !== undefined && (obj.exponent = Math.round(message.exponent));\n        if (message.aliases) {\n            obj.aliases = message.aliases.map((e) => e);\n        }\n        else {\n            obj.aliases = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseDenomUnit();\n        message.denom = object.denom ?? \"\";\n        message.exponent = object.exponent ?? 0;\n        message.aliases = object.aliases?.map((e) => e) || [];\n        return message;\n    },\n};\nfunction createBaseMetadata() {\n    return {\n        description: \"\",\n        denomUnits: [],\n        base: \"\",\n        display: \"\",\n        name: \"\",\n        symbol: \"\",\n        uri: \"\",\n        uriHash: \"\",\n    };\n}\nexports.Metadata = {\n    typeUrl: \"/cosmos.bank.v1beta1.Metadata\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.description !== \"\") {\n            writer.uint32(10).string(message.description);\n        }\n        for (const v of message.denomUnits) {\n            exports.DenomUnit.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.base !== \"\") {\n            writer.uint32(26).string(message.base);\n        }\n        if (message.display !== \"\") {\n            writer.uint32(34).string(message.display);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(42).string(message.name);\n        }\n        if (message.symbol !== \"\") {\n            writer.uint32(50).string(message.symbol);\n        }\n        if (message.uri !== \"\") {\n            writer.uint32(58).string(message.uri);\n        }\n        if (message.uriHash !== \"\") {\n            writer.uint32(66).string(message.uriHash);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMetadata();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.description = reader.string();\n                    break;\n                case 2:\n                    message.denomUnits.push(exports.DenomUnit.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.base = reader.string();\n                    break;\n                case 4:\n                    message.display = reader.string();\n                    break;\n                case 5:\n                    message.name = reader.string();\n                    break;\n                case 6:\n                    message.symbol = reader.string();\n                    break;\n                case 7:\n                    message.uri = reader.string();\n                    break;\n                case 8:\n                    message.uriHash = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseMetadata();\n        if ((0, helpers_1.isSet)(object.description))\n            obj.description = String(object.description);\n        if (Array.isArray(object?.denomUnits))\n            obj.denomUnits = object.denomUnits.map((e) => exports.DenomUnit.fromJSON(e));\n        if ((0, helpers_1.isSet)(object.base))\n            obj.base = String(object.base);\n        if ((0, helpers_1.isSet)(object.display))\n            obj.display = String(object.display);\n        if ((0, helpers_1.isSet)(object.name))\n            obj.name = String(object.name);\n        if ((0, helpers_1.isSet)(object.symbol))\n            obj.symbol = String(object.symbol);\n        if ((0, helpers_1.isSet)(object.uri))\n            obj.uri = String(object.uri);\n        if ((0, helpers_1.isSet)(object.uriHash))\n            obj.uriHash = String(object.uriHash);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.description !== undefined && (obj.description = message.description);\n        if (message.denomUnits) {\n            obj.denomUnits = message.denomUnits.map((e) => (e ? exports.DenomUnit.toJSON(e) : undefined));\n        }\n        else {\n            obj.denomUnits = [];\n        }\n        message.base !== undefined && (obj.base = message.base);\n        message.display !== undefined && (obj.display = message.display);\n        message.name !== undefined && (obj.name = message.name);\n        message.symbol !== undefined && (obj.symbol = message.symbol);\n        message.uri !== undefined && (obj.uri = message.uri);\n        message.uriHash !== undefined && (obj.uriHash = message.uriHash);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMetadata();\n        message.description = object.description ?? \"\";\n        message.denomUnits = object.denomUnits?.map((e) => exports.DenomUnit.fromPartial(e)) || [];\n        message.base = object.base ?? \"\";\n        message.display = object.display ?? \"\";\n        message.name = object.name ?? \"\";\n        message.symbol = object.symbol ?? \"\";\n        message.uri = object.uri ?? \"\";\n        message.uriHash = object.uriHash ?? \"\";\n        return message;\n    },\n};\n//# sourceMappingURL=bank.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvY29zbW9zL2JhbmsvdjFiZXRhMS9iYW5rLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLG1CQUFtQixHQUFHLGNBQWMsR0FBRyx1QkFBdUI7QUFDdko7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0lBQXlCO0FBQ2hELGlCQUFpQixtQkFBTyxDQUFDLDBHQUFpQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyw0R0FBa0I7QUFDNUMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL2Nvc21qcy10eXBlc0AwLjkuMC9ub2RlX21vZHVsZXMvY29zbWpzLXR5cGVzL2Nvc21vcy9iYW5rL3YxYmV0YTEvYmFuay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0YWRhdGEgPSBleHBvcnRzLkRlbm9tVW5pdCA9IGV4cG9ydHMuU3VwcGx5ID0gZXhwb3J0cy5PdXRwdXQgPSBleHBvcnRzLklucHV0ID0gZXhwb3J0cy5TZW5kRW5hYmxlZCA9IGV4cG9ydHMuUGFyYW1zID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgY29pbl8xID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvdjFiZXRhMS9jb2luXCIpO1xuY29uc3QgYmluYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmluYXJ5XCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hlbHBlcnNcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLmJhbmsudjFiZXRhMVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVBhcmFtcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZW5kRW5hYmxlZDogW10sXG4gICAgICAgIGRlZmF1bHRTZW5kRW5hYmxlZDogZmFsc2UsXG4gICAgfTtcbn1cbmV4cG9ydHMuUGFyYW1zID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYW5rLnYxYmV0YTEuUGFyYW1zXCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zZW5kRW5hYmxlZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5TZW5kRW5hYmxlZC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZWZhdWx0U2VuZEVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmJvb2wobWVzc2FnZS5kZWZhdWx0U2VuZEVuYWJsZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVBhcmFtcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZEVuYWJsZWQucHVzaChleHBvcnRzLlNlbmRFbmFibGVkLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVmYXVsdFNlbmRFbmFibGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlUGFyYW1zKCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdD8uc2VuZEVuYWJsZWQpKVxuICAgICAgICAgICAgb2JqLnNlbmRFbmFibGVkID0gb2JqZWN0LnNlbmRFbmFibGVkLm1hcCgoZSkgPT4gZXhwb3J0cy5TZW5kRW5hYmxlZC5mcm9tSlNPTihlKSk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QuZGVmYXVsdFNlbmRFbmFibGVkKSlcbiAgICAgICAgICAgIG9iai5kZWZhdWx0U2VuZEVuYWJsZWQgPSBCb29sZWFuKG9iamVjdC5kZWZhdWx0U2VuZEVuYWJsZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnNlbmRFbmFibGVkKSB7XG4gICAgICAgICAgICBvYmouc2VuZEVuYWJsZWQgPSBtZXNzYWdlLnNlbmRFbmFibGVkLm1hcCgoZSkgPT4gKGUgPyBleHBvcnRzLlNlbmRFbmFibGVkLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnNlbmRFbmFibGVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5kZWZhdWx0U2VuZEVuYWJsZWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmRlZmF1bHRTZW5kRW5hYmxlZCA9IG1lc3NhZ2UuZGVmYXVsdFNlbmRFbmFibGVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVBhcmFtcygpO1xuICAgICAgICBtZXNzYWdlLnNlbmRFbmFibGVkID0gb2JqZWN0LnNlbmRFbmFibGVkPy5tYXAoKGUpID0+IGV4cG9ydHMuU2VuZEVuYWJsZWQuZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLmRlZmF1bHRTZW5kRW5hYmxlZCA9IG9iamVjdC5kZWZhdWx0U2VuZEVuYWJsZWQgPz8gZmFsc2U7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbmRFbmFibGVkKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbm9tOiBcIlwiLFxuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICB9O1xufVxuZXhwb3J0cy5TZW5kRW5hYmxlZCA9IHtcbiAgICB0eXBlVXJsOiBcIi9jb3Ntb3MuYmFuay52MWJldGExLlNlbmRFbmFibGVkXCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kZW5vbSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuZGVub20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmJvb2wobWVzc2FnZS5lbmFibGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZW5kRW5hYmxlZCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVub20gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbmFibGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlU2VuZEVuYWJsZWQoKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5kZW5vbSkpXG4gICAgICAgICAgICBvYmouZGVub20gPSBTdHJpbmcob2JqZWN0LmRlbm9tKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5lbmFibGVkKSlcbiAgICAgICAgICAgIG9iai5lbmFibGVkID0gQm9vbGVhbihvYmplY3QuZW5hYmxlZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZW5vbSAhPT0gdW5kZWZpbmVkICYmIChvYmouZGVub20gPSBtZXNzYWdlLmRlbm9tKTtcbiAgICAgICAgbWVzc2FnZS5lbmFibGVkICE9PSB1bmRlZmluZWQgJiYgKG9iai5lbmFibGVkID0gbWVzc2FnZS5lbmFibGVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbmRFbmFibGVkKCk7XG4gICAgICAgIG1lc3NhZ2UuZGVub20gPSBvYmplY3QuZGVub20gPz8gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5lbmFibGVkID0gb2JqZWN0LmVuYWJsZWQgPz8gZmFsc2U7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUlucHV0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IFwiXCIsXG4gICAgICAgIGNvaW5zOiBbXSxcbiAgICB9O1xufVxuZXhwb3J0cy5JbnB1dCA9IHtcbiAgICB0eXBlVXJsOiBcIi9jb3Ntb3MuYmFuay52MWJldGExLklucHV0XCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5jb2lucykge1xuICAgICAgICAgICAgY29pbl8xLkNvaW4uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW5wdXQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2lucy5wdXNoKGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VJbnB1dCgpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmFkZHJlc3MpKVxuICAgICAgICAgICAgb2JqLmFkZHJlc3MgPSBTdHJpbmcob2JqZWN0LmFkZHJlc3MpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Q/LmNvaW5zKSlcbiAgICAgICAgICAgIG9iai5jb2lucyA9IG9iamVjdC5jb2lucy5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21KU09OKGUpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiAob2JqLmFkZHJlc3MgPSBtZXNzYWdlLmFkZHJlc3MpO1xuICAgICAgICBpZiAobWVzc2FnZS5jb2lucykge1xuICAgICAgICAgICAgb2JqLmNvaW5zID0gbWVzc2FnZS5jb2lucy5tYXAoKGUpID0+IChlID8gY29pbl8xLkNvaW4udG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouY29pbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW5wdXQoKTtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gb2JqZWN0LmFkZHJlc3MgPz8gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5jb2lucyA9IG9iamVjdC5jb2lucz8ubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChlKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU91dHB1dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBcIlwiLFxuICAgICAgICBjb2luczogW10sXG4gICAgfTtcbn1cbmV4cG9ydHMuT3V0cHV0ID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYW5rLnYxYmV0YTEuT3V0cHV0XCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5jb2lucykge1xuICAgICAgICAgICAgY29pbl8xLkNvaW4uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlT3V0cHV0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29pbnMucHVzaChjb2luXzEuQ29pbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlT3V0cHV0KCk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QuYWRkcmVzcykpXG4gICAgICAgICAgICBvYmouYWRkcmVzcyA9IFN0cmluZyhvYmplY3QuYWRkcmVzcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdD8uY29pbnMpKVxuICAgICAgICAgICAgb2JqLmNvaW5zID0gb2JqZWN0LmNvaW5zLm1hcCgoZSkgPT4gY29pbl8xLkNvaW4uZnJvbUpTT04oZSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmIChvYmouYWRkcmVzcyA9IG1lc3NhZ2UuYWRkcmVzcyk7XG4gICAgICAgIGlmIChtZXNzYWdlLmNvaW5zKSB7XG4gICAgICAgICAgICBvYmouY29pbnMgPSBtZXNzYWdlLmNvaW5zLm1hcCgoZSkgPT4gKGUgPyBjb2luXzEuQ29pbi50b0pTT04oZSkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5jb2lucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VPdXRwdXQoKTtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gb2JqZWN0LmFkZHJlc3MgPz8gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5jb2lucyA9IG9iamVjdC5jb2lucz8ubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChlKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVN1cHBseSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3RhbDogW10sXG4gICAgfTtcbn1cbmV4cG9ydHMuU3VwcGx5ID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYW5rLnYxYmV0YTEuU3VwcGx5XCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS50b3RhbCkge1xuICAgICAgICAgICAgY29pbl8xLkNvaW4uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU3VwcGx5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b3RhbC5wdXNoKGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VTdXBwbHkoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0Py50b3RhbCkpXG4gICAgICAgICAgICBvYmoudG90YWwgPSBvYmplY3QudG90YWwubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tSlNPTihlKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG90YWwpIHtcbiAgICAgICAgICAgIG9iai50b3RhbCA9IG1lc3NhZ2UudG90YWwubWFwKChlKSA9PiAoZSA/IGNvaW5fMS5Db2luLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnRvdGFsID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVN1cHBseSgpO1xuICAgICAgICBtZXNzYWdlLnRvdGFsID0gb2JqZWN0LnRvdGFsPy5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVub21Vbml0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbm9tOiBcIlwiLFxuICAgICAgICBleHBvbmVudDogMCxcbiAgICAgICAgYWxpYXNlczogW10sXG4gICAgfTtcbn1cbmV4cG9ydHMuRGVub21Vbml0ID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYW5rLnYxYmV0YTEuRGVub21Vbml0XCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kZW5vbSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuZGVub20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmV4cG9uZW50ICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50MzIobWVzc2FnZS5leHBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYWxpYXNlcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlbm9tVW5pdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVub20gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5leHBvbmVudCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFsaWFzZXMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VEZW5vbVVuaXQoKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5kZW5vbSkpXG4gICAgICAgICAgICBvYmouZGVub20gPSBTdHJpbmcob2JqZWN0LmRlbm9tKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5leHBvbmVudCkpXG4gICAgICAgICAgICBvYmouZXhwb25lbnQgPSBOdW1iZXIob2JqZWN0LmV4cG9uZW50KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0Py5hbGlhc2VzKSlcbiAgICAgICAgICAgIG9iai5hbGlhc2VzID0gb2JqZWN0LmFsaWFzZXMubWFwKChlKSA9PiBTdHJpbmcoZSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZGVub20gIT09IHVuZGVmaW5lZCAmJiAob2JqLmRlbm9tID0gbWVzc2FnZS5kZW5vbSk7XG4gICAgICAgIG1lc3NhZ2UuZXhwb25lbnQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmV4cG9uZW50ID0gTWF0aC5yb3VuZChtZXNzYWdlLmV4cG9uZW50KSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmFsaWFzZXMpIHtcbiAgICAgICAgICAgIG9iai5hbGlhc2VzID0gbWVzc2FnZS5hbGlhc2VzLm1hcCgoZSkgPT4gZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouYWxpYXNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZW5vbVVuaXQoKTtcbiAgICAgICAgbWVzc2FnZS5kZW5vbSA9IG9iamVjdC5kZW5vbSA/PyBcIlwiO1xuICAgICAgICBtZXNzYWdlLmV4cG9uZW50ID0gb2JqZWN0LmV4cG9uZW50ID8/IDA7XG4gICAgICAgIG1lc3NhZ2UuYWxpYXNlcyA9IG9iamVjdC5hbGlhc2VzPy5tYXAoKGUpID0+IGUpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgZGVub21Vbml0czogW10sXG4gICAgICAgIGJhc2U6IFwiXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHN5bWJvbDogXCJcIixcbiAgICAgICAgdXJpOiBcIlwiLFxuICAgICAgICB1cmlIYXNoOiBcIlwiLFxuICAgIH07XG59XG5leHBvcnRzLk1ldGFkYXRhID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYW5rLnYxYmV0YTEuTWV0YWRhdGFcIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5kZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZGVub21Vbml0cykge1xuICAgICAgICAgICAgZXhwb3J0cy5EZW5vbVVuaXQuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmFzZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UuYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGlzcGxheSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2UuZGlzcGxheSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0Mikuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3ltYm9sICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDUwKS5zdHJpbmcobWVzc2FnZS5zeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnVyaSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig1OCkuc3RyaW5nKG1lc3NhZ2UudXJpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS51cmlIYXNoICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDY2KS5zdHJpbmcobWVzc2FnZS51cmlIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZXRhZGF0YSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVzY3JpcHRpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZW5vbVVuaXRzLnB1c2goZXhwb3J0cy5EZW5vbVVuaXQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iYXNlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGlzcGxheSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zeW1ib2wgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cmkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cmlIYXNoID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VNZXRhZGF0YSgpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmRlc2NyaXB0aW9uKSlcbiAgICAgICAgICAgIG9iai5kZXNjcmlwdGlvbiA9IFN0cmluZyhvYmplY3QuZGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Q/LmRlbm9tVW5pdHMpKVxuICAgICAgICAgICAgb2JqLmRlbm9tVW5pdHMgPSBvYmplY3QuZGVub21Vbml0cy5tYXAoKGUpID0+IGV4cG9ydHMuRGVub21Vbml0LmZyb21KU09OKGUpKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5iYXNlKSlcbiAgICAgICAgICAgIG9iai5iYXNlID0gU3RyaW5nKG9iamVjdC5iYXNlKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5kaXNwbGF5KSlcbiAgICAgICAgICAgIG9iai5kaXNwbGF5ID0gU3RyaW5nKG9iamVjdC5kaXNwbGF5KTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIG9iai5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5zeW1ib2wpKVxuICAgICAgICAgICAgb2JqLnN5bWJvbCA9IFN0cmluZyhvYmplY3Quc3ltYm9sKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC51cmkpKVxuICAgICAgICAgICAgb2JqLnVyaSA9IFN0cmluZyhvYmplY3QudXJpKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC51cmlIYXNoKSlcbiAgICAgICAgICAgIG9iai51cmlIYXNoID0gU3RyaW5nKG9iamVjdC51cmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQgJiYgKG9iai5kZXNjcmlwdGlvbiA9IG1lc3NhZ2UuZGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAobWVzc2FnZS5kZW5vbVVuaXRzKSB7XG4gICAgICAgICAgICBvYmouZGVub21Vbml0cyA9IG1lc3NhZ2UuZGVub21Vbml0cy5tYXAoKGUpID0+IChlID8gZXhwb3J0cy5EZW5vbVVuaXQudG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouZGVub21Vbml0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UuYmFzZSAhPT0gdW5kZWZpbmVkICYmIChvYmouYmFzZSA9IG1lc3NhZ2UuYmFzZSk7XG4gICAgICAgIG1lc3NhZ2UuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIChvYmouZGlzcGxheSA9IG1lc3NhZ2UuZGlzcGxheSk7XG4gICAgICAgIG1lc3NhZ2UubmFtZSAhPT0gdW5kZWZpbmVkICYmIChvYmoubmFtZSA9IG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIG1lc3NhZ2Uuc3ltYm9sICE9PSB1bmRlZmluZWQgJiYgKG9iai5zeW1ib2wgPSBtZXNzYWdlLnN5bWJvbCk7XG4gICAgICAgIG1lc3NhZ2UudXJpICE9PSB1bmRlZmluZWQgJiYgKG9iai51cmkgPSBtZXNzYWdlLnVyaSk7XG4gICAgICAgIG1lc3NhZ2UudXJpSGFzaCAhPT0gdW5kZWZpbmVkICYmIChvYmoudXJpSGFzaCA9IG1lc3NhZ2UudXJpSGFzaCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZXRhZGF0YSgpO1xuICAgICAgICBtZXNzYWdlLmRlc2NyaXB0aW9uID0gb2JqZWN0LmRlc2NyaXB0aW9uID8/IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuZGVub21Vbml0cyA9IG9iamVjdC5kZW5vbVVuaXRzPy5tYXAoKGUpID0+IGV4cG9ydHMuRGVub21Vbml0LmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5iYXNlID0gb2JqZWN0LmJhc2UgPz8gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kaXNwbGF5ID0gb2JqZWN0LmRpc3BsYXkgPz8gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gb2JqZWN0Lm5hbWUgPz8gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zeW1ib2wgPSBvYmplY3Quc3ltYm9sID8/IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudXJpID0gb2JqZWN0LnVyaSA/PyBcIlwiO1xuICAgICAgICBtZXNzYWdlLnVyaUhhc2ggPSBvYmplY3QudXJpSGFzaCA/PyBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhbmsuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgClientImpl = exports.MsgSetSendEnabledResponse = exports.MsgSetSendEnabled = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgMultiSendResponse = exports.MsgMultiSend = exports.MsgSendResponse = exports.MsgSend = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst coin_1 = __webpack_require__(/*! ../../base/v1beta1/coin */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js\");\nconst bank_1 = __webpack_require__(/*! ./bank */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js\");\nconst binary_1 = __webpack_require__(/*! ../../../binary */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\");\nconst helpers_1 = __webpack_require__(/*! ../../../helpers */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\");\nexports.protobufPackage = \"cosmos.bank.v1beta1\";\nfunction createBaseMsgSend() {\n    return {\n        fromAddress: \"\",\n        toAddress: \"\",\n        amount: [],\n    };\n}\nexports.MsgSend = {\n    typeUrl: \"/cosmos.bank.v1beta1.MsgSend\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.fromAddress !== \"\") {\n            writer.uint32(10).string(message.fromAddress);\n        }\n        if (message.toAddress !== \"\") {\n            writer.uint32(18).string(message.toAddress);\n        }\n        for (const v of message.amount) {\n            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSend();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.fromAddress = reader.string();\n                    break;\n                case 2:\n                    message.toAddress = reader.string();\n                    break;\n                case 3:\n                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseMsgSend();\n        if ((0, helpers_1.isSet)(object.fromAddress))\n            obj.fromAddress = String(object.fromAddress);\n        if ((0, helpers_1.isSet)(object.toAddress))\n            obj.toAddress = String(object.toAddress);\n        if (Array.isArray(object?.amount))\n            obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.fromAddress !== undefined && (obj.fromAddress = message.fromAddress);\n        message.toAddress !== undefined && (obj.toAddress = message.toAddress);\n        if (message.amount) {\n            obj.amount = message.amount.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.amount = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgSend();\n        message.fromAddress = object.fromAddress ?? \"\";\n        message.toAddress = object.toAddress ?? \"\";\n        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseMsgSendResponse() {\n    return {};\n}\nexports.MsgSendResponse = {\n    typeUrl: \"/cosmos.bank.v1beta1.MsgSendResponse\",\n    encode(_, writer = binary_1.BinaryWriter.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSendResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const obj = createBaseMsgSendResponse();\n        return obj;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgSendResponse();\n        return message;\n    },\n};\nfunction createBaseMsgMultiSend() {\n    return {\n        inputs: [],\n        outputs: [],\n    };\n}\nexports.MsgMultiSend = {\n    typeUrl: \"/cosmos.bank.v1beta1.MsgMultiSend\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        for (const v of message.inputs) {\n            bank_1.Input.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.outputs) {\n            bank_1.Output.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgMultiSend();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseMsgMultiSend();\n        if (Array.isArray(object?.inputs))\n            obj.inputs = object.inputs.map((e) => bank_1.Input.fromJSON(e));\n        if (Array.isArray(object?.outputs))\n            obj.outputs = object.outputs.map((e) => bank_1.Output.fromJSON(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.inputs) {\n            obj.inputs = message.inputs.map((e) => (e ? bank_1.Input.toJSON(e) : undefined));\n        }\n        else {\n            obj.inputs = [];\n        }\n        if (message.outputs) {\n            obj.outputs = message.outputs.map((e) => (e ? bank_1.Output.toJSON(e) : undefined));\n        }\n        else {\n            obj.outputs = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgMultiSend();\n        message.inputs = object.inputs?.map((e) => bank_1.Input.fromPartial(e)) || [];\n        message.outputs = object.outputs?.map((e) => bank_1.Output.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseMsgMultiSendResponse() {\n    return {};\n}\nexports.MsgMultiSendResponse = {\n    typeUrl: \"/cosmos.bank.v1beta1.MsgMultiSendResponse\",\n    encode(_, writer = binary_1.BinaryWriter.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgMultiSendResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const obj = createBaseMsgMultiSendResponse();\n        return obj;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgMultiSendResponse();\n        return message;\n    },\n};\nfunction createBaseMsgUpdateParams() {\n    return {\n        authority: \"\",\n        params: bank_1.Params.fromPartial({}),\n    };\n}\nexports.MsgUpdateParams = {\n    typeUrl: \"/cosmos.bank.v1beta1.MsgUpdateParams\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.authority !== \"\") {\n            writer.uint32(10).string(message.authority);\n        }\n        if (message.params !== undefined) {\n            bank_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateParams();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authority = reader.string();\n                    break;\n                case 2:\n                    message.params = bank_1.Params.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseMsgUpdateParams();\n        if ((0, helpers_1.isSet)(object.authority))\n            obj.authority = String(object.authority);\n        if ((0, helpers_1.isSet)(object.params))\n            obj.params = bank_1.Params.fromJSON(object.params);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.authority !== undefined && (obj.authority = message.authority);\n        message.params !== undefined && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgUpdateParams();\n        message.authority = object.authority ?? \"\";\n        if (object.params !== undefined && object.params !== null) {\n            message.params = bank_1.Params.fromPartial(object.params);\n        }\n        return message;\n    },\n};\nfunction createBaseMsgUpdateParamsResponse() {\n    return {};\n}\nexports.MsgUpdateParamsResponse = {\n    typeUrl: \"/cosmos.bank.v1beta1.MsgUpdateParamsResponse\",\n    encode(_, writer = binary_1.BinaryWriter.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateParamsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const obj = createBaseMsgUpdateParamsResponse();\n        return obj;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgUpdateParamsResponse();\n        return message;\n    },\n};\nfunction createBaseMsgSetSendEnabled() {\n    return {\n        authority: \"\",\n        sendEnabled: [],\n        useDefaultFor: [],\n    };\n}\nexports.MsgSetSendEnabled = {\n    typeUrl: \"/cosmos.bank.v1beta1.MsgSetSendEnabled\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.authority !== \"\") {\n            writer.uint32(10).string(message.authority);\n        }\n        for (const v of message.sendEnabled) {\n            bank_1.SendEnabled.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        for (const v of message.useDefaultFor) {\n            writer.uint32(26).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSetSendEnabled();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authority = reader.string();\n                    break;\n                case 2:\n                    message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.useDefaultFor.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseMsgSetSendEnabled();\n        if ((0, helpers_1.isSet)(object.authority))\n            obj.authority = String(object.authority);\n        if (Array.isArray(object?.sendEnabled))\n            obj.sendEnabled = object.sendEnabled.map((e) => bank_1.SendEnabled.fromJSON(e));\n        if (Array.isArray(object?.useDefaultFor))\n            obj.useDefaultFor = object.useDefaultFor.map((e) => String(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.authority !== undefined && (obj.authority = message.authority);\n        if (message.sendEnabled) {\n            obj.sendEnabled = message.sendEnabled.map((e) => (e ? bank_1.SendEnabled.toJSON(e) : undefined));\n        }\n        else {\n            obj.sendEnabled = [];\n        }\n        if (message.useDefaultFor) {\n            obj.useDefaultFor = message.useDefaultFor.map((e) => e);\n        }\n        else {\n            obj.useDefaultFor = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgSetSendEnabled();\n        message.authority = object.authority ?? \"\";\n        message.sendEnabled = object.sendEnabled?.map((e) => bank_1.SendEnabled.fromPartial(e)) || [];\n        message.useDefaultFor = object.useDefaultFor?.map((e) => e) || [];\n        return message;\n    },\n};\nfunction createBaseMsgSetSendEnabledResponse() {\n    return {};\n}\nexports.MsgSetSendEnabledResponse = {\n    typeUrl: \"/cosmos.bank.v1beta1.MsgSetSendEnabledResponse\",\n    encode(_, writer = binary_1.BinaryWriter.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSetSendEnabledResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const obj = createBaseMsgSetSendEnabledResponse();\n        return obj;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgSetSendEnabledResponse();\n        return message;\n    },\n};\nclass MsgClientImpl {\n    constructor(rpc) {\n        this.rpc = rpc;\n        this.Send = this.Send.bind(this);\n        this.MultiSend = this.MultiSend.bind(this);\n        this.UpdateParams = this.UpdateParams.bind(this);\n        this.SetSendEnabled = this.SetSendEnabled.bind(this);\n    }\n    Send(request) {\n        const data = exports.MsgSend.encode(request).finish();\n        const promise = this.rpc.request(\"cosmos.bank.v1beta1.Msg\", \"Send\", data);\n        return promise.then((data) => exports.MsgSendResponse.decode(new binary_1.BinaryReader(data)));\n    }\n    MultiSend(request) {\n        const data = exports.MsgMultiSend.encode(request).finish();\n        const promise = this.rpc.request(\"cosmos.bank.v1beta1.Msg\", \"MultiSend\", data);\n        return promise.then((data) => exports.MsgMultiSendResponse.decode(new binary_1.BinaryReader(data)));\n    }\n    UpdateParams(request) {\n        const data = exports.MsgUpdateParams.encode(request).finish();\n        const promise = this.rpc.request(\"cosmos.bank.v1beta1.Msg\", \"UpdateParams\", data);\n        return promise.then((data) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data)));\n    }\n    SetSendEnabled(request) {\n        const data = exports.MsgSetSendEnabled.encode(request).finish();\n        const promise = this.rpc.request(\"cosmos.bank.v1beta1.Msg\", \"SetSendEnabled\", data);\n        return promise.then((data) => exports.MsgSetSendEnabledResponse.decode(new binary_1.BinaryReader(data)));\n    }\n}\nexports.MsgClientImpl = MsgClientImpl;\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvY29zbW9zL2JhbmsvdjFiZXRhMS90eC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxpQ0FBaUMsR0FBRyx5QkFBeUIsR0FBRywrQkFBK0IsR0FBRyx1QkFBdUIsR0FBRyw0QkFBNEIsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUIsR0FBRyxlQUFlLEdBQUcsdUJBQXVCO0FBQzdRO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLG9JQUF5QjtBQUNoRCxlQUFlLG1CQUFPLENBQUMsbUhBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsMEdBQWlCO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLDRHQUFrQjtBQUM1Qyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL2Nvc21qcy10eXBlc0AwLjkuMC9ub2RlX21vZHVsZXMvY29zbWpzLXR5cGVzL2Nvc21vcy9iYW5rL3YxYmV0YTEvdHguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1zZ0NsaWVudEltcGwgPSBleHBvcnRzLk1zZ1NldFNlbmRFbmFibGVkUmVzcG9uc2UgPSBleHBvcnRzLk1zZ1NldFNlbmRFbmFibGVkID0gZXhwb3J0cy5Nc2dVcGRhdGVQYXJhbXNSZXNwb25zZSA9IGV4cG9ydHMuTXNnVXBkYXRlUGFyYW1zID0gZXhwb3J0cy5Nc2dNdWx0aVNlbmRSZXNwb25zZSA9IGV4cG9ydHMuTXNnTXVsdGlTZW5kID0gZXhwb3J0cy5Nc2dTZW5kUmVzcG9uc2UgPSBleHBvcnRzLk1zZ1NlbmQgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBjb2luXzEgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS92MWJldGExL2NvaW5cIik7XG5jb25zdCBiYW5rXzEgPSByZXF1aXJlKFwiLi9iYW5rXCIpO1xuY29uc3QgYmluYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmluYXJ5XCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hlbHBlcnNcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLmJhbmsudjFiZXRhMVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1NlbmQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUFkZHJlc3M6IFwiXCIsXG4gICAgICAgIHRvQWRkcmVzczogXCJcIixcbiAgICAgICAgYW1vdW50OiBbXSxcbiAgICB9O1xufVxuZXhwb3J0cy5Nc2dTZW5kID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYW5rLnYxYmV0YTEuTXNnU2VuZFwiLFxuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBiaW5hcnlfMS5CaW5hcnlXcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZnJvbUFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmZyb21BZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b0FkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnRvQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYW1vdW50KSB7XG4gICAgICAgICAgICBjb2luXzEuQ29pbi5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTZW5kKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mcm9tQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRvQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFtb3VudC5wdXNoKGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VNc2dTZW5kKCk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QuZnJvbUFkZHJlc3MpKVxuICAgICAgICAgICAgb2JqLmZyb21BZGRyZXNzID0gU3RyaW5nKG9iamVjdC5mcm9tQWRkcmVzcyk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QudG9BZGRyZXNzKSlcbiAgICAgICAgICAgIG9iai50b0FkZHJlc3MgPSBTdHJpbmcob2JqZWN0LnRvQWRkcmVzcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdD8uYW1vdW50KSlcbiAgICAgICAgICAgIG9iai5hbW91bnQgPSBvYmplY3QuYW1vdW50Lm1hcCgoZSkgPT4gY29pbl8xLkNvaW4uZnJvbUpTT04oZSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZnJvbUFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiAob2JqLmZyb21BZGRyZXNzID0gbWVzc2FnZS5mcm9tQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UudG9BZGRyZXNzICE9PSB1bmRlZmluZWQgJiYgKG9iai50b0FkZHJlc3MgPSBtZXNzYWdlLnRvQWRkcmVzcyk7XG4gICAgICAgIGlmIChtZXNzYWdlLmFtb3VudCkge1xuICAgICAgICAgICAgb2JqLmFtb3VudCA9IG1lc3NhZ2UuYW1vdW50Lm1hcCgoZSkgPT4gKGUgPyBjb2luXzEuQ29pbi50b0pTT04oZSkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5hbW91bnQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnU2VuZCgpO1xuICAgICAgICBtZXNzYWdlLmZyb21BZGRyZXNzID0gb2JqZWN0LmZyb21BZGRyZXNzID8/IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudG9BZGRyZXNzID0gb2JqZWN0LnRvQWRkcmVzcyA/PyBcIlwiO1xuICAgICAgICBtZXNzYWdlLmFtb3VudCA9IG9iamVjdC5hbW91bnQ/Lm1hcCgoZSkgPT4gY29pbl8xLkNvaW4uZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dTZW5kUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHt9O1xufVxuZXhwb3J0cy5Nc2dTZW5kUmVzcG9uc2UgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dTZW5kUmVzcG9uc2VcIixcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1NlbmRSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlTXNnU2VuZFJlc3BvbnNlKCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTZW5kUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnTXVsdGlTZW5kKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgIH07XG59XG5leHBvcnRzLk1zZ011bHRpU2VuZCA9IHtcbiAgICB0eXBlVXJsOiBcIi9jb3Ntb3MuYmFuay52MWJldGExLk1zZ011bHRpU2VuZFwiLFxuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBiaW5hcnlfMS5CaW5hcnlXcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuaW5wdXRzKSB7XG4gICAgICAgICAgICBiYW5rXzEuSW5wdXQuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2Uub3V0cHV0cykge1xuICAgICAgICAgICAgYmFua18xLk91dHB1dC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dNdWx0aVNlbmQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0cy5wdXNoKGJhbmtfMS5JbnB1dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dHMucHVzaChiYW5rXzEuT3V0cHV0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VNc2dNdWx0aVNlbmQoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0Py5pbnB1dHMpKVxuICAgICAgICAgICAgb2JqLmlucHV0cyA9IG9iamVjdC5pbnB1dHMubWFwKChlKSA9PiBiYW5rXzEuSW5wdXQuZnJvbUpTT04oZSkpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Q/Lm91dHB1dHMpKVxuICAgICAgICAgICAgb2JqLm91dHB1dHMgPSBvYmplY3Qub3V0cHV0cy5tYXAoKGUpID0+IGJhbmtfMS5PdXRwdXQuZnJvbUpTT04oZSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmlucHV0cykge1xuICAgICAgICAgICAgb2JqLmlucHV0cyA9IG1lc3NhZ2UuaW5wdXRzLm1hcCgoZSkgPT4gKGUgPyBiYW5rXzEuSW5wdXQudG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouaW5wdXRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0cykge1xuICAgICAgICAgICAgb2JqLm91dHB1dHMgPSBtZXNzYWdlLm91dHB1dHMubWFwKChlKSA9PiAoZSA/IGJhbmtfMS5PdXRwdXQudG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoub3V0cHV0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dNdWx0aVNlbmQoKTtcbiAgICAgICAgbWVzc2FnZS5pbnB1dHMgPSBvYmplY3QuaW5wdXRzPy5tYXAoKGUpID0+IGJhbmtfMS5JbnB1dC5mcm9tUGFydGlhbChlKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2Uub3V0cHV0cyA9IG9iamVjdC5vdXRwdXRzPy5tYXAoKGUpID0+IGJhbmtfMS5PdXRwdXQuZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dNdWx0aVNlbmRSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ011bHRpU2VuZFJlc3BvbnNlID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYW5rLnYxYmV0YTEuTXNnTXVsdGlTZW5kUmVzcG9uc2VcIixcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ011bHRpU2VuZFJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihfKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VNc2dNdWx0aVNlbmRSZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnTXVsdGlTZW5kUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnVXBkYXRlUGFyYW1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcml0eTogXCJcIixcbiAgICAgICAgcGFyYW1zOiBiYW5rXzEuUGFyYW1zLmZyb21QYXJ0aWFsKHt9KSxcbiAgICB9O1xufVxuZXhwb3J0cy5Nc2dVcGRhdGVQYXJhbXMgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dVcGRhdGVQYXJhbXNcIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhvcml0eSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuYXV0aG9yaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmFua18xLlBhcmFtcy5lbmNvZGUobWVzc2FnZS5wYXJhbXMsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnVXBkYXRlUGFyYW1zKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdXRob3JpdHkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJhbXMgPSBiYW5rXzEuUGFyYW1zLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZU1zZ1VwZGF0ZVBhcmFtcygpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmF1dGhvcml0eSkpXG4gICAgICAgICAgICBvYmouYXV0aG9yaXR5ID0gU3RyaW5nKG9iamVjdC5hdXRob3JpdHkpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LnBhcmFtcykpXG4gICAgICAgICAgICBvYmoucGFyYW1zID0gYmFua18xLlBhcmFtcy5mcm9tSlNPTihvYmplY3QucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmF1dGhvcml0eSAhPT0gdW5kZWZpbmVkICYmIChvYmouYXV0aG9yaXR5ID0gbWVzc2FnZS5hdXRob3JpdHkpO1xuICAgICAgICBtZXNzYWdlLnBhcmFtcyAhPT0gdW5kZWZpbmVkICYmIChvYmoucGFyYW1zID0gbWVzc2FnZS5wYXJhbXMgPyBiYW5rXzEuUGFyYW1zLnRvSlNPTihtZXNzYWdlLnBhcmFtcykgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnVXBkYXRlUGFyYW1zKCk7XG4gICAgICAgIG1lc3NhZ2UuYXV0aG9yaXR5ID0gb2JqZWN0LmF1dGhvcml0eSA/PyBcIlwiO1xuICAgICAgICBpZiAob2JqZWN0LnBhcmFtcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYXJhbXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucGFyYW1zID0gYmFua18xLlBhcmFtcy5mcm9tUGFydGlhbChvYmplY3QucGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dVcGRhdGVQYXJhbXNSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ1VwZGF0ZVBhcmFtc1Jlc3BvbnNlID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYW5rLnYxYmV0YTEuTXNnVXBkYXRlUGFyYW1zUmVzcG9uc2VcIixcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1VwZGF0ZVBhcmFtc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihfKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VNc2dVcGRhdGVQYXJhbXNSZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnVXBkYXRlUGFyYW1zUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnU2V0U2VuZEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yaXR5OiBcIlwiLFxuICAgICAgICBzZW5kRW5hYmxlZDogW10sXG4gICAgICAgIHVzZURlZmF1bHRGb3I6IFtdLFxuICAgIH07XG59XG5leHBvcnRzLk1zZ1NldFNlbmRFbmFibGVkID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYW5rLnYxYmV0YTEuTXNnU2V0U2VuZEVuYWJsZWRcIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhvcml0eSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuYXV0aG9yaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zZW5kRW5hYmxlZCkge1xuICAgICAgICAgICAgYmFua18xLlNlbmRFbmFibGVkLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnVzZURlZmF1bHRGb3IpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTZXRTZW5kRW5hYmxlZCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXV0aG9yaXR5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZEVuYWJsZWQucHVzaChiYW5rXzEuU2VuZEVuYWJsZWQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VEZWZhdWx0Rm9yLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlTXNnU2V0U2VuZEVuYWJsZWQoKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5hdXRob3JpdHkpKVxuICAgICAgICAgICAgb2JqLmF1dGhvcml0eSA9IFN0cmluZyhvYmplY3QuYXV0aG9yaXR5KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0Py5zZW5kRW5hYmxlZCkpXG4gICAgICAgICAgICBvYmouc2VuZEVuYWJsZWQgPSBvYmplY3Quc2VuZEVuYWJsZWQubWFwKChlKSA9PiBiYW5rXzEuU2VuZEVuYWJsZWQuZnJvbUpTT04oZSkpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Q/LnVzZURlZmF1bHRGb3IpKVxuICAgICAgICAgICAgb2JqLnVzZURlZmF1bHRGb3IgPSBvYmplY3QudXNlRGVmYXVsdEZvci5tYXAoKGUpID0+IFN0cmluZyhlKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hdXRob3JpdHkgIT09IHVuZGVmaW5lZCAmJiAob2JqLmF1dGhvcml0eSA9IG1lc3NhZ2UuYXV0aG9yaXR5KTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VuZEVuYWJsZWQpIHtcbiAgICAgICAgICAgIG9iai5zZW5kRW5hYmxlZCA9IG1lc3NhZ2Uuc2VuZEVuYWJsZWQubWFwKChlKSA9PiAoZSA/IGJhbmtfMS5TZW5kRW5hYmxlZC50b0pTT04oZSkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5zZW5kRW5hYmxlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnVzZURlZmF1bHRGb3IpIHtcbiAgICAgICAgICAgIG9iai51c2VEZWZhdWx0Rm9yID0gbWVzc2FnZS51c2VEZWZhdWx0Rm9yLm1hcCgoZSkgPT4gZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoudXNlRGVmYXVsdEZvciA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTZXRTZW5kRW5hYmxlZCgpO1xuICAgICAgICBtZXNzYWdlLmF1dGhvcml0eSA9IG9iamVjdC5hdXRob3JpdHkgPz8gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zZW5kRW5hYmxlZCA9IG9iamVjdC5zZW5kRW5hYmxlZD8ubWFwKChlKSA9PiBiYW5rXzEuU2VuZEVuYWJsZWQuZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLnVzZURlZmF1bHRGb3IgPSBvYmplY3QudXNlRGVmYXVsdEZvcj8ubWFwKChlKSA9PiBlKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnU2V0U2VuZEVuYWJsZWRSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ1NldFNlbmRFbmFibGVkUmVzcG9uc2UgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dTZXRTZW5kRW5hYmxlZFJlc3BvbnNlXCIsXG4gICAgZW5jb2RlKF8sIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTZXRTZW5kRW5hYmxlZFJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihfKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VNc2dTZXRTZW5kRW5hYmxlZFJlc3BvbnNlKCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTZXRTZW5kRW5hYmxlZFJlc3BvbnNlKCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuY2xhc3MgTXNnQ2xpZW50SW1wbCB7XG4gICAgY29uc3RydWN0b3IocnBjKSB7XG4gICAgICAgIHRoaXMucnBjID0gcnBjO1xuICAgICAgICB0aGlzLlNlbmQgPSB0aGlzLlNlbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5NdWx0aVNlbmQgPSB0aGlzLk11bHRpU2VuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLlVwZGF0ZVBhcmFtcyA9IHRoaXMuVXBkYXRlUGFyYW1zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuU2V0U2VuZEVuYWJsZWQgPSB0aGlzLlNldFNlbmRFbmFibGVkLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIFNlbmQocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZXhwb3J0cy5Nc2dTZW5kLmVuY29kZShyZXF1ZXN0KS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucnBjLnJlcXVlc3QoXCJjb3Ntb3MuYmFuay52MWJldGExLk1zZ1wiLCBcIlNlbmRcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGRhdGEpID0+IGV4cG9ydHMuTXNnU2VuZFJlc3BvbnNlLmRlY29kZShuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGRhdGEpKSk7XG4gICAgfVxuICAgIE11bHRpU2VuZChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBleHBvcnRzLk1zZ011bHRpU2VuZC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwiY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dcIiwgXCJNdWx0aVNlbmRcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGRhdGEpID0+IGV4cG9ydHMuTXNnTXVsdGlTZW5kUmVzcG9uc2UuZGVjb2RlKG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoZGF0YSkpKTtcbiAgICB9XG4gICAgVXBkYXRlUGFyYW1zKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGV4cG9ydHMuTXNnVXBkYXRlUGFyYW1zLmVuY29kZShyZXF1ZXN0KS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucnBjLnJlcXVlc3QoXCJjb3Ntb3MuYmFuay52MWJldGExLk1zZ1wiLCBcIlVwZGF0ZVBhcmFtc1wiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoZGF0YSkgPT4gZXhwb3J0cy5Nc2dVcGRhdGVQYXJhbXNSZXNwb25zZS5kZWNvZGUobmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihkYXRhKSkpO1xuICAgIH1cbiAgICBTZXRTZW5kRW5hYmxlZChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBleHBvcnRzLk1zZ1NldFNlbmRFbmFibGVkLmVuY29kZShyZXF1ZXN0KS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucnBjLnJlcXVlc3QoXCJjb3Ntb3MuYmFuay52MWJldGExLk1zZ1wiLCBcIlNldFNlbmRFbmFibGVkXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChkYXRhKSA9PiBleHBvcnRzLk1zZ1NldFNlbmRFbmFibGVkUmVzcG9uc2UuZGVjb2RlKG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoZGF0YSkpKTtcbiAgICB9XG59XG5leHBvcnRzLk1zZ0NsaWVudEltcGwgPSBNc2dDbGllbnRJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DecProto = exports.IntProto = exports.DecCoin = exports.Coin = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst binary_1 = __webpack_require__(/*! ../../../binary */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\");\nconst helpers_1 = __webpack_require__(/*! ../../../helpers */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\");\nexports.protobufPackage = \"cosmos.base.v1beta1\";\nfunction createBaseCoin() {\n    return {\n        denom: \"\",\n        amount: \"\",\n    };\n}\nexports.Coin = {\n    typeUrl: \"/cosmos.base.v1beta1.Coin\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.denom !== \"\") {\n            writer.uint32(10).string(message.denom);\n        }\n        if (message.amount !== \"\") {\n            writer.uint32(18).string(message.amount);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCoin();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.denom = reader.string();\n                    break;\n                case 2:\n                    message.amount = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseCoin();\n        if ((0, helpers_1.isSet)(object.denom))\n            obj.denom = String(object.denom);\n        if ((0, helpers_1.isSet)(object.amount))\n            obj.amount = String(object.amount);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.denom !== undefined && (obj.denom = message.denom);\n        message.amount !== undefined && (obj.amount = message.amount);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseCoin();\n        message.denom = object.denom ?? \"\";\n        message.amount = object.amount ?? \"\";\n        return message;\n    },\n};\nfunction createBaseDecCoin() {\n    return {\n        denom: \"\",\n        amount: \"\",\n    };\n}\nexports.DecCoin = {\n    typeUrl: \"/cosmos.base.v1beta1.DecCoin\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.denom !== \"\") {\n            writer.uint32(10).string(message.denom);\n        }\n        if (message.amount !== \"\") {\n            writer.uint32(18).string(message.amount);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecCoin();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.denom = reader.string();\n                    break;\n                case 2:\n                    message.amount = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseDecCoin();\n        if ((0, helpers_1.isSet)(object.denom))\n            obj.denom = String(object.denom);\n        if ((0, helpers_1.isSet)(object.amount))\n            obj.amount = String(object.amount);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.denom !== undefined && (obj.denom = message.denom);\n        message.amount !== undefined && (obj.amount = message.amount);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseDecCoin();\n        message.denom = object.denom ?? \"\";\n        message.amount = object.amount ?? \"\";\n        return message;\n    },\n};\nfunction createBaseIntProto() {\n    return {\n        int: \"\",\n    };\n}\nexports.IntProto = {\n    typeUrl: \"/cosmos.base.v1beta1.IntProto\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.int !== \"\") {\n            writer.uint32(10).string(message.int);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseIntProto();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.int = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseIntProto();\n        if ((0, helpers_1.isSet)(object.int))\n            obj.int = String(object.int);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.int !== undefined && (obj.int = message.int);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseIntProto();\n        message.int = object.int ?? \"\";\n        return message;\n    },\n};\nfunction createBaseDecProto() {\n    return {\n        dec: \"\",\n    };\n}\nexports.DecProto = {\n    typeUrl: \"/cosmos.base.v1beta1.DecProto\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.dec !== \"\") {\n            writer.uint32(10).string(message.dec);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecProto();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dec = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseDecProto();\n        if ((0, helpers_1.isSet)(object.dec))\n            obj.dec = String(object.dec);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.dec !== undefined && (obj.dec = message.dec);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseDecProto();\n        message.dec = object.dec ?? \"\";\n        return message;\n    },\n};\n//# sourceMappingURL=coin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcsdUJBQXVCO0FBQzlGO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMEdBQWlCO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLDRHQUFrQjtBQUM1Qyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL2Nvc21qcy10eXBlc0AwLjkuMC9ub2RlX21vZHVsZXMvY29zbWpzLXR5cGVzL2Nvc21vcy9iYXNlL3YxYmV0YTEvY29pbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVjUHJvdG8gPSBleHBvcnRzLkludFByb3RvID0gZXhwb3J0cy5EZWNDb2luID0gZXhwb3J0cy5Db2luID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgYmluYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmluYXJ5XCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hlbHBlcnNcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLmJhc2UudjFiZXRhMVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNvaW4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVub206IFwiXCIsXG4gICAgICAgIGFtb3VudDogXCJcIixcbiAgICB9O1xufVxuZXhwb3J0cy5Db2luID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYXNlLnYxYmV0YTEuQ29pblwiLFxuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBiaW5hcnlfMS5CaW5hcnlXcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVub20gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmRlbm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hbW91bnQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29pbigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVub20gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbW91bnQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZUNvaW4oKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5kZW5vbSkpXG4gICAgICAgICAgICBvYmouZGVub20gPSBTdHJpbmcob2JqZWN0LmRlbm9tKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5hbW91bnQpKVxuICAgICAgICAgICAgb2JqLmFtb3VudCA9IFN0cmluZyhvYmplY3QuYW1vdW50KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmRlbm9tICE9PSB1bmRlZmluZWQgJiYgKG9iai5kZW5vbSA9IG1lc3NhZ2UuZGVub20pO1xuICAgICAgICBtZXNzYWdlLmFtb3VudCAhPT0gdW5kZWZpbmVkICYmIChvYmouYW1vdW50ID0gbWVzc2FnZS5hbW91bnQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29pbigpO1xuICAgICAgICBtZXNzYWdlLmRlbm9tID0gb2JqZWN0LmRlbm9tID8/IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuYW1vdW50ID0gb2JqZWN0LmFtb3VudCA/PyBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEZWNDb2luKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbm9tOiBcIlwiLFxuICAgICAgICBhbW91bnQ6IFwiXCIsXG4gICAgfTtcbn1cbmV4cG9ydHMuRGVjQ29pbiA9IHtcbiAgICB0eXBlVXJsOiBcIi9jb3Ntb3MuYmFzZS52MWJldGExLkRlY0NvaW5cIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlbm9tICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5kZW5vbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYW1vdW50ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5hbW91bnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY0NvaW4oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbm9tID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYW1vdW50ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VEZWNDb2luKCk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QuZGVub20pKVxuICAgICAgICAgICAgb2JqLmRlbm9tID0gU3RyaW5nKG9iamVjdC5kZW5vbSk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QuYW1vdW50KSlcbiAgICAgICAgICAgIG9iai5hbW91bnQgPSBTdHJpbmcob2JqZWN0LmFtb3VudCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZW5vbSAhPT0gdW5kZWZpbmVkICYmIChvYmouZGVub20gPSBtZXNzYWdlLmRlbm9tKTtcbiAgICAgICAgbWVzc2FnZS5hbW91bnQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmFtb3VudCA9IG1lc3NhZ2UuYW1vdW50KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY0NvaW4oKTtcbiAgICAgICAgbWVzc2FnZS5kZW5vbSA9IG9iamVjdC5kZW5vbSA/PyBcIlwiO1xuICAgICAgICBtZXNzYWdlLmFtb3VudCA9IG9iamVjdC5hbW91bnQgPz8gXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlSW50UHJvdG8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50OiBcIlwiLFxuICAgIH07XG59XG5leHBvcnRzLkludFByb3RvID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYXNlLnYxYmV0YTEuSW50UHJvdG9cIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmludCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuaW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbnRQcm90bygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VJbnRQcm90bygpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmludCkpXG4gICAgICAgICAgICBvYmouaW50ID0gU3RyaW5nKG9iamVjdC5pbnQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaW50ICE9PSB1bmRlZmluZWQgJiYgKG9iai5pbnQgPSBtZXNzYWdlLmludCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbnRQcm90bygpO1xuICAgICAgICBtZXNzYWdlLmludCA9IG9iamVjdC5pbnQgPz8gXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVjUHJvdG8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjOiBcIlwiLFxuICAgIH07XG59XG5leHBvcnRzLkRlY1Byb3RvID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5iYXNlLnYxYmV0YTEuRGVjUHJvdG9cIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlYyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuZGVjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNQcm90bygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVjID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VEZWNQcm90bygpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmRlYykpXG4gICAgICAgICAgICBvYmouZGVjID0gU3RyaW5nKG9iamVjdC5kZWMpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZGVjICE9PSB1bmRlZmluZWQgJiYgKG9iai5kZWMgPSBtZXNzYWdlLmRlYyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNQcm90bygpO1xuICAgICAgICBtZXNzYWdlLmRlYyA9IG9iamVjdC5kZWMgPz8gXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2luLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PrivKey = exports.PubKey = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst binary_1 = __webpack_require__(/*! ../../../binary */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\");\nconst helpers_1 = __webpack_require__(/*! ../../../helpers */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\");\nexports.protobufPackage = \"cosmos.crypto.ed25519\";\nfunction createBasePubKey() {\n    return {\n        key: new Uint8Array(),\n    };\n}\nexports.PubKey = {\n    typeUrl: \"/cosmos.crypto.ed25519.PubKey\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePubKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBasePubKey();\n        if ((0, helpers_1.isSet)(object.key))\n            obj.key = (0, helpers_1.bytesFromBase64)(object.key);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePubKey();\n        message.key = object.key ?? new Uint8Array();\n        return message;\n    },\n};\nfunction createBasePrivKey() {\n    return {\n        key: new Uint8Array(),\n    };\n}\nexports.PrivKey = {\n    typeUrl: \"/cosmos.crypto.ed25519.PrivKey\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBasePrivKey();\n        if ((0, helpers_1.isSet)(object.key))\n            obj.key = (0, helpers_1.bytesFromBase64)(object.key);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePrivKey();\n        message.key = object.key ?? new Uint8Array();\n        return message;\n    },\n};\n//# sourceMappingURL=keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvY29zbW9zL2NyeXB0by9lZDI1NTE5L2tleXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLGNBQWMsR0FBRyx1QkFBdUI7QUFDMUQ7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywwR0FBaUI7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsNEdBQWtCO0FBQzVDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWJ1YmFrcmppbW9oL0Rlc2t0b3AvQ29kaW5nIFN0dWZmcy9oYWNrYXRob24vc2VjcmV0LW5ldHdvcmsvbWVtZUFpX2NvaW5fY3JlYXRvci9haS1tZW1lLWNvaW4tY3JlYXRvci9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvY29zbW9zL2NyeXB0by9lZDI1NTE5L2tleXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByaXZLZXkgPSBleHBvcnRzLlB1YktleSA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGJpbmFyeV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2JpbmFyeVwiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9oZWxwZXJzXCIpO1xuZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSBcImNvc21vcy5jcnlwdG8uZWQyNTUxOVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVB1YktleSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydHMuUHViS2V5ID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5jcnlwdG8uZWQyNTUxOS5QdWJLZXlcIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdWJLZXkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VQdWJLZXkoKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5rZXkpKVxuICAgICAgICAgICAgb2JqLmtleSA9ICgwLCBoZWxwZXJzXzEuYnl0ZXNGcm9tQmFzZTY0KShvYmplY3Qua2V5KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmtleSA9ICgwLCBoZWxwZXJzXzEuYmFzZTY0RnJvbUJ5dGVzKShtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5rZXkgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdWJLZXkoKTtcbiAgICAgICAgbWVzc2FnZS5rZXkgPSBvYmplY3Qua2V5ID8/IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVByaXZLZXkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnRzLlByaXZLZXkgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLmNyeXB0by5lZDI1NTE5LlByaXZLZXlcIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2S2V5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlUHJpdktleSgpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmtleSkpXG4gICAgICAgICAgICBvYmoua2V5ID0gKDAsIGhlbHBlcnNfMS5ieXRlc0Zyb21CYXNlNjQpKG9iamVjdC5rZXkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uua2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoua2V5ID0gKDAsIGhlbHBlcnNfMS5iYXNlNjRGcm9tQnl0ZXMpKG1lc3NhZ2Uua2V5ICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmtleSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZLZXkoKTtcbiAgICAgICAgbWVzc2FnZS5rZXkgPSBvYmplY3Qua2V5ID8/IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LegacyAminoPubKey = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/google/protobuf/any.js\");\nconst binary_1 = __webpack_require__(/*! ../../../binary */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\");\nconst helpers_1 = __webpack_require__(/*! ../../../helpers */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\");\nexports.protobufPackage = \"cosmos.crypto.multisig\";\nfunction createBaseLegacyAminoPubKey() {\n    return {\n        threshold: 0,\n        publicKeys: [],\n    };\n}\nexports.LegacyAminoPubKey = {\n    typeUrl: \"/cosmos.crypto.multisig.LegacyAminoPubKey\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.threshold !== 0) {\n            writer.uint32(8).uint32(message.threshold);\n        }\n        for (const v of message.publicKeys) {\n            any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseLegacyAminoPubKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.threshold = reader.uint32();\n                    break;\n                case 2:\n                    message.publicKeys.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseLegacyAminoPubKey();\n        if ((0, helpers_1.isSet)(object.threshold))\n            obj.threshold = Number(object.threshold);\n        if (Array.isArray(object?.publicKeys))\n            obj.publicKeys = object.publicKeys.map((e) => any_1.Any.fromJSON(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.threshold !== undefined && (obj.threshold = Math.round(message.threshold));\n        if (message.publicKeys) {\n            obj.publicKeys = message.publicKeys.map((e) => (e ? any_1.Any.toJSON(e) : undefined));\n        }\n        else {\n            obj.publicKeys = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseLegacyAminoPubKey();\n        message.threshold = object.threshold ?? 0;\n        message.publicKeys = object.publicKeys?.map((e) => any_1.Any.fromPartial(e)) || [];\n        return message;\n    },\n};\n//# sourceMappingURL=keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvY29zbW9zL2NyeXB0by9tdWx0aXNpZy9rZXlzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHVCQUF1QjtBQUNuRDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxvSUFBOEI7QUFDcEQsaUJBQWlCLG1CQUFPLENBQUMsMEdBQWlCO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLDRHQUFrQjtBQUM1Qyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL2Nvc21qcy10eXBlc0AwLjkuMC9ub2RlX21vZHVsZXMvY29zbWpzLXR5cGVzL2Nvc21vcy9jcnlwdG8vbXVsdGlzaWcva2V5cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGVnYWN5QW1pbm9QdWJLZXkgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBhbnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9nb29nbGUvcHJvdG9idWYvYW55XCIpO1xuY29uc3QgYmluYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmluYXJ5XCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hlbHBlcnNcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLmNyeXB0by5tdWx0aXNpZ1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZUxlZ2FjeUFtaW5vUHViS2V5KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcHVibGljS2V5czogW10sXG4gICAgfTtcbn1cbmV4cG9ydHMuTGVnYWN5QW1pbm9QdWJLZXkgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLmNyeXB0by5tdWx0aXNpZy5MZWdhY3lBbWlub1B1YktleVwiLFxuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBiaW5hcnlfMS5CaW5hcnlXcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudGhyZXNob2xkICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLnVpbnQzMihtZXNzYWdlLnRocmVzaG9sZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucHVibGljS2V5cykge1xuICAgICAgICAgICAgYW55XzEuQW55LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUxlZ2FjeUFtaW5vUHViS2V5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aHJlc2hvbGQgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wdWJsaWNLZXlzLnB1c2goYW55XzEuQW55LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VMZWdhY3lBbWlub1B1YktleSgpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LnRocmVzaG9sZCkpXG4gICAgICAgICAgICBvYmoudGhyZXNob2xkID0gTnVtYmVyKG9iamVjdC50aHJlc2hvbGQpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Q/LnB1YmxpY0tleXMpKVxuICAgICAgICAgICAgb2JqLnB1YmxpY0tleXMgPSBvYmplY3QucHVibGljS2V5cy5tYXAoKGUpID0+IGFueV8xLkFueS5mcm9tSlNPTihlKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRocmVzaG9sZCA9IE1hdGgucm91bmQobWVzc2FnZS50aHJlc2hvbGQpKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucHVibGljS2V5cykge1xuICAgICAgICAgICAgb2JqLnB1YmxpY0tleXMgPSBtZXNzYWdlLnB1YmxpY0tleXMubWFwKChlKSA9PiAoZSA/IGFueV8xLkFueS50b0pTT04oZSkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5wdWJsaWNLZXlzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUxlZ2FjeUFtaW5vUHViS2V5KCk7XG4gICAgICAgIG1lc3NhZ2UudGhyZXNob2xkID0gb2JqZWN0LnRocmVzaG9sZCA/PyAwO1xuICAgICAgICBtZXNzYWdlLnB1YmxpY0tleXMgPSBvYmplY3QucHVibGljS2V5cz8ubWFwKChlKSA9PiBhbnlfMS5BbnkuZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompactBitArray = exports.MultiSignature = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst binary_1 = __webpack_require__(/*! ../../../../binary */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\");\nconst helpers_1 = __webpack_require__(/*! ../../../../helpers */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\");\nexports.protobufPackage = \"cosmos.crypto.multisig.v1beta1\";\nfunction createBaseMultiSignature() {\n    return {\n        signatures: [],\n    };\n}\nexports.MultiSignature = {\n    typeUrl: \"/cosmos.crypto.multisig.v1beta1.MultiSignature\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        for (const v of message.signatures) {\n            writer.uint32(10).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMultiSignature();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signatures.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseMultiSignature();\n        if (Array.isArray(object?.signatures))\n            obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMultiSignature();\n        message.signatures = object.signatures?.map((e) => e) || [];\n        return message;\n    },\n};\nfunction createBaseCompactBitArray() {\n    return {\n        extraBitsStored: 0,\n        elems: new Uint8Array(),\n    };\n}\nexports.CompactBitArray = {\n    typeUrl: \"/cosmos.crypto.multisig.v1beta1.CompactBitArray\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.extraBitsStored !== 0) {\n            writer.uint32(8).uint32(message.extraBitsStored);\n        }\n        if (message.elems.length !== 0) {\n            writer.uint32(18).bytes(message.elems);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCompactBitArray();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.extraBitsStored = reader.uint32();\n                    break;\n                case 2:\n                    message.elems = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseCompactBitArray();\n        if ((0, helpers_1.isSet)(object.extraBitsStored))\n            obj.extraBitsStored = Number(object.extraBitsStored);\n        if ((0, helpers_1.isSet)(object.elems))\n            obj.elems = (0, helpers_1.bytesFromBase64)(object.elems);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.extraBitsStored !== undefined && (obj.extraBitsStored = Math.round(message.extraBitsStored));\n        message.elems !== undefined &&\n            (obj.elems = (0, helpers_1.base64FromBytes)(message.elems !== undefined ? message.elems : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseCompactBitArray();\n        message.extraBitsStored = object.extraBitsStored ?? 0;\n        message.elems = object.elems ?? new Uint8Array();\n        return message;\n    },\n};\n//# sourceMappingURL=multisig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvY29zbW9zL2NyeXB0by9tdWx0aXNpZy92MWJldGExL211bHRpc2lnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QjtBQUMxRTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDZHQUFvQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQywrR0FBcUI7QUFDL0MsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hYnViYWtyamltb2gvRGVza3RvcC9Db2RpbmcgU3R1ZmZzL2hhY2thdGhvbi9zZWNyZXQtbmV0d29yay9tZW1lQWlfY29pbl9jcmVhdG9yL2FpLW1lbWUtY29pbi1jcmVhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS9jb3NtanMtdHlwZXNAMC45LjAvbm9kZV9tb2R1bGVzL2Nvc21qcy10eXBlcy9jb3Ntb3MvY3J5cHRvL211bHRpc2lnL3YxYmV0YTEvbXVsdGlzaWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXBhY3RCaXRBcnJheSA9IGV4cG9ydHMuTXVsdGlTaWduYXR1cmUgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBiaW5hcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9iaW5hcnlcIik7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vaGVscGVyc1wiKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJjb3Ntb3MuY3J5cHRvLm11bHRpc2lnLnYxYmV0YTFcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNdWx0aVNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduYXR1cmVzOiBbXSxcbiAgICB9O1xufVxuZXhwb3J0cy5NdWx0aVNpZ25hdHVyZSA9IHtcbiAgICB0eXBlVXJsOiBcIi9jb3Ntb3MuY3J5cHRvLm11bHRpc2lnLnYxYmV0YTEuTXVsdGlTaWduYXR1cmVcIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU11bHRpU2lnbmF0dXJlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VNdWx0aVNpZ25hdHVyZSgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Q/LnNpZ25hdHVyZXMpKVxuICAgICAgICAgICAgb2JqLnNpZ25hdHVyZXMgPSBvYmplY3Quc2lnbmF0dXJlcy5tYXAoKGUpID0+ICgwLCBoZWxwZXJzXzEuYnl0ZXNGcm9tQmFzZTY0KShlKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2lnbmF0dXJlcykge1xuICAgICAgICAgICAgb2JqLnNpZ25hdHVyZXMgPSBtZXNzYWdlLnNpZ25hdHVyZXMubWFwKChlKSA9PiAoMCwgaGVscGVyc18xLmJhc2U2NEZyb21CeXRlcykoZSAhPT0gdW5kZWZpbmVkID8gZSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5zaWduYXR1cmVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU11bHRpU2lnbmF0dXJlKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlcyA9IG9iamVjdC5zaWduYXR1cmVzPy5tYXAoKGUpID0+IGUpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb21wYWN0Qml0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXh0cmFCaXRzU3RvcmVkOiAwLFxuICAgICAgICBlbGVtczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICB9O1xufVxuZXhwb3J0cy5Db21wYWN0Qml0QXJyYXkgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLmNyeXB0by5tdWx0aXNpZy52MWJldGExLkNvbXBhY3RCaXRBcnJheVwiLFxuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBiaW5hcnlfMS5CaW5hcnlXcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZXh0cmFCaXRzU3RvcmVkICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLnVpbnQzMihtZXNzYWdlLmV4dHJhQml0c1N0b3JlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmVsZW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb21wYWN0Qml0QXJyYXkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4dHJhQml0c1N0b3JlZCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1zID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZUNvbXBhY3RCaXRBcnJheSgpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmV4dHJhQml0c1N0b3JlZCkpXG4gICAgICAgICAgICBvYmouZXh0cmFCaXRzU3RvcmVkID0gTnVtYmVyKG9iamVjdC5leHRyYUJpdHNTdG9yZWQpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmVsZW1zKSlcbiAgICAgICAgICAgIG9iai5lbGVtcyA9ICgwLCBoZWxwZXJzXzEuYnl0ZXNGcm9tQmFzZTY0KShvYmplY3QuZWxlbXMpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZXh0cmFCaXRzU3RvcmVkICE9PSB1bmRlZmluZWQgJiYgKG9iai5leHRyYUJpdHNTdG9yZWQgPSBNYXRoLnJvdW5kKG1lc3NhZ2UuZXh0cmFCaXRzU3RvcmVkKSk7XG4gICAgICAgIG1lc3NhZ2UuZWxlbXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5lbGVtcyA9ICgwLCBoZWxwZXJzXzEuYmFzZTY0RnJvbUJ5dGVzKShtZXNzYWdlLmVsZW1zICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmVsZW1zIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29tcGFjdEJpdEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuZXh0cmFCaXRzU3RvcmVkID0gb2JqZWN0LmV4dHJhQml0c1N0b3JlZCA/PyAwO1xuICAgICAgICBtZXNzYWdlLmVsZW1zID0gb2JqZWN0LmVsZW1zID8/IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlzaWcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PrivKey = exports.PubKey = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst binary_1 = __webpack_require__(/*! ../../../binary */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\");\nconst helpers_1 = __webpack_require__(/*! ../../../helpers */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\");\nexports.protobufPackage = \"cosmos.crypto.secp256k1\";\nfunction createBasePubKey() {\n    return {\n        key: new Uint8Array(),\n    };\n}\nexports.PubKey = {\n    typeUrl: \"/cosmos.crypto.secp256k1.PubKey\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePubKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBasePubKey();\n        if ((0, helpers_1.isSet)(object.key))\n            obj.key = (0, helpers_1.bytesFromBase64)(object.key);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePubKey();\n        message.key = object.key ?? new Uint8Array();\n        return message;\n    },\n};\nfunction createBasePrivKey() {\n    return {\n        key: new Uint8Array(),\n    };\n}\nexports.PrivKey = {\n    typeUrl: \"/cosmos.crypto.secp256k1.PrivKey\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBasePrivKey();\n        if ((0, helpers_1.isSet)(object.key))\n            obj.key = (0, helpers_1.bytesFromBase64)(object.key);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = (0, helpers_1.base64FromBytes)(message.key !== undefined ? message.key : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePrivKey();\n        message.key = object.key ?? new Uint8Array();\n        return message;\n    },\n};\n//# sourceMappingURL=keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvY29zbW9zL2NyeXB0by9zZWNwMjU2azEva2V5cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsY0FBYyxHQUFHLHVCQUF1QjtBQUMxRDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDBHQUFpQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyw0R0FBa0I7QUFDNUMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hYnViYWtyamltb2gvRGVza3RvcC9Db2RpbmcgU3R1ZmZzL2hhY2thdGhvbi9zZWNyZXQtbmV0d29yay9tZW1lQWlfY29pbl9jcmVhdG9yL2FpLW1lbWUtY29pbi1jcmVhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS9jb3NtanMtdHlwZXNAMC45LjAvbm9kZV9tb2R1bGVzL2Nvc21qcy10eXBlcy9jb3Ntb3MvY3J5cHRvL3NlY3AyNTZrMS9rZXlzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcml2S2V5ID0gZXhwb3J0cy5QdWJLZXkgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBiaW5hcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iaW5hcnlcIik7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vaGVscGVyc1wiKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJjb3Ntb3MuY3J5cHRvLnNlY3AyNTZrMVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVB1YktleSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydHMuUHViS2V5ID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy5jcnlwdG8uc2VjcDI1NmsxLlB1YktleVwiLFxuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBiaW5hcnlfMS5CaW5hcnlXcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1YktleSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZVB1YktleSgpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmtleSkpXG4gICAgICAgICAgICBvYmoua2V5ID0gKDAsIGhlbHBlcnNfMS5ieXRlc0Zyb21CYXNlNjQpKG9iamVjdC5rZXkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uua2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoua2V5ID0gKDAsIGhlbHBlcnNfMS5iYXNlNjRGcm9tQnl0ZXMpKG1lc3NhZ2Uua2V5ICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmtleSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1YktleSgpO1xuICAgICAgICBtZXNzYWdlLmtleSA9IG9iamVjdC5rZXkgPz8gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdktleSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydHMuUHJpdktleSA9IHtcbiAgICB0eXBlVXJsOiBcIi9jb3Ntb3MuY3J5cHRvLnNlY3AyNTZrMS5Qcml2S2V5XCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdktleSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZVByaXZLZXkoKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5rZXkpKVxuICAgICAgICAgICAgb2JqLmtleSA9ICgwLCBoZWxwZXJzXzEuYnl0ZXNGcm9tQmFzZTY0KShvYmplY3Qua2V5KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmtleSA9ICgwLCBoZWxwZXJzXzEuYmFzZTY0RnJvbUJ5dGVzKShtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5rZXkgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2S2V5KCk7XG4gICAgICAgIG1lc3NhZ2Uua2V5ID0gb2JqZWN0LmtleSA/PyBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SignatureDescriptor_Data_Multi = exports.SignatureDescriptor_Data_Single = exports.SignatureDescriptor_Data = exports.SignatureDescriptor = exports.SignatureDescriptors = exports.signModeToJSON = exports.signModeFromJSON = exports.SignMode = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst multisig_1 = __webpack_require__(/*! ../../../crypto/multisig/v1beta1/multisig */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js\");\nconst any_1 = __webpack_require__(/*! ../../../../google/protobuf/any */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/google/protobuf/any.js\");\nconst binary_1 = __webpack_require__(/*! ../../../../binary */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\");\nconst helpers_1 = __webpack_require__(/*! ../../../../helpers */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\");\nexports.protobufPackage = \"cosmos.tx.signing.v1beta1\";\n/**\n * SignMode represents a signing mode with its own security guarantees.\n *\n * This enum should be considered a registry of all known sign modes\n * in the Cosmos ecosystem. Apps are not expected to support all known\n * sign modes. Apps that would like to support custom  sign modes are\n * encouraged to open a small PR against this file to add a new case\n * to this SignMode enum describing their sign mode so that different\n * apps have a consistent version of this enum.\n */\nvar SignMode;\n(function (SignMode) {\n    /**\n     * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\n     * rejected.\n     */\n    SignMode[SignMode[\"SIGN_MODE_UNSPECIFIED\"] = 0] = \"SIGN_MODE_UNSPECIFIED\";\n    /**\n     * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\n     * verified with raw bytes from Tx.\n     */\n    SignMode[SignMode[\"SIGN_MODE_DIRECT\"] = 1] = \"SIGN_MODE_DIRECT\";\n    /**\n     * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some\n     * human-readable textual representation on top of the binary representation\n     * from SIGN_MODE_DIRECT. It is currently not supported.\n     */\n    SignMode[SignMode[\"SIGN_MODE_TEXTUAL\"] = 2] = \"SIGN_MODE_TEXTUAL\";\n    /**\n     * SIGN_MODE_DIRECT_AUX - SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\n     * SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\n     * require signers signing over other signers' `signer_info`. It also allows\n     * for adding Tips in transactions.\n     *\n     * Since: cosmos-sdk 0.46\n     */\n    SignMode[SignMode[\"SIGN_MODE_DIRECT_AUX\"] = 3] = \"SIGN_MODE_DIRECT_AUX\";\n    /**\n     * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\n     * Amino JSON and will be removed in the future.\n     */\n    SignMode[SignMode[\"SIGN_MODE_LEGACY_AMINO_JSON\"] = 127] = \"SIGN_MODE_LEGACY_AMINO_JSON\";\n    /**\n     * SIGN_MODE_EIP_191 - SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\n     * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191\n     *\n     * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\n     * but is not implemented on the SDK by default. To enable EIP-191, you need\n     * to pass a custom `TxConfig` that has an implementation of\n     * `SignModeHandler` for EIP-191. The SDK may decide to fully support\n     * EIP-191 in the future.\n     *\n     * Since: cosmos-sdk 0.45.2\n     */\n    SignMode[SignMode[\"SIGN_MODE_EIP_191\"] = 191] = \"SIGN_MODE_EIP_191\";\n    SignMode[SignMode[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(SignMode || (exports.SignMode = SignMode = {}));\nfunction signModeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"SIGN_MODE_UNSPECIFIED\":\n            return SignMode.SIGN_MODE_UNSPECIFIED;\n        case 1:\n        case \"SIGN_MODE_DIRECT\":\n            return SignMode.SIGN_MODE_DIRECT;\n        case 2:\n        case \"SIGN_MODE_TEXTUAL\":\n            return SignMode.SIGN_MODE_TEXTUAL;\n        case 3:\n        case \"SIGN_MODE_DIRECT_AUX\":\n            return SignMode.SIGN_MODE_DIRECT_AUX;\n        case 127:\n        case \"SIGN_MODE_LEGACY_AMINO_JSON\":\n            return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n        case 191:\n        case \"SIGN_MODE_EIP_191\":\n            return SignMode.SIGN_MODE_EIP_191;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return SignMode.UNRECOGNIZED;\n    }\n}\nexports.signModeFromJSON = signModeFromJSON;\nfunction signModeToJSON(object) {\n    switch (object) {\n        case SignMode.SIGN_MODE_UNSPECIFIED:\n            return \"SIGN_MODE_UNSPECIFIED\";\n        case SignMode.SIGN_MODE_DIRECT:\n            return \"SIGN_MODE_DIRECT\";\n        case SignMode.SIGN_MODE_TEXTUAL:\n            return \"SIGN_MODE_TEXTUAL\";\n        case SignMode.SIGN_MODE_DIRECT_AUX:\n            return \"SIGN_MODE_DIRECT_AUX\";\n        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:\n            return \"SIGN_MODE_LEGACY_AMINO_JSON\";\n        case SignMode.SIGN_MODE_EIP_191:\n            return \"SIGN_MODE_EIP_191\";\n        case SignMode.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nexports.signModeToJSON = signModeToJSON;\nfunction createBaseSignatureDescriptors() {\n    return {\n        signatures: [],\n    };\n}\nexports.SignatureDescriptors = {\n    typeUrl: \"/cosmos.tx.signing.v1beta1.SignatureDescriptors\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        for (const v of message.signatures) {\n            exports.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignatureDescriptors();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signatures.push(exports.SignatureDescriptor.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseSignatureDescriptors();\n        if (Array.isArray(object?.signatures))\n            obj.signatures = object.signatures.map((e) => exports.SignatureDescriptor.fromJSON(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => (e ? exports.SignatureDescriptor.toJSON(e) : undefined));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignatureDescriptors();\n        message.signatures = object.signatures?.map((e) => exports.SignatureDescriptor.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseSignatureDescriptor() {\n    return {\n        publicKey: undefined,\n        data: undefined,\n        sequence: BigInt(0),\n    };\n}\nexports.SignatureDescriptor = {\n    typeUrl: \"/cosmos.tx.signing.v1beta1.SignatureDescriptor\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.publicKey !== undefined) {\n            any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.data !== undefined) {\n            exports.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.sequence !== BigInt(0)) {\n            writer.uint32(24).uint64(message.sequence);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignatureDescriptor();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.publicKey = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.data = exports.SignatureDescriptor_Data.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.sequence = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseSignatureDescriptor();\n        if ((0, helpers_1.isSet)(object.publicKey))\n            obj.publicKey = any_1.Any.fromJSON(object.publicKey);\n        if ((0, helpers_1.isSet)(object.data))\n            obj.data = exports.SignatureDescriptor_Data.fromJSON(object.data);\n        if ((0, helpers_1.isSet)(object.sequence))\n            obj.sequence = BigInt(object.sequence.toString());\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);\n        message.data !== undefined &&\n            (obj.data = message.data ? exports.SignatureDescriptor_Data.toJSON(message.data) : undefined);\n        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignatureDescriptor();\n        if (object.publicKey !== undefined && object.publicKey !== null) {\n            message.publicKey = any_1.Any.fromPartial(object.publicKey);\n        }\n        if (object.data !== undefined && object.data !== null) {\n            message.data = exports.SignatureDescriptor_Data.fromPartial(object.data);\n        }\n        if (object.sequence !== undefined && object.sequence !== null) {\n            message.sequence = BigInt(object.sequence.toString());\n        }\n        return message;\n    },\n};\nfunction createBaseSignatureDescriptor_Data() {\n    return {\n        single: undefined,\n        multi: undefined,\n    };\n}\nexports.SignatureDescriptor_Data = {\n    typeUrl: \"/cosmos.tx.signing.v1beta1.Data\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.single !== undefined) {\n            exports.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.multi !== undefined) {\n            exports.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignatureDescriptor_Data();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.single = exports.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.multi = exports.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseSignatureDescriptor_Data();\n        if ((0, helpers_1.isSet)(object.single))\n            obj.single = exports.SignatureDescriptor_Data_Single.fromJSON(object.single);\n        if ((0, helpers_1.isSet)(object.multi))\n            obj.multi = exports.SignatureDescriptor_Data_Multi.fromJSON(object.multi);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.single !== undefined &&\n            (obj.single = message.single ? exports.SignatureDescriptor_Data_Single.toJSON(message.single) : undefined);\n        message.multi !== undefined &&\n            (obj.multi = message.multi ? exports.SignatureDescriptor_Data_Multi.toJSON(message.multi) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignatureDescriptor_Data();\n        if (object.single !== undefined && object.single !== null) {\n            message.single = exports.SignatureDescriptor_Data_Single.fromPartial(object.single);\n        }\n        if (object.multi !== undefined && object.multi !== null) {\n            message.multi = exports.SignatureDescriptor_Data_Multi.fromPartial(object.multi);\n        }\n        return message;\n    },\n};\nfunction createBaseSignatureDescriptor_Data_Single() {\n    return {\n        mode: 0,\n        signature: new Uint8Array(),\n    };\n}\nexports.SignatureDescriptor_Data_Single = {\n    typeUrl: \"/cosmos.tx.signing.v1beta1.Single\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.mode !== 0) {\n            writer.uint32(8).int32(message.mode);\n        }\n        if (message.signature.length !== 0) {\n            writer.uint32(18).bytes(message.signature);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignatureDescriptor_Data_Single();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.mode = reader.int32();\n                    break;\n                case 2:\n                    message.signature = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseSignatureDescriptor_Data_Single();\n        if ((0, helpers_1.isSet)(object.mode))\n            obj.mode = signModeFromJSON(object.mode);\n        if ((0, helpers_1.isSet)(object.signature))\n            obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n        message.signature !== undefined &&\n            (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== undefined ? message.signature : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignatureDescriptor_Data_Single();\n        message.mode = object.mode ?? 0;\n        message.signature = object.signature ?? new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSignatureDescriptor_Data_Multi() {\n    return {\n        bitarray: undefined,\n        signatures: [],\n    };\n}\nexports.SignatureDescriptor_Data_Multi = {\n    typeUrl: \"/cosmos.tx.signing.v1beta1.Multi\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.bitarray !== undefined) {\n            multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.signatures) {\n            exports.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignatureDescriptor_Data_Multi();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.signatures.push(exports.SignatureDescriptor_Data.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseSignatureDescriptor_Data_Multi();\n        if ((0, helpers_1.isSet)(object.bitarray))\n            obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);\n        if (Array.isArray(object?.signatures))\n            obj.signatures = object.signatures.map((e) => exports.SignatureDescriptor_Data.fromJSON(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bitarray !== undefined &&\n            (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : undefined);\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => (e ? exports.SignatureDescriptor_Data.toJSON(e) : undefined));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignatureDescriptor_Data_Multi();\n        if (object.bitarray !== undefined && object.bitarray !== null) {\n            message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);\n        }\n        message.signatures = object.signatures?.map((e) => exports.SignatureDescriptor_Data.fromPartial(e)) || [];\n        return message;\n    },\n};\n//# sourceMappingURL=signing.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvY29zbW9zL3R4L3NpZ25pbmcvdjFiZXRhMS9zaWduaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNDQUFzQyxHQUFHLHVDQUF1QyxHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDRCQUE0QixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLGdCQUFnQixHQUFHLHVCQUF1QjtBQUNqUjtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHFLQUEyQztBQUN0RSxjQUFjLG1CQUFPLENBQUMsdUlBQWlDO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLDZHQUFvQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQywrR0FBcUI7QUFDL0MsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGVBQWUsZ0JBQWdCLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hYnViYWtyamltb2gvRGVza3RvcC9Db2RpbmcgU3R1ZmZzL2hhY2thdGhvbi9zZWNyZXQtbmV0d29yay9tZW1lQWlfY29pbl9jcmVhdG9yL2FpLW1lbWUtY29pbi1jcmVhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS9jb3NtanMtdHlwZXNAMC45LjAvbm9kZV9tb2R1bGVzL2Nvc21qcy10eXBlcy9jb3Ntb3MvdHgvc2lnbmluZy92MWJldGExL3NpZ25pbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aSA9IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhX1NpbmdsZSA9IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhID0gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yID0gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9ycyA9IGV4cG9ydHMuc2lnbk1vZGVUb0pTT04gPSBleHBvcnRzLnNpZ25Nb2RlRnJvbUpTT04gPSBleHBvcnRzLlNpZ25Nb2RlID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgbXVsdGlzaWdfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jcnlwdG8vbXVsdGlzaWcvdjFiZXRhMS9tdWx0aXNpZ1wiKTtcbmNvbnN0IGFueV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi9hbnlcIik7XG5jb25zdCBiaW5hcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9iaW5hcnlcIik7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vaGVscGVyc1wiKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJjb3Ntb3MudHguc2lnbmluZy52MWJldGExXCI7XG4vKipcbiAqIFNpZ25Nb2RlIHJlcHJlc2VudHMgYSBzaWduaW5nIG1vZGUgd2l0aCBpdHMgb3duIHNlY3VyaXR5IGd1YXJhbnRlZXMuXG4gKlxuICogVGhpcyBlbnVtIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgcmVnaXN0cnkgb2YgYWxsIGtub3duIHNpZ24gbW9kZXNcbiAqIGluIHRoZSBDb3Ntb3MgZWNvc3lzdGVtLiBBcHBzIGFyZSBub3QgZXhwZWN0ZWQgdG8gc3VwcG9ydCBhbGwga25vd25cbiAqIHNpZ24gbW9kZXMuIEFwcHMgdGhhdCB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgY3VzdG9tICBzaWduIG1vZGVzIGFyZVxuICogZW5jb3VyYWdlZCB0byBvcGVuIGEgc21hbGwgUFIgYWdhaW5zdCB0aGlzIGZpbGUgdG8gYWRkIGEgbmV3IGNhc2VcbiAqIHRvIHRoaXMgU2lnbk1vZGUgZW51bSBkZXNjcmliaW5nIHRoZWlyIHNpZ24gbW9kZSBzbyB0aGF0IGRpZmZlcmVudFxuICogYXBwcyBoYXZlIGEgY29uc2lzdGVudCB2ZXJzaW9uIG9mIHRoaXMgZW51bS5cbiAqL1xudmFyIFNpZ25Nb2RlO1xuKGZ1bmN0aW9uIChTaWduTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFNJR05fTU9ERV9VTlNQRUNJRklFRCAtIFNJR05fTU9ERV9VTlNQRUNJRklFRCBzcGVjaWZpZXMgYW4gdW5rbm93biBzaWduaW5nIG1vZGUgYW5kIHdpbGwgYmVcbiAgICAgKiByZWplY3RlZC5cbiAgICAgKi9cbiAgICBTaWduTW9kZVtTaWduTW9kZVtcIlNJR05fTU9ERV9VTlNQRUNJRklFRFwiXSA9IDBdID0gXCJTSUdOX01PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTSUdOX01PREVfRElSRUNUIC0gU0lHTl9NT0RFX0RJUkVDVCBzcGVjaWZpZXMgYSBzaWduaW5nIG1vZGUgd2hpY2ggdXNlcyBTaWduRG9jIGFuZCBpc1xuICAgICAqIHZlcmlmaWVkIHdpdGggcmF3IGJ5dGVzIGZyb20gVHguXG4gICAgICovXG4gICAgU2lnbk1vZGVbU2lnbk1vZGVbXCJTSUdOX01PREVfRElSRUNUXCJdID0gMV0gPSBcIlNJR05fTU9ERV9ESVJFQ1RcIjtcbiAgICAvKipcbiAgICAgKiBTSUdOX01PREVfVEVYVFVBTCAtIFNJR05fTU9ERV9URVhUVUFMIGlzIGEgZnV0dXJlIHNpZ25pbmcgbW9kZSB0aGF0IHdpbGwgdmVyaWZ5IHNvbWVcbiAgICAgKiBodW1hbi1yZWFkYWJsZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9uIHRvcCBvZiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uXG4gICAgICogZnJvbSBTSUdOX01PREVfRElSRUNULiBJdCBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBTaWduTW9kZVtTaWduTW9kZVtcIlNJR05fTU9ERV9URVhUVUFMXCJdID0gMl0gPSBcIlNJR05fTU9ERV9URVhUVUFMXCI7XG4gICAgLyoqXG4gICAgICogU0lHTl9NT0RFX0RJUkVDVF9BVVggLSBTSUdOX01PREVfRElSRUNUX0FVWCBzcGVjaWZpZXMgYSBzaWduaW5nIG1vZGUgd2hpY2ggdXNlc1xuICAgICAqIFNpZ25Eb2NEaXJlY3RBdXguIEFzIG9wcG9zZWQgdG8gU0lHTl9NT0RFX0RJUkVDVCwgdGhpcyBzaWduIG1vZGUgZG9lcyBub3RcbiAgICAgKiByZXF1aXJlIHNpZ25lcnMgc2lnbmluZyBvdmVyIG90aGVyIHNpZ25lcnMnIGBzaWduZXJfaW5mb2AuIEl0IGFsc28gYWxsb3dzXG4gICAgICogZm9yIGFkZGluZyBUaXBzIGluIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIFNpbmNlOiBjb3Ntb3Mtc2RrIDAuNDZcbiAgICAgKi9cbiAgICBTaWduTW9kZVtTaWduTW9kZVtcIlNJR05fTU9ERV9ESVJFQ1RfQVVYXCJdID0gM10gPSBcIlNJR05fTU9ERV9ESVJFQ1RfQVVYXCI7XG4gICAgLyoqXG4gICAgICogU0lHTl9NT0RFX0xFR0FDWV9BTUlOT19KU09OIC0gU0lHTl9NT0RFX0xFR0FDWV9BTUlOT19KU09OIGlzIGEgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgbW9kZSB3aGljaCB1c2VzXG4gICAgICogQW1pbm8gSlNPTiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICovXG4gICAgU2lnbk1vZGVbU2lnbk1vZGVbXCJTSUdOX01PREVfTEVHQUNZX0FNSU5PX0pTT05cIl0gPSAxMjddID0gXCJTSUdOX01PREVfTEVHQUNZX0FNSU5PX0pTT05cIjtcbiAgICAvKipcbiAgICAgKiBTSUdOX01PREVfRUlQXzE5MSAtIFNJR05fTU9ERV9FSVBfMTkxIHNwZWNpZmllcyB0aGUgc2lnbiBtb2RlIGZvciBFSVAgMTkxIHNpZ25pbmcgb24gdGhlIENvc21vc1xuICAgICAqIFNESy4gUmVmOiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE5MVxuICAgICAqXG4gICAgICogQ3VycmVudGx5LCBTSUdOX01PREVfRUlQXzE5MSBpcyByZWdpc3RlcmVkIGFzIGEgU2lnbk1vZGUgZW51bSB2YXJpYW50LFxuICAgICAqIGJ1dCBpcyBub3QgaW1wbGVtZW50ZWQgb24gdGhlIFNESyBieSBkZWZhdWx0LiBUbyBlbmFibGUgRUlQLTE5MSwgeW91IG5lZWRcbiAgICAgKiB0byBwYXNzIGEgY3VzdG9tIGBUeENvbmZpZ2AgdGhhdCBoYXMgYW4gaW1wbGVtZW50YXRpb24gb2ZcbiAgICAgKiBgU2lnbk1vZGVIYW5kbGVyYCBmb3IgRUlQLTE5MS4gVGhlIFNESyBtYXkgZGVjaWRlIHRvIGZ1bGx5IHN1cHBvcnRcbiAgICAgKiBFSVAtMTkxIGluIHRoZSBmdXR1cmUuXG4gICAgICpcbiAgICAgKiBTaW5jZTogY29zbW9zLXNkayAwLjQ1LjJcbiAgICAgKi9cbiAgICBTaWduTW9kZVtTaWduTW9kZVtcIlNJR05fTU9ERV9FSVBfMTkxXCJdID0gMTkxXSA9IFwiU0lHTl9NT0RFX0VJUF8xOTFcIjtcbiAgICBTaWduTW9kZVtTaWduTW9kZVtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShTaWduTW9kZSB8fCAoZXhwb3J0cy5TaWduTW9kZSA9IFNpZ25Nb2RlID0ge30pKTtcbmZ1bmN0aW9uIHNpZ25Nb2RlRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiU0lHTl9NT0RFX1VOU1BFQ0lGSUVEXCI6XG4gICAgICAgICAgICByZXR1cm4gU2lnbk1vZGUuU0lHTl9NT0RFX1VOU1BFQ0lGSUVEO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJTSUdOX01PREVfRElSRUNUXCI6XG4gICAgICAgICAgICByZXR1cm4gU2lnbk1vZGUuU0lHTl9NT0RFX0RJUkVDVDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiU0lHTl9NT0RFX1RFWFRVQUxcIjpcbiAgICAgICAgICAgIHJldHVybiBTaWduTW9kZS5TSUdOX01PREVfVEVYVFVBTDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIFwiU0lHTl9NT0RFX0RJUkVDVF9BVVhcIjpcbiAgICAgICAgICAgIHJldHVybiBTaWduTW9kZS5TSUdOX01PREVfRElSRUNUX0FVWDtcbiAgICAgICAgY2FzZSAxMjc6XG4gICAgICAgIGNhc2UgXCJTSUdOX01PREVfTEVHQUNZX0FNSU5PX0pTT05cIjpcbiAgICAgICAgICAgIHJldHVybiBTaWduTW9kZS5TSUdOX01PREVfTEVHQUNZX0FNSU5PX0pTT047XG4gICAgICAgIGNhc2UgMTkxOlxuICAgICAgICBjYXNlIFwiU0lHTl9NT0RFX0VJUF8xOTFcIjpcbiAgICAgICAgICAgIHJldHVybiBTaWduTW9kZS5TSUdOX01PREVfRUlQXzE5MTtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFNpZ25Nb2RlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLnNpZ25Nb2RlRnJvbUpTT04gPSBzaWduTW9kZUZyb21KU09OO1xuZnVuY3Rpb24gc2lnbk1vZGVUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBTaWduTW9kZS5TSUdOX01PREVfVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJTSUdOX01PREVfVU5TUEVDSUZJRURcIjtcbiAgICAgICAgY2FzZSBTaWduTW9kZS5TSUdOX01PREVfRElSRUNUOlxuICAgICAgICAgICAgcmV0dXJuIFwiU0lHTl9NT0RFX0RJUkVDVFwiO1xuICAgICAgICBjYXNlIFNpZ25Nb2RlLlNJR05fTU9ERV9URVhUVUFMOlxuICAgICAgICAgICAgcmV0dXJuIFwiU0lHTl9NT0RFX1RFWFRVQUxcIjtcbiAgICAgICAgY2FzZSBTaWduTW9kZS5TSUdOX01PREVfRElSRUNUX0FVWDpcbiAgICAgICAgICAgIHJldHVybiBcIlNJR05fTU9ERV9ESVJFQ1RfQVVYXCI7XG4gICAgICAgIGNhc2UgU2lnbk1vZGUuU0lHTl9NT0RFX0xFR0FDWV9BTUlOT19KU09OOlxuICAgICAgICAgICAgcmV0dXJuIFwiU0lHTl9NT0RFX0xFR0FDWV9BTUlOT19KU09OXCI7XG4gICAgICAgIGNhc2UgU2lnbk1vZGUuU0lHTl9NT0RFX0VJUF8xOTE6XG4gICAgICAgICAgICByZXR1cm4gXCJTSUdOX01PREVfRUlQXzE5MVwiO1xuICAgICAgICBjYXNlIFNpZ25Nb2RlLlVOUkVDT0dOSVpFRDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOUkVDT0dOSVpFRFwiO1xuICAgIH1cbn1cbmV4cG9ydHMuc2lnbk1vZGVUb0pTT04gPSBzaWduTW9kZVRvSlNPTjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduYXR1cmVEZXNjcmlwdG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduYXR1cmVzOiBbXSxcbiAgICB9O1xufVxuZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9ycyA9IHtcbiAgICB0eXBlVXJsOiBcIi9jb3Ntb3MudHguc2lnbmluZy52MWJldGExLlNpZ25hdHVyZURlc2NyaXB0b3JzXCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3IuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcnMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZXMucHVzaChleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3IuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JzKCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdD8uc2lnbmF0dXJlcykpXG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IG9iamVjdC5zaWduYXR1cmVzLm1hcCgoZSkgPT4gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yLmZyb21KU09OKGUpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IG1lc3NhZ2Uuc2lnbmF0dXJlcy5tYXAoKGUpID0+IChlID8gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnNpZ25hdHVyZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcnMoKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzID0gb2JqZWN0LnNpZ25hdHVyZXM/Lm1hcCgoZSkgPT4gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBzZXF1ZW5jZTogQmlnSW50KDApLFxuICAgIH07XG59XG5leHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3IgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLnR4LnNpZ25pbmcudjFiZXRhMS5TaWduYXR1cmVEZXNjcmlwdG9yXCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wdWJsaWNLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYW55XzEuQW55LmVuY29kZShtZXNzYWdlLnB1YmxpY0tleSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhLmVuY29kZShtZXNzYWdlLmRhdGEsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2UgIT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDY0KG1lc3NhZ2Uuc2VxdWVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3IoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSA9IGFueV8xLkFueS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZSA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcigpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LnB1YmxpY0tleSkpXG4gICAgICAgICAgICBvYmoucHVibGljS2V5ID0gYW55XzEuQW55LmZyb21KU09OKG9iamVjdC5wdWJsaWNLZXkpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmRhdGEpKVxuICAgICAgICAgICAgb2JqLmRhdGEgPSBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YS5mcm9tSlNPTihvYmplY3QuZGF0YSk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3Quc2VxdWVuY2UpKVxuICAgICAgICAgICAgb2JqLnNlcXVlbmNlID0gQmlnSW50KG9iamVjdC5zZXF1ZW5jZS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnB1YmxpY0tleSA9IG1lc3NhZ2UucHVibGljS2V5ID8gYW55XzEuQW55LnRvSlNPTihtZXNzYWdlLnB1YmxpY0tleSkgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kYXRhID0gbWVzc2FnZS5kYXRhID8gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEudG9KU09OKG1lc3NhZ2UuZGF0YSkgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnNlcXVlbmNlICE9PSB1bmRlZmluZWQgJiYgKG9iai5zZXF1ZW5jZSA9IChtZXNzYWdlLnNlcXVlbmNlIHx8IEJpZ0ludCgwKSkudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmVEZXNjcmlwdG9yKCk7XG4gICAgICAgIGlmIChvYmplY3QucHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnB1YmxpY0tleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5wdWJsaWNLZXkgPSBhbnlfMS5BbnkuZnJvbVBhcnRpYWwob2JqZWN0LnB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5kYXRhICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhLmZyb21QYXJ0aWFsKG9iamVjdC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnNlcXVlbmNlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlcXVlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNlcXVlbmNlID0gQmlnSW50KG9iamVjdC5zZXF1ZW5jZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2luZ2xlOiB1bmRlZmluZWQsXG4gICAgICAgIG11bHRpOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy50eC5zaWduaW5nLnYxYmV0YTEuRGF0YVwiLFxuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBiaW5hcnlfMS5CaW5hcnlXcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2luZ2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhX1NpbmdsZS5lbmNvZGUobWVzc2FnZS5zaW5nbGUsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubXVsdGkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfTXVsdGkuZW5jb2RlKG1lc3NhZ2UubXVsdGksIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaW5nbGUgPSBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm11bHRpID0gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfTXVsdGkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhKCk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3Quc2luZ2xlKSlcbiAgICAgICAgICAgIG9iai5zaW5nbGUgPSBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUuZnJvbUpTT04ob2JqZWN0LnNpbmdsZSk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QubXVsdGkpKVxuICAgICAgICAgICAgb2JqLm11bHRpID0gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfTXVsdGkuZnJvbUpTT04ob2JqZWN0Lm11bHRpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnNpbmdsZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNpbmdsZSA9IG1lc3NhZ2Uuc2luZ2xlID8gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfU2luZ2xlLnRvSlNPTihtZXNzYWdlLnNpbmdsZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLm11bHRpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubXVsdGkgPSBtZXNzYWdlLm11bHRpID8gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfTXVsdGkudG9KU09OKG1lc3NhZ2UubXVsdGkpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YSgpO1xuICAgICAgICBpZiAob2JqZWN0LnNpbmdsZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaW5nbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2luZ2xlID0gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfU2luZ2xlLmZyb21QYXJ0aWFsKG9iamVjdC5zaW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QubXVsdGkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubXVsdGkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubXVsdGkgPSBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aS5mcm9tUGFydGlhbChvYmplY3QubXVsdGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbW9kZTogMCxcbiAgICAgICAgc2lnbmF0dXJlOiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLnR4LnNpZ25pbmcudjFiZXRhMS5TaW5nbGVcIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm1vZGUgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuaW50MzIobWVzc2FnZS5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhX1NpbmdsZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubW9kZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUoKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5tb2RlKSlcbiAgICAgICAgICAgIG9iai5tb2RlID0gc2lnbk1vZGVGcm9tSlNPTihvYmplY3QubW9kZSk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3Quc2lnbmF0dXJlKSlcbiAgICAgICAgICAgIG9iai5zaWduYXR1cmUgPSAoMCwgaGVscGVyc18xLmJ5dGVzRnJvbUJhc2U2NCkob2JqZWN0LnNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5tb2RlICE9PSB1bmRlZmluZWQgJiYgKG9iai5tb2RlID0gc2lnbk1vZGVUb0pTT04obWVzc2FnZS5tb2RlKSk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2lnbmF0dXJlID0gKDAsIGhlbHBlcnNfMS5iYXNlNjRGcm9tQnl0ZXMpKG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnNpZ25hdHVyZSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUoKTtcbiAgICAgICAgbWVzc2FnZS5tb2RlID0gb2JqZWN0Lm1vZGUgPz8gMDtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPSBvYmplY3Quc2lnbmF0dXJlID8/IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiaXRhcnJheTogdW5kZWZpbmVkLFxuICAgICAgICBzaWduYXR1cmVzOiBbXSxcbiAgICB9O1xufVxuZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfTXVsdGkgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLnR4LnNpZ25pbmcudjFiZXRhMS5NdWx0aVwiLFxuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBiaW5hcnlfMS5CaW5hcnlXcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYml0YXJyYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbXVsdGlzaWdfMS5Db21wYWN0Qml0QXJyYXkuZW5jb2RlKG1lc3NhZ2UuYml0YXJyYXksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2Uuc2lnbmF0dXJlcykge1xuICAgICAgICAgICAgZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhX011bHRpKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iaXRhcnJheSA9IG11bHRpc2lnXzEuQ29tcGFjdEJpdEFycmF5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzLnB1c2goZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aSgpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmJpdGFycmF5KSlcbiAgICAgICAgICAgIG9iai5iaXRhcnJheSA9IG11bHRpc2lnXzEuQ29tcGFjdEJpdEFycmF5LmZyb21KU09OKG9iamVjdC5iaXRhcnJheSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdD8uc2lnbmF0dXJlcykpXG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IG9iamVjdC5zaWduYXR1cmVzLm1hcCgoZSkgPT4gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEuZnJvbUpTT04oZSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYml0YXJyYXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5iaXRhcnJheSA9IG1lc3NhZ2UuYml0YXJyYXkgPyBtdWx0aXNpZ18xLkNvbXBhY3RCaXRBcnJheS50b0pTT04obWVzc2FnZS5iaXRhcnJheSkgOiB1bmRlZmluZWQpO1xuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IG1lc3NhZ2Uuc2lnbmF0dXJlcy5tYXAoKGUpID0+IChlID8gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEudG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfTXVsdGkoKTtcbiAgICAgICAgaWYgKG9iamVjdC5iaXRhcnJheSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5iaXRhcnJheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5iaXRhcnJheSA9IG11bHRpc2lnXzEuQ29tcGFjdEJpdEFycmF5LmZyb21QYXJ0aWFsKG9iamVjdC5iaXRhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzID0gb2JqZWN0LnNpZ25hdHVyZXM/Lm1hcCgoZSkgPT4gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEuZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25pbmcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AuxSignerData = exports.Tip = exports.Fee = exports.ModeInfo_Multi = exports.ModeInfo_Single = exports.ModeInfo = exports.SignerInfo = exports.AuthInfo = exports.TxBody = exports.SignDocDirectAux = exports.SignDoc = exports.TxRaw = exports.Tx = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/google/protobuf/any.js\");\nconst signing_1 = __webpack_require__(/*! ../signing/v1beta1/signing */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js\");\nconst multisig_1 = __webpack_require__(/*! ../../crypto/multisig/v1beta1/multisig */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js\");\nconst coin_1 = __webpack_require__(/*! ../../base/v1beta1/coin */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js\");\nconst binary_1 = __webpack_require__(/*! ../../../binary */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\");\nconst helpers_1 = __webpack_require__(/*! ../../../helpers */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\");\nexports.protobufPackage = \"cosmos.tx.v1beta1\";\nfunction createBaseTx() {\n    return {\n        body: undefined,\n        authInfo: undefined,\n        signatures: [],\n    };\n}\nexports.Tx = {\n    typeUrl: \"/cosmos.tx.v1beta1.Tx\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.body !== undefined) {\n            exports.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.authInfo !== undefined) {\n            exports.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();\n        }\n        for (const v of message.signatures) {\n            writer.uint32(26).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTx();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.body = exports.TxBody.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.authInfo = exports.AuthInfo.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.signatures.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseTx();\n        if ((0, helpers_1.isSet)(object.body))\n            obj.body = exports.TxBody.fromJSON(object.body);\n        if ((0, helpers_1.isSet)(object.authInfo))\n            obj.authInfo = exports.AuthInfo.fromJSON(object.authInfo);\n        if (Array.isArray(object?.signatures))\n            obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.body !== undefined && (obj.body = message.body ? exports.TxBody.toJSON(message.body) : undefined);\n        message.authInfo !== undefined &&\n            (obj.authInfo = message.authInfo ? exports.AuthInfo.toJSON(message.authInfo) : undefined);\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseTx();\n        if (object.body !== undefined && object.body !== null) {\n            message.body = exports.TxBody.fromPartial(object.body);\n        }\n        if (object.authInfo !== undefined && object.authInfo !== null) {\n            message.authInfo = exports.AuthInfo.fromPartial(object.authInfo);\n        }\n        message.signatures = object.signatures?.map((e) => e) || [];\n        return message;\n    },\n};\nfunction createBaseTxRaw() {\n    return {\n        bodyBytes: new Uint8Array(),\n        authInfoBytes: new Uint8Array(),\n        signatures: [],\n    };\n}\nexports.TxRaw = {\n    typeUrl: \"/cosmos.tx.v1beta1.TxRaw\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.bodyBytes.length !== 0) {\n            writer.uint32(10).bytes(message.bodyBytes);\n        }\n        if (message.authInfoBytes.length !== 0) {\n            writer.uint32(18).bytes(message.authInfoBytes);\n        }\n        for (const v of message.signatures) {\n            writer.uint32(26).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxRaw();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bodyBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.authInfoBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.signatures.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseTxRaw();\n        if ((0, helpers_1.isSet)(object.bodyBytes))\n            obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);\n        if ((0, helpers_1.isSet)(object.authInfoBytes))\n            obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);\n        if (Array.isArray(object?.signatures))\n            obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bodyBytes !== undefined &&\n            (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));\n        message.authInfoBytes !== undefined &&\n            (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseTxRaw();\n        message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();\n        message.signatures = object.signatures?.map((e) => e) || [];\n        return message;\n    },\n};\nfunction createBaseSignDoc() {\n    return {\n        bodyBytes: new Uint8Array(),\n        authInfoBytes: new Uint8Array(),\n        chainId: \"\",\n        accountNumber: BigInt(0),\n    };\n}\nexports.SignDoc = {\n    typeUrl: \"/cosmos.tx.v1beta1.SignDoc\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.bodyBytes.length !== 0) {\n            writer.uint32(10).bytes(message.bodyBytes);\n        }\n        if (message.authInfoBytes.length !== 0) {\n            writer.uint32(18).bytes(message.authInfoBytes);\n        }\n        if (message.chainId !== \"\") {\n            writer.uint32(26).string(message.chainId);\n        }\n        if (message.accountNumber !== BigInt(0)) {\n            writer.uint32(32).uint64(message.accountNumber);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignDoc();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bodyBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.authInfoBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.chainId = reader.string();\n                    break;\n                case 4:\n                    message.accountNumber = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseSignDoc();\n        if ((0, helpers_1.isSet)(object.bodyBytes))\n            obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);\n        if ((0, helpers_1.isSet)(object.authInfoBytes))\n            obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);\n        if ((0, helpers_1.isSet)(object.chainId))\n            obj.chainId = String(object.chainId);\n        if ((0, helpers_1.isSet)(object.accountNumber))\n            obj.accountNumber = BigInt(object.accountNumber.toString());\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bodyBytes !== undefined &&\n            (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));\n        message.authInfoBytes !== undefined &&\n            (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));\n        message.chainId !== undefined && (obj.chainId = message.chainId);\n        message.accountNumber !== undefined &&\n            (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignDoc();\n        message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();\n        message.chainId = object.chainId ?? \"\";\n        if (object.accountNumber !== undefined && object.accountNumber !== null) {\n            message.accountNumber = BigInt(object.accountNumber.toString());\n        }\n        return message;\n    },\n};\nfunction createBaseSignDocDirectAux() {\n    return {\n        bodyBytes: new Uint8Array(),\n        publicKey: undefined,\n        chainId: \"\",\n        accountNumber: BigInt(0),\n        sequence: BigInt(0),\n        tip: undefined,\n    };\n}\nexports.SignDocDirectAux = {\n    typeUrl: \"/cosmos.tx.v1beta1.SignDocDirectAux\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.bodyBytes.length !== 0) {\n            writer.uint32(10).bytes(message.bodyBytes);\n        }\n        if (message.publicKey !== undefined) {\n            any_1.Any.encode(message.publicKey, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.chainId !== \"\") {\n            writer.uint32(26).string(message.chainId);\n        }\n        if (message.accountNumber !== BigInt(0)) {\n            writer.uint32(32).uint64(message.accountNumber);\n        }\n        if (message.sequence !== BigInt(0)) {\n            writer.uint32(40).uint64(message.sequence);\n        }\n        if (message.tip !== undefined) {\n            exports.Tip.encode(message.tip, writer.uint32(50).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignDocDirectAux();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bodyBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.publicKey = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.chainId = reader.string();\n                    break;\n                case 4:\n                    message.accountNumber = reader.uint64();\n                    break;\n                case 5:\n                    message.sequence = reader.uint64();\n                    break;\n                case 6:\n                    message.tip = exports.Tip.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseSignDocDirectAux();\n        if ((0, helpers_1.isSet)(object.bodyBytes))\n            obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);\n        if ((0, helpers_1.isSet)(object.publicKey))\n            obj.publicKey = any_1.Any.fromJSON(object.publicKey);\n        if ((0, helpers_1.isSet)(object.chainId))\n            obj.chainId = String(object.chainId);\n        if ((0, helpers_1.isSet)(object.accountNumber))\n            obj.accountNumber = BigInt(object.accountNumber.toString());\n        if ((0, helpers_1.isSet)(object.sequence))\n            obj.sequence = BigInt(object.sequence.toString());\n        if ((0, helpers_1.isSet)(object.tip))\n            obj.tip = exports.Tip.fromJSON(object.tip);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bodyBytes !== undefined &&\n            (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);\n        message.chainId !== undefined && (obj.chainId = message.chainId);\n        message.accountNumber !== undefined &&\n            (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());\n        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());\n        message.tip !== undefined && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignDocDirectAux();\n        message.bodyBytes = object.bodyBytes ?? new Uint8Array();\n        if (object.publicKey !== undefined && object.publicKey !== null) {\n            message.publicKey = any_1.Any.fromPartial(object.publicKey);\n        }\n        message.chainId = object.chainId ?? \"\";\n        if (object.accountNumber !== undefined && object.accountNumber !== null) {\n            message.accountNumber = BigInt(object.accountNumber.toString());\n        }\n        if (object.sequence !== undefined && object.sequence !== null) {\n            message.sequence = BigInt(object.sequence.toString());\n        }\n        if (object.tip !== undefined && object.tip !== null) {\n            message.tip = exports.Tip.fromPartial(object.tip);\n        }\n        return message;\n    },\n};\nfunction createBaseTxBody() {\n    return {\n        messages: [],\n        memo: \"\",\n        timeoutHeight: BigInt(0),\n        extensionOptions: [],\n        nonCriticalExtensionOptions: [],\n    };\n}\nexports.TxBody = {\n    typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        for (const v of message.messages) {\n            any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.memo !== \"\") {\n            writer.uint32(18).string(message.memo);\n        }\n        if (message.timeoutHeight !== BigInt(0)) {\n            writer.uint32(24).uint64(message.timeoutHeight);\n        }\n        for (const v of message.extensionOptions) {\n            any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();\n        }\n        for (const v of message.nonCriticalExtensionOptions) {\n            any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messages.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.memo = reader.string();\n                    break;\n                case 3:\n                    message.timeoutHeight = reader.uint64();\n                    break;\n                case 1023:\n                    message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                case 2047:\n                    message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseTxBody();\n        if (Array.isArray(object?.messages))\n            obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));\n        if ((0, helpers_1.isSet)(object.memo))\n            obj.memo = String(object.memo);\n        if ((0, helpers_1.isSet)(object.timeoutHeight))\n            obj.timeoutHeight = BigInt(object.timeoutHeight.toString());\n        if (Array.isArray(object?.extensionOptions))\n            obj.extensionOptions = object.extensionOptions.map((e) => any_1.Any.fromJSON(e));\n        if (Array.isArray(object?.nonCriticalExtensionOptions))\n            obj.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions.map((e) => any_1.Any.fromJSON(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.messages) {\n            obj.messages = message.messages.map((e) => (e ? any_1.Any.toJSON(e) : undefined));\n        }\n        else {\n            obj.messages = [];\n        }\n        message.memo !== undefined && (obj.memo = message.memo);\n        message.timeoutHeight !== undefined &&\n            (obj.timeoutHeight = (message.timeoutHeight || BigInt(0)).toString());\n        if (message.extensionOptions) {\n            obj.extensionOptions = message.extensionOptions.map((e) => (e ? any_1.Any.toJSON(e) : undefined));\n        }\n        else {\n            obj.extensionOptions = [];\n        }\n        if (message.nonCriticalExtensionOptions) {\n            obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e) => e ? any_1.Any.toJSON(e) : undefined);\n        }\n        else {\n            obj.nonCriticalExtensionOptions = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseTxBody();\n        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];\n        message.memo = object.memo ?? \"\";\n        if (object.timeoutHeight !== undefined && object.timeoutHeight !== null) {\n            message.timeoutHeight = BigInt(object.timeoutHeight.toString());\n        }\n        message.extensionOptions = object.extensionOptions?.map((e) => any_1.Any.fromPartial(e)) || [];\n        message.nonCriticalExtensionOptions =\n            object.nonCriticalExtensionOptions?.map((e) => any_1.Any.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseAuthInfo() {\n    return {\n        signerInfos: [],\n        fee: undefined,\n        tip: undefined,\n    };\n}\nexports.AuthInfo = {\n    typeUrl: \"/cosmos.tx.v1beta1.AuthInfo\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        for (const v of message.signerInfos) {\n            exports.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.fee !== undefined) {\n            exports.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.tip !== undefined) {\n            exports.Tip.encode(message.tip, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAuthInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signerInfos.push(exports.SignerInfo.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.fee = exports.Fee.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.tip = exports.Tip.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseAuthInfo();\n        if (Array.isArray(object?.signerInfos))\n            obj.signerInfos = object.signerInfos.map((e) => exports.SignerInfo.fromJSON(e));\n        if ((0, helpers_1.isSet)(object.fee))\n            obj.fee = exports.Fee.fromJSON(object.fee);\n        if ((0, helpers_1.isSet)(object.tip))\n            obj.tip = exports.Tip.fromJSON(object.tip);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.signerInfos) {\n            obj.signerInfos = message.signerInfos.map((e) => (e ? exports.SignerInfo.toJSON(e) : undefined));\n        }\n        else {\n            obj.signerInfos = [];\n        }\n        message.fee !== undefined && (obj.fee = message.fee ? exports.Fee.toJSON(message.fee) : undefined);\n        message.tip !== undefined && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseAuthInfo();\n        message.signerInfos = object.signerInfos?.map((e) => exports.SignerInfo.fromPartial(e)) || [];\n        if (object.fee !== undefined && object.fee !== null) {\n            message.fee = exports.Fee.fromPartial(object.fee);\n        }\n        if (object.tip !== undefined && object.tip !== null) {\n            message.tip = exports.Tip.fromPartial(object.tip);\n        }\n        return message;\n    },\n};\nfunction createBaseSignerInfo() {\n    return {\n        publicKey: undefined,\n        modeInfo: undefined,\n        sequence: BigInt(0),\n    };\n}\nexports.SignerInfo = {\n    typeUrl: \"/cosmos.tx.v1beta1.SignerInfo\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.publicKey !== undefined) {\n            any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.modeInfo !== undefined) {\n            exports.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.sequence !== BigInt(0)) {\n            writer.uint32(24).uint64(message.sequence);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignerInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.publicKey = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.modeInfo = exports.ModeInfo.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.sequence = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseSignerInfo();\n        if ((0, helpers_1.isSet)(object.publicKey))\n            obj.publicKey = any_1.Any.fromJSON(object.publicKey);\n        if ((0, helpers_1.isSet)(object.modeInfo))\n            obj.modeInfo = exports.ModeInfo.fromJSON(object.modeInfo);\n        if ((0, helpers_1.isSet)(object.sequence))\n            obj.sequence = BigInt(object.sequence.toString());\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);\n        message.modeInfo !== undefined &&\n            (obj.modeInfo = message.modeInfo ? exports.ModeInfo.toJSON(message.modeInfo) : undefined);\n        message.sequence !== undefined && (obj.sequence = (message.sequence || BigInt(0)).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignerInfo();\n        if (object.publicKey !== undefined && object.publicKey !== null) {\n            message.publicKey = any_1.Any.fromPartial(object.publicKey);\n        }\n        if (object.modeInfo !== undefined && object.modeInfo !== null) {\n            message.modeInfo = exports.ModeInfo.fromPartial(object.modeInfo);\n        }\n        if (object.sequence !== undefined && object.sequence !== null) {\n            message.sequence = BigInt(object.sequence.toString());\n        }\n        return message;\n    },\n};\nfunction createBaseModeInfo() {\n    return {\n        single: undefined,\n        multi: undefined,\n    };\n}\nexports.ModeInfo = {\n    typeUrl: \"/cosmos.tx.v1beta1.ModeInfo\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.single !== undefined) {\n            exports.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.multi !== undefined) {\n            exports.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseModeInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.single = exports.ModeInfo_Single.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.multi = exports.ModeInfo_Multi.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseModeInfo();\n        if ((0, helpers_1.isSet)(object.single))\n            obj.single = exports.ModeInfo_Single.fromJSON(object.single);\n        if ((0, helpers_1.isSet)(object.multi))\n            obj.multi = exports.ModeInfo_Multi.fromJSON(object.multi);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.single !== undefined &&\n            (obj.single = message.single ? exports.ModeInfo_Single.toJSON(message.single) : undefined);\n        message.multi !== undefined &&\n            (obj.multi = message.multi ? exports.ModeInfo_Multi.toJSON(message.multi) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseModeInfo();\n        if (object.single !== undefined && object.single !== null) {\n            message.single = exports.ModeInfo_Single.fromPartial(object.single);\n        }\n        if (object.multi !== undefined && object.multi !== null) {\n            message.multi = exports.ModeInfo_Multi.fromPartial(object.multi);\n        }\n        return message;\n    },\n};\nfunction createBaseModeInfo_Single() {\n    return {\n        mode: 0,\n    };\n}\nexports.ModeInfo_Single = {\n    typeUrl: \"/cosmos.tx.v1beta1.Single\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.mode !== 0) {\n            writer.uint32(8).int32(message.mode);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseModeInfo_Single();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.mode = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseModeInfo_Single();\n        if ((0, helpers_1.isSet)(object.mode))\n            obj.mode = (0, signing_1.signModeFromJSON)(object.mode);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.mode !== undefined && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseModeInfo_Single();\n        message.mode = object.mode ?? 0;\n        return message;\n    },\n};\nfunction createBaseModeInfo_Multi() {\n    return {\n        bitarray: undefined,\n        modeInfos: [],\n    };\n}\nexports.ModeInfo_Multi = {\n    typeUrl: \"/cosmos.tx.v1beta1.Multi\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.bitarray !== undefined) {\n            multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.modeInfos) {\n            exports.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseModeInfo_Multi();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.modeInfos.push(exports.ModeInfo.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseModeInfo_Multi();\n        if ((0, helpers_1.isSet)(object.bitarray))\n            obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);\n        if (Array.isArray(object?.modeInfos))\n            obj.modeInfos = object.modeInfos.map((e) => exports.ModeInfo.fromJSON(e));\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bitarray !== undefined &&\n            (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : undefined);\n        if (message.modeInfos) {\n            obj.modeInfos = message.modeInfos.map((e) => (e ? exports.ModeInfo.toJSON(e) : undefined));\n        }\n        else {\n            obj.modeInfos = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseModeInfo_Multi();\n        if (object.bitarray !== undefined && object.bitarray !== null) {\n            message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);\n        }\n        message.modeInfos = object.modeInfos?.map((e) => exports.ModeInfo.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseFee() {\n    return {\n        amount: [],\n        gasLimit: BigInt(0),\n        payer: \"\",\n        granter: \"\",\n    };\n}\nexports.Fee = {\n    typeUrl: \"/cosmos.tx.v1beta1.Fee\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        for (const v of message.amount) {\n            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.gasLimit !== BigInt(0)) {\n            writer.uint32(16).uint64(message.gasLimit);\n        }\n        if (message.payer !== \"\") {\n            writer.uint32(26).string(message.payer);\n        }\n        if (message.granter !== \"\") {\n            writer.uint32(34).string(message.granter);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFee();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.gasLimit = reader.uint64();\n                    break;\n                case 3:\n                    message.payer = reader.string();\n                    break;\n                case 4:\n                    message.granter = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseFee();\n        if (Array.isArray(object?.amount))\n            obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));\n        if ((0, helpers_1.isSet)(object.gasLimit))\n            obj.gasLimit = BigInt(object.gasLimit.toString());\n        if ((0, helpers_1.isSet)(object.payer))\n            obj.payer = String(object.payer);\n        if ((0, helpers_1.isSet)(object.granter))\n            obj.granter = String(object.granter);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.amount) {\n            obj.amount = message.amount.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.amount = [];\n        }\n        message.gasLimit !== undefined && (obj.gasLimit = (message.gasLimit || BigInt(0)).toString());\n        message.payer !== undefined && (obj.payer = message.payer);\n        message.granter !== undefined && (obj.granter = message.granter);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseFee();\n        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];\n        if (object.gasLimit !== undefined && object.gasLimit !== null) {\n            message.gasLimit = BigInt(object.gasLimit.toString());\n        }\n        message.payer = object.payer ?? \"\";\n        message.granter = object.granter ?? \"\";\n        return message;\n    },\n};\nfunction createBaseTip() {\n    return {\n        amount: [],\n        tipper: \"\",\n    };\n}\nexports.Tip = {\n    typeUrl: \"/cosmos.tx.v1beta1.Tip\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        for (const v of message.amount) {\n            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.tipper !== \"\") {\n            writer.uint32(18).string(message.tipper);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTip();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.tipper = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseTip();\n        if (Array.isArray(object?.amount))\n            obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));\n        if ((0, helpers_1.isSet)(object.tipper))\n            obj.tipper = String(object.tipper);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.amount) {\n            obj.amount = message.amount.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.amount = [];\n        }\n        message.tipper !== undefined && (obj.tipper = message.tipper);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseTip();\n        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];\n        message.tipper = object.tipper ?? \"\";\n        return message;\n    },\n};\nfunction createBaseAuxSignerData() {\n    return {\n        address: \"\",\n        signDoc: undefined,\n        mode: 0,\n        sig: new Uint8Array(),\n    };\n}\nexports.AuxSignerData = {\n    typeUrl: \"/cosmos.tx.v1beta1.AuxSignerData\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.address !== \"\") {\n            writer.uint32(10).string(message.address);\n        }\n        if (message.signDoc !== undefined) {\n            exports.SignDocDirectAux.encode(message.signDoc, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.mode !== 0) {\n            writer.uint32(24).int32(message.mode);\n        }\n        if (message.sig.length !== 0) {\n            writer.uint32(34).bytes(message.sig);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAuxSignerData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                case 2:\n                    message.signDoc = exports.SignDocDirectAux.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.mode = reader.int32();\n                    break;\n                case 4:\n                    message.sig = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseAuxSignerData();\n        if ((0, helpers_1.isSet)(object.address))\n            obj.address = String(object.address);\n        if ((0, helpers_1.isSet)(object.signDoc))\n            obj.signDoc = exports.SignDocDirectAux.fromJSON(object.signDoc);\n        if ((0, helpers_1.isSet)(object.mode))\n            obj.mode = (0, signing_1.signModeFromJSON)(object.mode);\n        if ((0, helpers_1.isSet)(object.sig))\n            obj.sig = (0, helpers_1.bytesFromBase64)(object.sig);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        message.signDoc !== undefined &&\n            (obj.signDoc = message.signDoc ? exports.SignDocDirectAux.toJSON(message.signDoc) : undefined);\n        message.mode !== undefined && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));\n        message.sig !== undefined &&\n            (obj.sig = (0, helpers_1.base64FromBytes)(message.sig !== undefined ? message.sig : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseAuxSignerData();\n        message.address = object.address ?? \"\";\n        if (object.signDoc !== undefined && object.signDoc !== null) {\n            message.signDoc = exports.SignDocDirectAux.fromPartial(object.signDoc);\n        }\n        message.mode = object.mode ?? 0;\n        message.sig = object.sig ?? new Uint8Array();\n        return message;\n    },\n};\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvY29zbW9zL3R4L3YxYmV0YTEvdHguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsd0JBQXdCLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxVQUFVLEdBQUcsdUJBQXVCO0FBQ3BSO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLG9JQUE4QjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQyxnSkFBNEI7QUFDdEQsbUJBQW1CLG1CQUFPLENBQUMsa0tBQXdDO0FBQ25FLGVBQWUsbUJBQU8sQ0FBQyxvSUFBeUI7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsMEdBQWlCO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLDRHQUFrQjtBQUM1Qyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FidWJha3JqaW1vaC9EZXNrdG9wL0NvZGluZyBTdHVmZnMvaGFja2F0aG9uL3NlY3JldC1uZXR3b3JrL21lbWVBaV9jb2luX2NyZWF0b3IvYWktbWVtZS1jb2luLWNyZWF0b3Ivbm9kZV9tb2R1bGVzLy5wbnBtL2Nvc21qcy10eXBlc0AwLjkuMC9ub2RlX21vZHVsZXMvY29zbWpzLXR5cGVzL2Nvc21vcy90eC92MWJldGExL3R4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdXhTaWduZXJEYXRhID0gZXhwb3J0cy5UaXAgPSBleHBvcnRzLkZlZSA9IGV4cG9ydHMuTW9kZUluZm9fTXVsdGkgPSBleHBvcnRzLk1vZGVJbmZvX1NpbmdsZSA9IGV4cG9ydHMuTW9kZUluZm8gPSBleHBvcnRzLlNpZ25lckluZm8gPSBleHBvcnRzLkF1dGhJbmZvID0gZXhwb3J0cy5UeEJvZHkgPSBleHBvcnRzLlNpZ25Eb2NEaXJlY3RBdXggPSBleHBvcnRzLlNpZ25Eb2MgPSBleHBvcnRzLlR4UmF3ID0gZXhwb3J0cy5UeCA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGFueV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi9hbnlcIik7XG5jb25zdCBzaWduaW5nXzEgPSByZXF1aXJlKFwiLi4vc2lnbmluZy92MWJldGExL3NpZ25pbmdcIik7XG5jb25zdCBtdWx0aXNpZ18xID0gcmVxdWlyZShcIi4uLy4uL2NyeXB0by9tdWx0aXNpZy92MWJldGExL211bHRpc2lnXCIpO1xuY29uc3QgY29pbl8xID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvdjFiZXRhMS9jb2luXCIpO1xuY29uc3QgYmluYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmluYXJ5XCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hlbHBlcnNcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLnR4LnYxYmV0YTFcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUeCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgICAgIGF1dGhJbmZvOiB1bmRlZmluZWQsXG4gICAgICAgIHNpZ25hdHVyZXM6IFtdLFxuICAgIH07XG59XG5leHBvcnRzLlR4ID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy50eC52MWJldGExLlR4XCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVHhCb2R5LmVuY29kZShtZXNzYWdlLmJvZHksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYXV0aEluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5BdXRoSW5mby5lbmNvZGUobWVzc2FnZS5hdXRoSW5mbywgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYm9keSA9IGV4cG9ydHMuVHhCb2R5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdXRoSW5mbyA9IGV4cG9ydHMuQXV0aEluZm8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZXMucHVzaChyZWFkZXIuYnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZVR4KCk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QuYm9keSkpXG4gICAgICAgICAgICBvYmouYm9keSA9IGV4cG9ydHMuVHhCb2R5LmZyb21KU09OKG9iamVjdC5ib2R5KTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5hdXRoSW5mbykpXG4gICAgICAgICAgICBvYmouYXV0aEluZm8gPSBleHBvcnRzLkF1dGhJbmZvLmZyb21KU09OKG9iamVjdC5hdXRoSW5mbyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdD8uc2lnbmF0dXJlcykpXG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IG9iamVjdC5zaWduYXR1cmVzLm1hcCgoZSkgPT4gKDAsIGhlbHBlcnNfMS5ieXRlc0Zyb21CYXNlNjQpKGUpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJvZHkgIT09IHVuZGVmaW5lZCAmJiAob2JqLmJvZHkgPSBtZXNzYWdlLmJvZHkgPyBleHBvcnRzLlR4Qm9keS50b0pTT04obWVzc2FnZS5ib2R5KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuYXV0aEluZm8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hdXRoSW5mbyA9IG1lc3NhZ2UuYXV0aEluZm8gPyBleHBvcnRzLkF1dGhJbmZvLnRvSlNPTihtZXNzYWdlLmF1dGhJbmZvKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIG9iai5zaWduYXR1cmVzID0gbWVzc2FnZS5zaWduYXR1cmVzLm1hcCgoZSkgPT4gKDAsIGhlbHBlcnNfMS5iYXNlNjRGcm9tQnl0ZXMpKGUgIT09IHVuZGVmaW5lZCA/IGUgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeCgpO1xuICAgICAgICBpZiAob2JqZWN0LmJvZHkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYm9keSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5ib2R5ID0gZXhwb3J0cy5UeEJvZHkuZnJvbVBhcnRpYWwob2JqZWN0LmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuYXV0aEluZm8gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYXV0aEluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYXV0aEluZm8gPSBleHBvcnRzLkF1dGhJbmZvLmZyb21QYXJ0aWFsKG9iamVjdC5hdXRoSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzID0gb2JqZWN0LnNpZ25hdHVyZXM/Lm1hcCgoZSkgPT4gZSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVR4UmF3KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJvZHlCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgYXV0aEluZm9CeXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgc2lnbmF0dXJlczogW10sXG4gICAgfTtcbn1cbmV4cG9ydHMuVHhSYXcgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLnR4LnYxYmV0YTEuVHhSYXdcIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmJvZHlCeXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuYm9keUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hdXRoSW5mb0J5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5hdXRoSW5mb0J5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeFJhdygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYm9keUJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdXRoSW5mb0J5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VUeFJhdygpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmJvZHlCeXRlcykpXG4gICAgICAgICAgICBvYmouYm9keUJ5dGVzID0gKDAsIGhlbHBlcnNfMS5ieXRlc0Zyb21CYXNlNjQpKG9iamVjdC5ib2R5Qnl0ZXMpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmF1dGhJbmZvQnl0ZXMpKVxuICAgICAgICAgICAgb2JqLmF1dGhJbmZvQnl0ZXMgPSAoMCwgaGVscGVyc18xLmJ5dGVzRnJvbUJhc2U2NCkob2JqZWN0LmF1dGhJbmZvQnl0ZXMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Q/LnNpZ25hdHVyZXMpKVxuICAgICAgICAgICAgb2JqLnNpZ25hdHVyZXMgPSBvYmplY3Quc2lnbmF0dXJlcy5tYXAoKGUpID0+ICgwLCBoZWxwZXJzXzEuYnl0ZXNGcm9tQmFzZTY0KShlKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ib2R5Qnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ib2R5Qnl0ZXMgPSAoMCwgaGVscGVyc18xLmJhc2U2NEZyb21CeXRlcykobWVzc2FnZS5ib2R5Qnl0ZXMgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuYm9keUJ5dGVzIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmF1dGhJbmZvQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hdXRoSW5mb0J5dGVzID0gKDAsIGhlbHBlcnNfMS5iYXNlNjRGcm9tQnl0ZXMpKG1lc3NhZ2UuYXV0aEluZm9CeXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5hdXRoSW5mb0J5dGVzIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IG1lc3NhZ2Uuc2lnbmF0dXJlcy5tYXAoKGUpID0+ICgwLCBoZWxwZXJzXzEuYmFzZTY0RnJvbUJ5dGVzKShlICE9PSB1bmRlZmluZWQgPyBlIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnNpZ25hdHVyZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVHhSYXcoKTtcbiAgICAgICAgbWVzc2FnZS5ib2R5Qnl0ZXMgPSBvYmplY3QuYm9keUJ5dGVzID8/IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuYXV0aEluZm9CeXRlcyA9IG9iamVjdC5hdXRoSW5mb0J5dGVzID8/IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlcyA9IG9iamVjdC5zaWduYXR1cmVzPy5tYXAoKGUpID0+IGUpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduRG9jKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJvZHlCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgYXV0aEluZm9CeXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgY2hhaW5JZDogXCJcIixcbiAgICAgICAgYWNjb3VudE51bWJlcjogQmlnSW50KDApLFxuICAgIH07XG59XG5leHBvcnRzLlNpZ25Eb2MgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLnR4LnYxYmV0YTEuU2lnbkRvY1wiLFxuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBiaW5hcnlfMS5CaW5hcnlXcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYm9keUJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5ib2R5Qnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhJbmZvQnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmF1dGhJbmZvQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNoYWluSWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLmNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFjY291bnROdW1iZXIgIT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzMikudWludDY0KG1lc3NhZ2UuYWNjb3VudE51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbkRvYygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYm9keUJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdXRoSW5mb0J5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaGFpbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWNjb3VudE51bWJlciA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlU2lnbkRvYygpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmJvZHlCeXRlcykpXG4gICAgICAgICAgICBvYmouYm9keUJ5dGVzID0gKDAsIGhlbHBlcnNfMS5ieXRlc0Zyb21CYXNlNjQpKG9iamVjdC5ib2R5Qnl0ZXMpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmF1dGhJbmZvQnl0ZXMpKVxuICAgICAgICAgICAgb2JqLmF1dGhJbmZvQnl0ZXMgPSAoMCwgaGVscGVyc18xLmJ5dGVzRnJvbUJhc2U2NCkob2JqZWN0LmF1dGhJbmZvQnl0ZXMpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmNoYWluSWQpKVxuICAgICAgICAgICAgb2JqLmNoYWluSWQgPSBTdHJpbmcob2JqZWN0LmNoYWluSWQpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmFjY291bnROdW1iZXIpKVxuICAgICAgICAgICAgb2JqLmFjY291bnROdW1iZXIgPSBCaWdJbnQob2JqZWN0LmFjY291bnROdW1iZXIudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ib2R5Qnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ib2R5Qnl0ZXMgPSAoMCwgaGVscGVyc18xLmJhc2U2NEZyb21CeXRlcykobWVzc2FnZS5ib2R5Qnl0ZXMgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuYm9keUJ5dGVzIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmF1dGhJbmZvQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hdXRoSW5mb0J5dGVzID0gKDAsIGhlbHBlcnNfMS5iYXNlNjRGcm9tQnl0ZXMpKG1lc3NhZ2UuYXV0aEluZm9CeXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5hdXRoSW5mb0J5dGVzIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmNoYWluSWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNoYWluSWQgPSBtZXNzYWdlLmNoYWluSWQpO1xuICAgICAgICBtZXNzYWdlLmFjY291bnROdW1iZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hY2NvdW50TnVtYmVyID0gKG1lc3NhZ2UuYWNjb3VudE51bWJlciB8fCBCaWdJbnQoMCkpLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbkRvYygpO1xuICAgICAgICBtZXNzYWdlLmJvZHlCeXRlcyA9IG9iamVjdC5ib2R5Qnl0ZXMgPz8gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5hdXRoSW5mb0J5dGVzID0gb2JqZWN0LmF1dGhJbmZvQnl0ZXMgPz8gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5jaGFpbklkID0gb2JqZWN0LmNoYWluSWQgPz8gXCJcIjtcbiAgICAgICAgaWYgKG9iamVjdC5hY2NvdW50TnVtYmVyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmFjY291bnROdW1iZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYWNjb3VudE51bWJlciA9IEJpZ0ludChvYmplY3QuYWNjb3VudE51bWJlci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduRG9jRGlyZWN0QXV4KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJvZHlCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgcHVibGljS2V5OiB1bmRlZmluZWQsXG4gICAgICAgIGNoYWluSWQ6IFwiXCIsXG4gICAgICAgIGFjY291bnROdW1iZXI6IEJpZ0ludCgwKSxcbiAgICAgICAgc2VxdWVuY2U6IEJpZ0ludCgwKSxcbiAgICAgICAgdGlwOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuU2lnbkRvY0RpcmVjdEF1eCA9IHtcbiAgICB0eXBlVXJsOiBcIi9jb3Ntb3MudHgudjFiZXRhMS5TaWduRG9jRGlyZWN0QXV4XCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ib2R5Qnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmJvZHlCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucHVibGljS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFueV8xLkFueS5lbmNvZGUobWVzc2FnZS5wdWJsaWNLZXksIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2hhaW5JZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UuY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWNjb3VudE51bWJlciAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS51aW50NjQobWVzc2FnZS5hY2NvdW50TnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZXF1ZW5jZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQwKS51aW50NjQobWVzc2FnZS5zZXF1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudGlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVGlwLmVuY29kZShtZXNzYWdlLnRpcCwgd3JpdGVyLnVpbnQzMig1MCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduRG9jRGlyZWN0QXV4KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ib2R5Qnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSA9IGFueV8xLkFueS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hhaW5JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFjY291bnROdW1iZXIgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZSA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpcCA9IGV4cG9ydHMuVGlwLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZVNpZ25Eb2NEaXJlY3RBdXgoKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5ib2R5Qnl0ZXMpKVxuICAgICAgICAgICAgb2JqLmJvZHlCeXRlcyA9ICgwLCBoZWxwZXJzXzEuYnl0ZXNGcm9tQmFzZTY0KShvYmplY3QuYm9keUJ5dGVzKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5wdWJsaWNLZXkpKVxuICAgICAgICAgICAgb2JqLnB1YmxpY0tleSA9IGFueV8xLkFueS5mcm9tSlNPTihvYmplY3QucHVibGljS2V5KTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5jaGFpbklkKSlcbiAgICAgICAgICAgIG9iai5jaGFpbklkID0gU3RyaW5nKG9iamVjdC5jaGFpbklkKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5hY2NvdW50TnVtYmVyKSlcbiAgICAgICAgICAgIG9iai5hY2NvdW50TnVtYmVyID0gQmlnSW50KG9iamVjdC5hY2NvdW50TnVtYmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LnNlcXVlbmNlKSlcbiAgICAgICAgICAgIG9iai5zZXF1ZW5jZSA9IEJpZ0ludChvYmplY3Quc2VxdWVuY2UudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QudGlwKSlcbiAgICAgICAgICAgIG9iai50aXAgPSBleHBvcnRzLlRpcC5mcm9tSlNPTihvYmplY3QudGlwKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJvZHlCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmJvZHlCeXRlcyA9ICgwLCBoZWxwZXJzXzEuYmFzZTY0RnJvbUJ5dGVzKShtZXNzYWdlLmJvZHlCeXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5ib2R5Qnl0ZXMgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UucHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHVibGljS2V5ID0gbWVzc2FnZS5wdWJsaWNLZXkgPyBhbnlfMS5BbnkudG9KU09OKG1lc3NhZ2UucHVibGljS2V5KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuY2hhaW5JZCAhPT0gdW5kZWZpbmVkICYmIChvYmouY2hhaW5JZCA9IG1lc3NhZ2UuY2hhaW5JZCk7XG4gICAgICAgIG1lc3NhZ2UuYWNjb3VudE51bWJlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFjY291bnROdW1iZXIgPSAobWVzc2FnZS5hY2NvdW50TnVtYmVyIHx8IEJpZ0ludCgwKSkudG9TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2Uuc2VxdWVuY2UgIT09IHVuZGVmaW5lZCAmJiAob2JqLnNlcXVlbmNlID0gKG1lc3NhZ2Uuc2VxdWVuY2UgfHwgQmlnSW50KDApKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS50aXAgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRpcCA9IG1lc3NhZ2UudGlwID8gZXhwb3J0cy5UaXAudG9KU09OKG1lc3NhZ2UudGlwKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduRG9jRGlyZWN0QXV4KCk7XG4gICAgICAgIG1lc3NhZ2UuYm9keUJ5dGVzID0gb2JqZWN0LmJvZHlCeXRlcyA/PyBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBpZiAob2JqZWN0LnB1YmxpY0tleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wdWJsaWNLZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucHVibGljS2V5ID0gYW55XzEuQW55LmZyb21QYXJ0aWFsKG9iamVjdC5wdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UuY2hhaW5JZCA9IG9iamVjdC5jaGFpbklkID8/IFwiXCI7XG4gICAgICAgIGlmIChvYmplY3QuYWNjb3VudE51bWJlciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hY2NvdW50TnVtYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmFjY291bnROdW1iZXIgPSBCaWdJbnQob2JqZWN0LmFjY291bnROdW1iZXIudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5zZXF1ZW5jZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zZXF1ZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZSA9IEJpZ0ludChvYmplY3Quc2VxdWVuY2UudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50aXAgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudGlwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnRpcCA9IGV4cG9ydHMuVGlwLmZyb21QYXJ0aWFsKG9iamVjdC50aXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVR4Qm9keSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgIG1lbW86IFwiXCIsXG4gICAgICAgIHRpbWVvdXRIZWlnaHQ6IEJpZ0ludCgwKSxcbiAgICAgICAgZXh0ZW5zaW9uT3B0aW9uczogW10sXG4gICAgICAgIG5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9uczogW10sXG4gICAgfTtcbn1cbmV4cG9ydHMuVHhCb2R5ID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy50eC52MWJldGExLlR4Qm9keVwiLFxuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBiaW5hcnlfMS5CaW5hcnlXcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGFueV8xLkFueS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tZW1vICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5tZW1vKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50aW1lb3V0SGVpZ2h0ICE9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQ2NChtZXNzYWdlLnRpbWVvdXRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmV4dGVuc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIGFueV8xLkFueS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMig4MTg2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9ucykge1xuICAgICAgICAgICAgYW55XzEuQW55LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDE2Mzc4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVR4Qm9keSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZXMucHVzaChhbnlfMS5BbnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZW1vID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZW91dEhlaWdodCA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDIzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4dGVuc2lvbk9wdGlvbnMucHVzaChhbnlfMS5BbnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA0NzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ub25Dcml0aWNhbEV4dGVuc2lvbk9wdGlvbnMucHVzaChhbnlfMS5BbnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZVR4Qm9keSgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Q/Lm1lc3NhZ2VzKSlcbiAgICAgICAgICAgIG9iai5tZXNzYWdlcyA9IG9iamVjdC5tZXNzYWdlcy5tYXAoKGUpID0+IGFueV8xLkFueS5mcm9tSlNPTihlKSk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QubWVtbykpXG4gICAgICAgICAgICBvYmoubWVtbyA9IFN0cmluZyhvYmplY3QubWVtbyk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QudGltZW91dEhlaWdodCkpXG4gICAgICAgICAgICBvYmoudGltZW91dEhlaWdodCA9IEJpZ0ludChvYmplY3QudGltZW91dEhlaWdodC50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0Py5leHRlbnNpb25PcHRpb25zKSlcbiAgICAgICAgICAgIG9iai5leHRlbnNpb25PcHRpb25zID0gb2JqZWN0LmV4dGVuc2lvbk9wdGlvbnMubWFwKChlKSA9PiBhbnlfMS5BbnkuZnJvbUpTT04oZSkpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Q/Lm5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9ucykpXG4gICAgICAgICAgICBvYmoubm9uQ3JpdGljYWxFeHRlbnNpb25PcHRpb25zID0gb2JqZWN0Lm5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9ucy5tYXAoKGUpID0+IGFueV8xLkFueS5mcm9tSlNPTihlKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG9iai5tZXNzYWdlcyA9IG1lc3NhZ2UubWVzc2FnZXMubWFwKChlKSA9PiAoZSA/IGFueV8xLkFueS50b0pTT04oZSkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UubWVtbyAhPT0gdW5kZWZpbmVkICYmIChvYmoubWVtbyA9IG1lc3NhZ2UubWVtbyk7XG4gICAgICAgIG1lc3NhZ2UudGltZW91dEhlaWdodCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRpbWVvdXRIZWlnaHQgPSAobWVzc2FnZS50aW1lb3V0SGVpZ2h0IHx8IEJpZ0ludCgwKSkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmV4dGVuc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9iai5leHRlbnNpb25PcHRpb25zID0gbWVzc2FnZS5leHRlbnNpb25PcHRpb25zLm1hcCgoZSkgPT4gKGUgPyBhbnlfMS5BbnkudG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouZXh0ZW5zaW9uT3B0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9ucykge1xuICAgICAgICAgICAgb2JqLm5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9ucyA9IG1lc3NhZ2Uubm9uQ3JpdGljYWxFeHRlbnNpb25PcHRpb25zLm1hcCgoZSkgPT4gZSA/IGFueV8xLkFueS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLm5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeEJvZHkoKTtcbiAgICAgICAgbWVzc2FnZS5tZXNzYWdlcyA9IG9iamVjdC5tZXNzYWdlcz8ubWFwKChlKSA9PiBhbnlfMS5BbnkuZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLm1lbW8gPSBvYmplY3QubWVtbyA/PyBcIlwiO1xuICAgICAgICBpZiAob2JqZWN0LnRpbWVvdXRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudGltZW91dEhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS50aW1lb3V0SGVpZ2h0ID0gQmlnSW50KG9iamVjdC50aW1lb3V0SGVpZ2h0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UuZXh0ZW5zaW9uT3B0aW9ucyA9IG9iamVjdC5leHRlbnNpb25PcHRpb25zPy5tYXAoKGUpID0+IGFueV8xLkFueS5mcm9tUGFydGlhbChlKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2Uubm9uQ3JpdGljYWxFeHRlbnNpb25PcHRpb25zID1cbiAgICAgICAgICAgIG9iamVjdC5ub25Dcml0aWNhbEV4dGVuc2lvbk9wdGlvbnM/Lm1hcCgoZSkgPT4gYW55XzEuQW55LmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQXV0aEluZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbmVySW5mb3M6IFtdLFxuICAgICAgICBmZWU6IHVuZGVmaW5lZCxcbiAgICAgICAgdGlwOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuQXV0aEluZm8gPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLnR4LnYxYmV0YTEuQXV0aEluZm9cIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnNpZ25lckluZm9zKSB7XG4gICAgICAgICAgICBleHBvcnRzLlNpZ25lckluZm8uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuRmVlLmVuY29kZShtZXNzYWdlLmZlZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50aXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5UaXAuZW5jb2RlKG1lc3NhZ2UudGlwLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUF1dGhJbmZvKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduZXJJbmZvcy5wdXNoKGV4cG9ydHMuU2lnbmVySW5mby5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZlZSA9IGV4cG9ydHMuRmVlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aXAgPSBleHBvcnRzLlRpcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VBdXRoSW5mbygpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Q/LnNpZ25lckluZm9zKSlcbiAgICAgICAgICAgIG9iai5zaWduZXJJbmZvcyA9IG9iamVjdC5zaWduZXJJbmZvcy5tYXAoKGUpID0+IGV4cG9ydHMuU2lnbmVySW5mby5mcm9tSlNPTihlKSk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QuZmVlKSlcbiAgICAgICAgICAgIG9iai5mZWUgPSBleHBvcnRzLkZlZS5mcm9tSlNPTihvYmplY3QuZmVlKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC50aXApKVxuICAgICAgICAgICAgb2JqLnRpcCA9IGV4cG9ydHMuVGlwLmZyb21KU09OKG9iamVjdC50aXApO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25lckluZm9zKSB7XG4gICAgICAgICAgICBvYmouc2lnbmVySW5mb3MgPSBtZXNzYWdlLnNpZ25lckluZm9zLm1hcCgoZSkgPT4gKGUgPyBleHBvcnRzLlNpZ25lckluZm8udG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc2lnbmVySW5mb3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLmZlZSAhPT0gdW5kZWZpbmVkICYmIChvYmouZmVlID0gbWVzc2FnZS5mZWUgPyBleHBvcnRzLkZlZS50b0pTT04obWVzc2FnZS5mZWUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS50aXAgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRpcCA9IG1lc3NhZ2UudGlwID8gZXhwb3J0cy5UaXAudG9KU09OKG1lc3NhZ2UudGlwKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VBdXRoSW5mbygpO1xuICAgICAgICBtZXNzYWdlLnNpZ25lckluZm9zID0gb2JqZWN0LnNpZ25lckluZm9zPy5tYXAoKGUpID0+IGV4cG9ydHMuU2lnbmVySW5mby5mcm9tUGFydGlhbChlKSkgfHwgW107XG4gICAgICAgIGlmIChvYmplY3QuZmVlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmZlZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5mZWUgPSBleHBvcnRzLkZlZS5mcm9tUGFydGlhbChvYmplY3QuZmVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnRpcCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50aXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudGlwID0gZXhwb3J0cy5UaXAuZnJvbVBhcnRpYWwob2JqZWN0LnRpcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmVySW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgbW9kZUluZm86IHVuZGVmaW5lZCxcbiAgICAgICAgc2VxdWVuY2U6IEJpZ0ludCgwKSxcbiAgICB9O1xufVxuZXhwb3J0cy5TaWduZXJJbmZvID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy50eC52MWJldGExLlNpZ25lckluZm9cIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnB1YmxpY0tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbnlfMS5BbnkuZW5jb2RlKG1lc3NhZ2UucHVibGljS2V5LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1vZGVJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuTW9kZUluZm8uZW5jb2RlKG1lc3NhZ2UubW9kZUluZm8sIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2UgIT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDY0KG1lc3NhZ2Uuc2VxdWVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lckluZm8oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSA9IGFueV8xLkFueS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubW9kZUluZm8gPSBleHBvcnRzLk1vZGVJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZSA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlU2lnbmVySW5mbygpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LnB1YmxpY0tleSkpXG4gICAgICAgICAgICBvYmoucHVibGljS2V5ID0gYW55XzEuQW55LmZyb21KU09OKG9iamVjdC5wdWJsaWNLZXkpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0Lm1vZGVJbmZvKSlcbiAgICAgICAgICAgIG9iai5tb2RlSW5mbyA9IGV4cG9ydHMuTW9kZUluZm8uZnJvbUpTT04ob2JqZWN0Lm1vZGVJbmZvKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5zZXF1ZW5jZSkpXG4gICAgICAgICAgICBvYmouc2VxdWVuY2UgPSBCaWdJbnQob2JqZWN0LnNlcXVlbmNlLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHVibGljS2V5ID0gbWVzc2FnZS5wdWJsaWNLZXkgPyBhbnlfMS5BbnkudG9KU09OKG1lc3NhZ2UucHVibGljS2V5KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UubW9kZUluZm8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5tb2RlSW5mbyA9IG1lc3NhZ2UubW9kZUluZm8gPyBleHBvcnRzLk1vZGVJbmZvLnRvSlNPTihtZXNzYWdlLm1vZGVJbmZvKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc2VxdWVuY2UgIT09IHVuZGVmaW5lZCAmJiAob2JqLnNlcXVlbmNlID0gKG1lc3NhZ2Uuc2VxdWVuY2UgfHwgQmlnSW50KDApKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lckluZm8oKTtcbiAgICAgICAgaWYgKG9iamVjdC5wdWJsaWNLZXkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHVibGljS2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSA9IGFueV8xLkFueS5mcm9tUGFydGlhbChvYmplY3QucHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Lm1vZGVJbmZvICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm1vZGVJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlLm1vZGVJbmZvID0gZXhwb3J0cy5Nb2RlSW5mby5mcm9tUGFydGlhbChvYmplY3QubW9kZUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Quc2VxdWVuY2UgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2VxdWVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2VxdWVuY2UgPSBCaWdJbnQob2JqZWN0LnNlcXVlbmNlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1vZGVJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpbmdsZTogdW5kZWZpbmVkLFxuICAgICAgICBtdWx0aTogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnRzLk1vZGVJbmZvID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy50eC52MWJldGExLk1vZGVJbmZvXCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zaW5nbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5Nb2RlSW5mb19TaW5nbGUuZW5jb2RlKG1lc3NhZ2Uuc2luZ2xlLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm11bHRpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuTW9kZUluZm9fTXVsdGkuZW5jb2RlKG1lc3NhZ2UubXVsdGksIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTW9kZUluZm8oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpbmdsZSA9IGV4cG9ydHMuTW9kZUluZm9fU2luZ2xlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tdWx0aSA9IGV4cG9ydHMuTW9kZUluZm9fTXVsdGkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlTW9kZUluZm8oKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5zaW5nbGUpKVxuICAgICAgICAgICAgb2JqLnNpbmdsZSA9IGV4cG9ydHMuTW9kZUluZm9fU2luZ2xlLmZyb21KU09OKG9iamVjdC5zaW5nbGUpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0Lm11bHRpKSlcbiAgICAgICAgICAgIG9iai5tdWx0aSA9IGV4cG9ydHMuTW9kZUluZm9fTXVsdGkuZnJvbUpTT04ob2JqZWN0Lm11bHRpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnNpbmdsZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNpbmdsZSA9IG1lc3NhZ2Uuc2luZ2xlID8gZXhwb3J0cy5Nb2RlSW5mb19TaW5nbGUudG9KU09OKG1lc3NhZ2Uuc2luZ2xlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UubXVsdGkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5tdWx0aSA9IG1lc3NhZ2UubXVsdGkgPyBleHBvcnRzLk1vZGVJbmZvX011bHRpLnRvSlNPTihtZXNzYWdlLm11bHRpKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNb2RlSW5mbygpO1xuICAgICAgICBpZiAob2JqZWN0LnNpbmdsZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaW5nbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2luZ2xlID0gZXhwb3J0cy5Nb2RlSW5mb19TaW5nbGUuZnJvbVBhcnRpYWwob2JqZWN0LnNpbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5tdWx0aSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5tdWx0aSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZS5tdWx0aSA9IGV4cG9ydHMuTW9kZUluZm9fTXVsdGkuZnJvbVBhcnRpYWwob2JqZWN0Lm11bHRpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNb2RlSW5mb19TaW5nbGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbW9kZTogMCxcbiAgICB9O1xufVxuZXhwb3J0cy5Nb2RlSW5mb19TaW5nbGUgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLnR4LnYxYmV0YTEuU2luZ2xlXCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5tb2RlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTW9kZUluZm9fU2luZ2xlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZU1vZGVJbmZvX1NpbmdsZSgpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0Lm1vZGUpKVxuICAgICAgICAgICAgb2JqLm1vZGUgPSAoMCwgc2lnbmluZ18xLnNpZ25Nb2RlRnJvbUpTT04pKG9iamVjdC5tb2RlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLm1vZGUgIT09IHVuZGVmaW5lZCAmJiAob2JqLm1vZGUgPSAoMCwgc2lnbmluZ18xLnNpZ25Nb2RlVG9KU09OKShtZXNzYWdlLm1vZGUpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1vZGVJbmZvX1NpbmdsZSgpO1xuICAgICAgICBtZXNzYWdlLm1vZGUgPSBvYmplY3QubW9kZSA/PyAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNb2RlSW5mb19NdWx0aSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiaXRhcnJheTogdW5kZWZpbmVkLFxuICAgICAgICBtb2RlSW5mb3M6IFtdLFxuICAgIH07XG59XG5leHBvcnRzLk1vZGVJbmZvX011bHRpID0ge1xuICAgIHR5cGVVcmw6IFwiL2Nvc21vcy50eC52MWJldGExLk11bHRpXCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5iaXRhcnJheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtdWx0aXNpZ18xLkNvbXBhY3RCaXRBcnJheS5lbmNvZGUobWVzc2FnZS5iaXRhcnJheSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5tb2RlSW5mb3MpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuTW9kZUluZm8uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTW9kZUluZm9fTXVsdGkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJpdGFycmF5ID0gbXVsdGlzaWdfMS5Db21wYWN0Qml0QXJyYXkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1vZGVJbmZvcy5wdXNoKGV4cG9ydHMuTW9kZUluZm8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZU1vZGVJbmZvX011bHRpKCk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QuYml0YXJyYXkpKVxuICAgICAgICAgICAgb2JqLmJpdGFycmF5ID0gbXVsdGlzaWdfMS5Db21wYWN0Qml0QXJyYXkuZnJvbUpTT04ob2JqZWN0LmJpdGFycmF5KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0Py5tb2RlSW5mb3MpKVxuICAgICAgICAgICAgb2JqLm1vZGVJbmZvcyA9IG9iamVjdC5tb2RlSW5mb3MubWFwKChlKSA9PiBleHBvcnRzLk1vZGVJbmZvLmZyb21KU09OKGUpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJpdGFycmF5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYml0YXJyYXkgPSBtZXNzYWdlLmJpdGFycmF5ID8gbXVsdGlzaWdfMS5Db21wYWN0Qml0QXJyYXkudG9KU09OKG1lc3NhZ2UuYml0YXJyYXkpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubW9kZUluZm9zKSB7XG4gICAgICAgICAgICBvYmoubW9kZUluZm9zID0gbWVzc2FnZS5tb2RlSW5mb3MubWFwKChlKSA9PiAoZSA/IGV4cG9ydHMuTW9kZUluZm8udG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoubW9kZUluZm9zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1vZGVJbmZvX011bHRpKCk7XG4gICAgICAgIGlmIChvYmplY3QuYml0YXJyYXkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYml0YXJyYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYml0YXJyYXkgPSBtdWx0aXNpZ18xLkNvbXBhY3RCaXRBcnJheS5mcm9tUGFydGlhbChvYmplY3QuYml0YXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UubW9kZUluZm9zID0gb2JqZWN0Lm1vZGVJbmZvcz8ubWFwKChlKSA9PiBleHBvcnRzLk1vZGVJbmZvLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRmVlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFtb3VudDogW10sXG4gICAgICAgIGdhc0xpbWl0OiBCaWdJbnQoMCksXG4gICAgICAgIHBheWVyOiBcIlwiLFxuICAgICAgICBncmFudGVyOiBcIlwiLFxuICAgIH07XG59XG5leHBvcnRzLkZlZSA9IHtcbiAgICB0eXBlVXJsOiBcIi9jb3Ntb3MudHgudjFiZXRhMS5GZWVcIixcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gYmluYXJ5XzEuQmluYXJ5V3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmFtb3VudCkge1xuICAgICAgICAgICAgY29pbl8xLkNvaW4uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZ2FzTGltaXQgIT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDY0KG1lc3NhZ2UuZ2FzTGltaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBheWVyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5wYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JhbnRlciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2UuZ3JhbnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgYmluYXJ5XzEuQmluYXJ5UmVhZGVyID8gaW5wdXQgOiBuZXcgYmluYXJ5XzEuQmluYXJ5UmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRmVlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbW91bnQucHVzaChjb2luXzEuQ29pbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdhc0xpbWl0ID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5ZXIgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFudGVyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VGZWUoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0Py5hbW91bnQpKVxuICAgICAgICAgICAgb2JqLmFtb3VudCA9IG9iamVjdC5hbW91bnQubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tSlNPTihlKSk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QuZ2FzTGltaXQpKVxuICAgICAgICAgICAgb2JqLmdhc0xpbWl0ID0gQmlnSW50KG9iamVjdC5nYXNMaW1pdC50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5wYXllcikpXG4gICAgICAgICAgICBvYmoucGF5ZXIgPSBTdHJpbmcob2JqZWN0LnBheWVyKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5ncmFudGVyKSlcbiAgICAgICAgICAgIG9iai5ncmFudGVyID0gU3RyaW5nKG9iamVjdC5ncmFudGVyKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5hbW91bnQpIHtcbiAgICAgICAgICAgIG9iai5hbW91bnQgPSBtZXNzYWdlLmFtb3VudC5tYXAoKGUpID0+IChlID8gY29pbl8xLkNvaW4udG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouYW1vdW50ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5nYXNMaW1pdCAhPT0gdW5kZWZpbmVkICYmIChvYmouZ2FzTGltaXQgPSAobWVzc2FnZS5nYXNMaW1pdCB8fCBCaWdJbnQoMCkpLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLnBheWVyICE9PSB1bmRlZmluZWQgJiYgKG9iai5wYXllciA9IG1lc3NhZ2UucGF5ZXIpO1xuICAgICAgICBtZXNzYWdlLmdyYW50ZXIgIT09IHVuZGVmaW5lZCAmJiAob2JqLmdyYW50ZXIgPSBtZXNzYWdlLmdyYW50ZXIpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRmVlKCk7XG4gICAgICAgIG1lc3NhZ2UuYW1vdW50ID0gb2JqZWN0LmFtb3VudD8ubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChlKSkgfHwgW107XG4gICAgICAgIGlmIChvYmplY3QuZ2FzTGltaXQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZ2FzTGltaXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZ2FzTGltaXQgPSBCaWdJbnQob2JqZWN0Lmdhc0xpbWl0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UucGF5ZXIgPSBvYmplY3QucGF5ZXIgPz8gXCJcIjtcbiAgICAgICAgbWVzc2FnZS5ncmFudGVyID0gb2JqZWN0LmdyYW50ZXIgPz8gXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVGlwKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFtb3VudDogW10sXG4gICAgICAgIHRpcHBlcjogXCJcIixcbiAgICB9O1xufVxuZXhwb3J0cy5UaXAgPSB7XG4gICAgdHlwZVVybDogXCIvY29zbW9zLnR4LnYxYmV0YTEuVGlwXCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5hbW91bnQpIHtcbiAgICAgICAgICAgIGNvaW5fMS5Db2luLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRpcHBlciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudGlwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBiaW5hcnlfMS5CaW5hcnlSZWFkZXIgPyBpbnB1dCA6IG5ldyBiaW5hcnlfMS5CaW5hcnlSZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUaXAoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFtb3VudC5wdXNoKGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGlwcGVyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNyZWF0ZUJhc2VUaXAoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0Py5hbW91bnQpKVxuICAgICAgICAgICAgb2JqLmFtb3VudCA9IG9iamVjdC5hbW91bnQubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tSlNPTihlKSk7XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzU2V0KShvYmplY3QudGlwcGVyKSlcbiAgICAgICAgICAgIG9iai50aXBwZXIgPSBTdHJpbmcob2JqZWN0LnRpcHBlcik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYW1vdW50KSB7XG4gICAgICAgICAgICBvYmouYW1vdW50ID0gbWVzc2FnZS5hbW91bnQubWFwKChlKSA9PiAoZSA/IGNvaW5fMS5Db2luLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmFtb3VudCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UudGlwcGVyICE9PSB1bmRlZmluZWQgJiYgKG9iai50aXBwZXIgPSBtZXNzYWdlLnRpcHBlcik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUaXAoKTtcbiAgICAgICAgbWVzc2FnZS5hbW91bnQgPSBvYmplY3QuYW1vdW50Py5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS50aXBwZXIgPSBvYmplY3QudGlwcGVyID8/IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUF1eFNpZ25lckRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogXCJcIixcbiAgICAgICAgc2lnbkRvYzogdW5kZWZpbmVkLFxuICAgICAgICBtb2RlOiAwLFxuICAgICAgICBzaWc6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydHMuQXV4U2lnbmVyRGF0YSA9IHtcbiAgICB0eXBlVXJsOiBcIi9jb3Ntb3MudHgudjFiZXRhMS5BdXhTaWduZXJEYXRhXCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduRG9jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU2lnbkRvY0RpcmVjdEF1eC5lbmNvZGUobWVzc2FnZS5zaWduRG9jLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1vZGUgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLmludDMyKG1lc3NhZ2UubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2lnLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuYnl0ZXMobWVzc2FnZS5zaWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUF1eFNpZ25lckRhdGEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduRG9jID0gZXhwb3J0cy5TaWduRG9jRGlyZWN0QXV4LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWcgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICBjb25zdCBvYmogPSBjcmVhdGVCYXNlQXV4U2lnbmVyRGF0YSgpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LmFkZHJlc3MpKVxuICAgICAgICAgICAgb2JqLmFkZHJlc3MgPSBTdHJpbmcob2JqZWN0LmFkZHJlc3MpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LnNpZ25Eb2MpKVxuICAgICAgICAgICAgb2JqLnNpZ25Eb2MgPSBleHBvcnRzLlNpZ25Eb2NEaXJlY3RBdXguZnJvbUpTT04ob2JqZWN0LnNpZ25Eb2MpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0Lm1vZGUpKVxuICAgICAgICAgICAgb2JqLm1vZGUgPSAoMCwgc2lnbmluZ18xLnNpZ25Nb2RlRnJvbUpTT04pKG9iamVjdC5tb2RlKTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNTZXQpKG9iamVjdC5zaWcpKVxuICAgICAgICAgICAgb2JqLnNpZyA9ICgwLCBoZWxwZXJzXzEuYnl0ZXNGcm9tQmFzZTY0KShvYmplY3Quc2lnKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiAob2JqLmFkZHJlc3MgPSBtZXNzYWdlLmFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLnNpZ25Eb2MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaWduRG9jID0gbWVzc2FnZS5zaWduRG9jID8gZXhwb3J0cy5TaWduRG9jRGlyZWN0QXV4LnRvSlNPTihtZXNzYWdlLnNpZ25Eb2MpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5tb2RlICE9PSB1bmRlZmluZWQgJiYgKG9iai5tb2RlID0gKDAsIHNpZ25pbmdfMS5zaWduTW9kZVRvSlNPTikobWVzc2FnZS5tb2RlKSk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2lnID0gKDAsIGhlbHBlcnNfMS5iYXNlNjRGcm9tQnl0ZXMpKG1lc3NhZ2Uuc2lnICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnNpZyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUF1eFNpZ25lckRhdGEoKTtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gb2JqZWN0LmFkZHJlc3MgPz8gXCJcIjtcbiAgICAgICAgaWYgKG9iamVjdC5zaWduRG9jICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNpZ25Eb2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbkRvYyA9IGV4cG9ydHMuU2lnbkRvY0RpcmVjdEF1eC5mcm9tUGFydGlhbChvYmplY3Quc2lnbkRvYyk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5tb2RlID0gb2JqZWN0Lm1vZGUgPz8gMDtcbiAgICAgICAgbWVzc2FnZS5zaWcgPSBvYmplY3Quc2lnID8/IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/google/protobuf/any.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/google/protobuf/any.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Any = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst binary_1 = __webpack_require__(/*! ../../binary */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/binary.js\");\nconst helpers_1 = __webpack_require__(/*! ../../helpers */ \"(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\");\nexports.protobufPackage = \"google.protobuf\";\nfunction createBaseAny() {\n    return {\n        typeUrl: \"\",\n        value: new Uint8Array(),\n    };\n}\nexports.Any = {\n    typeUrl: \"/google.protobuf.Any\",\n    encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.typeUrl !== \"\") {\n            writer.uint32(10).string(message.typeUrl);\n        }\n        if (message.value.length !== 0) {\n            writer.uint32(18).bytes(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAny();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.typeUrl = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const obj = createBaseAny();\n        if ((0, helpers_1.isSet)(object.typeUrl))\n            obj.typeUrl = String(object.typeUrl);\n        if ((0, helpers_1.isSet)(object.value))\n            obj.value = (0, helpers_1.bytesFromBase64)(object.value);\n        return obj;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.typeUrl !== undefined && (obj.typeUrl = message.typeUrl);\n        message.value !== undefined &&\n            (obj.value = (0, helpers_1.base64FromBytes)(message.value !== undefined ? message.value : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseAny();\n        message.typeUrl = object.typeUrl ?? \"\";\n        message.value = object.value ?? new Uint8Array();\n        return message;\n    },\n};\n//# sourceMappingURL=any.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvZ29vZ2xlL3Byb3RvYnVmL2FueS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXLEdBQUcsdUJBQXVCO0FBQ3JDO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsdUdBQWM7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMseUdBQWU7QUFDekMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWJ1YmFrcmppbW9oL0Rlc2t0b3AvQ29kaW5nIFN0dWZmcy9oYWNrYXRob24vc2VjcmV0LW5ldHdvcmsvbWVtZUFpX2NvaW5fY3JlYXRvci9haS1tZW1lLWNvaW4tY3JlYXRvci9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvZ29vZ2xlL3Byb3RvYnVmL2FueS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW55ID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgYmluYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vYmluYXJ5XCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnNcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiZ29vZ2xlLnByb3RvYnVmXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlQW55KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVVcmw6IFwiXCIsXG4gICAgICAgIHZhbHVlOiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnRzLkFueSA9IHtcbiAgICB0eXBlVXJsOiBcIi9nb29nbGUucHJvdG9idWYuQW55XCIsXG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IGJpbmFyeV8xLkJpbmFyeVdyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlVXJsICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS50eXBlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIGJpbmFyeV8xLkJpbmFyeVJlYWRlciA/IGlucHV0IDogbmV3IGJpbmFyeV8xLkJpbmFyeVJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFueSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZVVybCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY3JlYXRlQmFzZUFueSgpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LnR5cGVVcmwpKVxuICAgICAgICAgICAgb2JqLnR5cGVVcmwgPSBTdHJpbmcob2JqZWN0LnR5cGVVcmwpO1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc1NldCkob2JqZWN0LnZhbHVlKSlcbiAgICAgICAgICAgIG9iai52YWx1ZSA9ICgwLCBoZWxwZXJzXzEuYnl0ZXNGcm9tQmFzZTY0KShvYmplY3QudmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudHlwZVVybCAhPT0gdW5kZWZpbmVkICYmIChvYmoudHlwZVVybCA9IG1lc3NhZ2UudHlwZVVybCk7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52YWx1ZSA9ICgwLCBoZWxwZXJzXzEuYmFzZTY0RnJvbUJ5dGVzKShtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnZhbHVlIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQW55KCk7XG4gICAgICAgIG1lc3NhZ2UudHlwZVVybCA9IG9iamVjdC50eXBlVXJsID8/IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgPSBvYmplY3QudmFsdWUgPz8gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/google/protobuf/any.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* eslint-disable */\n/**\n * This file and any referenced files were automatically generated by @cosmology/telescope@1.0.7\n * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain\n * and run the transpile command or yarn proto command to regenerate this bundle.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromJsonTimestamp = exports.fromTimestamp = exports.toTimestamp = exports.setPaginationParams = exports.isObject = exports.isSet = exports.fromDuration = exports.toDuration = exports.omitDefault = exports.base64FromBytes = exports.bytesFromBase64 = void 0;\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nexports.bytesFromBase64 = bytesFromBase64;\nconst btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    arr.forEach((byte) => {\n        bin.push(String.fromCharCode(byte));\n    });\n    return btoa(bin.join(\"\"));\n}\nexports.base64FromBytes = base64FromBytes;\nfunction omitDefault(input) {\n    if (typeof input === \"string\") {\n        return input === \"\" ? undefined : input;\n    }\n    if (typeof input === \"number\") {\n        return input === 0 ? undefined : input;\n    }\n    if (typeof input === \"bigint\") {\n        return input === BigInt(0) ? undefined : input;\n    }\n    throw new Error(`Got unsupported type ${typeof input}`);\n}\nexports.omitDefault = omitDefault;\nfunction toDuration(duration) {\n    return {\n        seconds: BigInt(Math.floor(parseInt(duration) / 1000000000)),\n        nanos: parseInt(duration) % 1000000000,\n    };\n}\nexports.toDuration = toDuration;\nfunction fromDuration(duration) {\n    return (parseInt(duration.seconds.toString()) * 1000000000 + duration.nanos).toString();\n}\nexports.fromDuration = fromDuration;\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\nexports.isSet = isSet;\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nexports.isObject = isObject;\nconst setPaginationParams = (options, pagination) => {\n    if (!pagination) {\n        return options;\n    }\n    if (typeof pagination?.countTotal !== \"undefined\") {\n        options.params[\"pagination.count_total\"] = pagination.countTotal;\n    }\n    if (typeof pagination?.key !== \"undefined\") {\n        // String to Uint8Array\n        // let uint8arr = new Uint8Array(Buffer.from(data,'base64'));\n        // Uint8Array to String\n        options.params[\"pagination.key\"] = Buffer.from(pagination.key).toString(\"base64\");\n    }\n    if (typeof pagination?.limit !== \"undefined\") {\n        options.params[\"pagination.limit\"] = pagination.limit.toString();\n    }\n    if (typeof pagination?.offset !== \"undefined\") {\n        options.params[\"pagination.offset\"] = pagination.offset.toString();\n    }\n    if (typeof pagination?.reverse !== \"undefined\") {\n        options.params[\"pagination.reverse\"] = pagination.reverse;\n    }\n    return options;\n};\nexports.setPaginationParams = setPaginationParams;\nfunction toTimestamp(date) {\n    const seconds = numberToLong(date.getTime() / 1000);\n    const nanos = (date.getTime() % 1000) * 1000000;\n    return {\n        seconds,\n        nanos,\n    };\n}\nexports.toTimestamp = toTimestamp;\nfunction fromTimestamp(t) {\n    let millis = Number(t.seconds) * 1000;\n    millis += t.nanos / 1000000;\n    return new Date(millis);\n}\nexports.fromTimestamp = fromTimestamp;\nconst timestampFromJSON = (object) => {\n    return {\n        seconds: isSet(object.seconds) ? BigInt(object.seconds.toString()) : BigInt(0),\n        nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\n    };\n};\nfunction fromJsonTimestamp(o) {\n    if (o instanceof Date) {\n        return toTimestamp(o);\n    }\n    else if (typeof o === \"string\") {\n        return toTimestamp(new Date(o));\n    }\n    else {\n        return timestampFromJSON(o);\n    }\n}\nexports.fromJsonTimestamp = fromJsonTimestamp;\nfunction numberToLong(number) {\n    return BigInt(Math.trunc(number));\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUIsR0FBRywyQkFBMkIsR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQzlQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hYnViYWtyamltb2gvRGVza3RvcC9Db2RpbmcgU3R1ZmZzL2hhY2thdGhvbi9zZWNyZXQtbmV0d29yay9tZW1lQWlfY29pbl9jcmVhdG9yL2FpLW1lbWUtY29pbi1jcmVhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS9jb3NtanMtdHlwZXNAMC45LjAvbm9kZV9tb2R1bGVzL2Nvc21qcy10eXBlcy9oZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogVGhpcyBmaWxlIGFuZCBhbnkgcmVmZXJlbmNlZCBmaWxlcyB3ZXJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEBjb3Ntb2xvZ3kvdGVsZXNjb3BlQDEuMC43XG4gKiBETyBOT1QgTU9ESUZZIEJZIEhBTkQuIEluc3RlYWQsIGRvd25sb2FkIHRoZSBsYXRlc3QgcHJvdG8gZmlsZXMgZm9yIHlvdXIgY2hhaW5cbiAqIGFuZCBydW4gdGhlIHRyYW5zcGlsZSBjb21tYW5kIG9yIHlhcm4gcHJvdG8gY29tbWFuZCB0byByZWdlbmVyYXRlIHRoaXMgYnVuZGxlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21Kc29uVGltZXN0YW1wID0gZXhwb3J0cy5mcm9tVGltZXN0YW1wID0gZXhwb3J0cy50b1RpbWVzdGFtcCA9IGV4cG9ydHMuc2V0UGFnaW5hdGlvblBhcmFtcyA9IGV4cG9ydHMuaXNPYmplY3QgPSBleHBvcnRzLmlzU2V0ID0gZXhwb3J0cy5mcm9tRHVyYXRpb24gPSBleHBvcnRzLnRvRHVyYXRpb24gPSBleHBvcnRzLm9taXREZWZhdWx0ID0gZXhwb3J0cy5iYXNlNjRGcm9tQnl0ZXMgPSBleHBvcnRzLmJ5dGVzRnJvbUJhc2U2NCA9IHZvaWQgMDtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5jb25zdCBhdG9iID0gZ2xvYmFsVGhpcy5hdG9iIHx8ICgoYjY0KSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGNvbnN0IGJpbiA9IGF0b2IoYjY0KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydHMuYnl0ZXNGcm9tQmFzZTY0ID0gYnl0ZXNGcm9tQmFzZTY0O1xuY29uc3QgYnRvYSA9IGdsb2JhbFRoaXMuYnRvYSB8fCAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sIFwiYmluYXJ5XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBjb25zdCBiaW4gPSBbXTtcbiAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnRvYShiaW4uam9pbihcIlwiKSk7XG59XG5leHBvcnRzLmJhc2U2NEZyb21CeXRlcyA9IGJhc2U2NEZyb21CeXRlcztcbmZ1bmN0aW9uIG9taXREZWZhdWx0KGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IFwiXCIgPyB1bmRlZmluZWQgOiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IDAgPyB1bmRlZmluZWQgOiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IEJpZ0ludCgwKSA/IHVuZGVmaW5lZCA6IGlucHV0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bnN1cHBvcnRlZCB0eXBlICR7dHlwZW9mIGlucHV0fWApO1xufVxuZXhwb3J0cy5vbWl0RGVmYXVsdCA9IG9taXREZWZhdWx0O1xuZnVuY3Rpb24gdG9EdXJhdGlvbihkdXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY29uZHM6IEJpZ0ludChNYXRoLmZsb29yKHBhcnNlSW50KGR1cmF0aW9uKSAvIDEwMDAwMDAwMDApKSxcbiAgICAgICAgbmFub3M6IHBhcnNlSW50KGR1cmF0aW9uKSAlIDEwMDAwMDAwMDAsXG4gICAgfTtcbn1cbmV4cG9ydHMudG9EdXJhdGlvbiA9IHRvRHVyYXRpb247XG5mdW5jdGlvbiBmcm9tRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICByZXR1cm4gKHBhcnNlSW50KGR1cmF0aW9uLnNlY29uZHMudG9TdHJpbmcoKSkgKiAxMDAwMDAwMDAwICsgZHVyYXRpb24ubmFub3MpLnRvU3RyaW5nKCk7XG59XG5leHBvcnRzLmZyb21EdXJhdGlvbiA9IGZyb21EdXJhdGlvbjtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5jb25zdCBzZXRQYWdpbmF0aW9uUGFyYW1zID0gKG9wdGlvbnMsIHBhZ2luYXRpb24pID0+IHtcbiAgICBpZiAoIXBhZ2luYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFnaW5hdGlvbj8uY291bnRUb3RhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvcHRpb25zLnBhcmFtc1tcInBhZ2luYXRpb24uY291bnRfdG90YWxcIl0gPSBwYWdpbmF0aW9uLmNvdW50VG90YWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFnaW5hdGlvbj8ua2V5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIFN0cmluZyB0byBVaW50OEFycmF5XG4gICAgICAgIC8vIGxldCB1aW50OGFyciA9IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKGRhdGEsJ2Jhc2U2NCcpKTtcbiAgICAgICAgLy8gVWludDhBcnJheSB0byBTdHJpbmdcbiAgICAgICAgb3B0aW9ucy5wYXJhbXNbXCJwYWdpbmF0aW9uLmtleVwiXSA9IEJ1ZmZlci5mcm9tKHBhZ2luYXRpb24ua2V5KS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWdpbmF0aW9uPy5saW1pdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvcHRpb25zLnBhcmFtc1tcInBhZ2luYXRpb24ubGltaXRcIl0gPSBwYWdpbmF0aW9uLmxpbWl0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFnaW5hdGlvbj8ub2Zmc2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG9wdGlvbnMucGFyYW1zW1wicGFnaW5hdGlvbi5vZmZzZXRcIl0gPSBwYWdpbmF0aW9uLm9mZnNldC50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhZ2luYXRpb24/LnJldmVyc2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb3B0aW9ucy5wYXJhbXNbXCJwYWdpbmF0aW9uLnJldmVyc2VcIl0gPSBwYWdpbmF0aW9uLnJldmVyc2U7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufTtcbmV4cG9ydHMuc2V0UGFnaW5hdGlvblBhcmFtcyA9IHNldFBhZ2luYXRpb25QYXJhbXM7XG5mdW5jdGlvbiB0b1RpbWVzdGFtcChkYXRlKSB7XG4gICAgY29uc3Qgc2Vjb25kcyA9IG51bWJlclRvTG9uZyhkYXRlLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIGNvbnN0IG5hbm9zID0gKGRhdGUuZ2V0VGltZSgpICUgMTAwMCkgKiAxMDAwMDAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY29uZHMsXG4gICAgICAgIG5hbm9zLFxuICAgIH07XG59XG5leHBvcnRzLnRvVGltZXN0YW1wID0gdG9UaW1lc3RhbXA7XG5mdW5jdGlvbiBmcm9tVGltZXN0YW1wKHQpIHtcbiAgICBsZXQgbWlsbGlzID0gTnVtYmVyKHQuc2Vjb25kcykgKiAxMDAwO1xuICAgIG1pbGxpcyArPSB0Lm5hbm9zIC8gMTAwMDAwMDtcbiAgICByZXR1cm4gbmV3IERhdGUobWlsbGlzKTtcbn1cbmV4cG9ydHMuZnJvbVRpbWVzdGFtcCA9IGZyb21UaW1lc3RhbXA7XG5jb25zdCB0aW1lc3RhbXBGcm9tSlNPTiA9IChvYmplY3QpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNvbmRzOiBpc1NldChvYmplY3Quc2Vjb25kcykgPyBCaWdJbnQob2JqZWN0LnNlY29uZHMudG9TdHJpbmcoKSkgOiBCaWdJbnQoMCksXG4gICAgICAgIG5hbm9zOiBpc1NldChvYmplY3QubmFub3MpID8gTnVtYmVyKG9iamVjdC5uYW5vcykgOiAwLFxuICAgIH07XG59O1xuZnVuY3Rpb24gZnJvbUpzb25UaW1lc3RhbXAobykge1xuICAgIGlmIChvIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gdG9UaW1lc3RhbXAobyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB0b1RpbWVzdGFtcChuZXcgRGF0ZShvKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGltZXN0YW1wRnJvbUpTT04obyk7XG4gICAgfVxufVxuZXhwb3J0cy5mcm9tSnNvblRpbWVzdGFtcCA9IGZyb21Kc29uVGltZXN0YW1wO1xuZnVuY3Rpb24gbnVtYmVyVG9Mb25nKG51bWJlcikge1xuICAgIHJldHVybiBCaWdJbnQoTWF0aC50cnVuYyhudW1iZXIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/utf8.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/utf8.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* eslint-disable */\n/**\n * This file and any referenced files were automatically generated by @cosmology/telescope@1.0.7\n * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain\n * and run the transpile command or yarn proto command to regenerate this bundle.\n */\n// Copyright (c) 2016, Daniel Wirtz  All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// * Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n// * Neither the name of its author, nor the names of its contributors\n//   may be used to endorse or promote products derived from this software\n//   without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.utf8Write = exports.utf8Read = exports.utf8Length = void 0;\n/**\n * Calculates the UTF8 byte length of a string.\n * @param {string} string String\n * @returns {number} Byte length\n */\nfunction utf8Length(str) {\n    let len = 0, c = 0;\n    for (let i = 0; i < str.length; ++i) {\n        c = str.charCodeAt(i);\n        if (c < 128)\n            len += 1;\n        else if (c < 2048)\n            len += 2;\n        else if ((c & 0xfc00) === 0xd800 && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            ++i;\n            len += 4;\n        }\n        else\n            len += 3;\n    }\n    return len;\n}\nexports.utf8Length = utf8Length;\n/**\n * Reads UTF8 bytes as a string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} String read\n */\nfunction utf8Read(buffer, start, end) {\n    const len = end - start;\n    if (len < 1)\n        return \"\";\n    const chunk = [];\n    let parts = [], i = 0, // char offset\n    t; // temporary\n    while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n            chunk[i++] = t;\n        else if (t > 191 && t < 224)\n            chunk[i++] = ((t & 31) << 6) | (buffer[start++] & 63);\n        else if (t > 239 && t < 365) {\n            t =\n                (((t & 7) << 18) |\n                    ((buffer[start++] & 63) << 12) |\n                    ((buffer[start++] & 63) << 6) |\n                    (buffer[start++] & 63)) -\n                    0x10000;\n            chunk[i++] = 0xd800 + (t >> 10);\n            chunk[i++] = 0xdc00 + (t & 1023);\n        }\n        else\n            chunk[i++] = ((t & 15) << 12) | ((buffer[start++] & 63) << 6) | (buffer[start++] & 63);\n        if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode(...chunk));\n            i = 0;\n        }\n    }\n    if (parts) {\n        if (i)\n            parts.push(String.fromCharCode(...chunk.slice(0, i)));\n        return parts.join(\"\");\n    }\n    return String.fromCharCode(...chunk.slice(0, i));\n}\nexports.utf8Read = utf8Read;\n/**\n * Writes a string as UTF8 bytes.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Bytes written\n */\nfunction utf8Write(str, buffer, offset) {\n    const start = offset;\n    let c1, // character 1\n    c2; // character 2\n    for (let i = 0; i < str.length; ++i) {\n        c1 = str.charCodeAt(i);\n        if (c1 < 128) {\n            buffer[offset++] = c1;\n        }\n        else if (c1 < 2048) {\n            buffer[offset++] = (c1 >> 6) | 192;\n            buffer[offset++] = (c1 & 63) | 128;\n        }\n        else if ((c1 & 0xfc00) === 0xd800 && ((c2 = str.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n            ++i;\n            buffer[offset++] = (c1 >> 18) | 240;\n            buffer[offset++] = ((c1 >> 12) & 63) | 128;\n            buffer[offset++] = ((c1 >> 6) & 63) | 128;\n            buffer[offset++] = (c1 & 63) | 128;\n        }\n        else {\n            buffer[offset++] = (c1 >> 12) | 224;\n            buffer[offset++] = ((c1 >> 6) & 63) | 128;\n            buffer[offset++] = (c1 & 63) | 128;\n        }\n    }\n    return offset - start;\n}\nexports.utf8Write = utf8Write;\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvdXRmOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsiL2hvbWUvYWJ1YmFrcmppbW9oL0Rlc2t0b3AvQ29kaW5nIFN0dWZmcy9oYWNrYXRob24vc2VjcmV0LW5ldHdvcmsvbWVtZUFpX2NvaW5fY3JlYXRvci9haS1tZW1lLWNvaW4tY3JlYXRvci9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvdXRmOC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBUaGlzIGZpbGUgYW5kIGFueSByZWZlcmVuY2VkIGZpbGVzIHdlcmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgQGNvc21vbG9neS90ZWxlc2NvcGVAMS4wLjdcbiAqIERPIE5PVCBNT0RJRlkgQlkgSEFORC4gSW5zdGVhZCwgZG93bmxvYWQgdGhlIGxhdGVzdCBwcm90byBmaWxlcyBmb3IgeW91ciBjaGFpblxuICogYW5kIHJ1biB0aGUgdHJhbnNwaWxlIGNvbW1hbmQgb3IgeWFybiBwcm90byBjb21tYW5kIHRvIHJlZ2VuZXJhdGUgdGhpcyBidW5kbGUuXG4gKi9cbi8vIENvcHlyaWdodCAoYykgMjAxNiwgRGFuaWVsIFdpcnR6ICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIGl0cyBhdXRob3IsIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuLy8gICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbi8vICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXRmOFdyaXRlID0gZXhwb3J0cy51dGY4UmVhZCA9IGV4cG9ydHMudXRmOExlbmd0aCA9IHZvaWQgMDtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgVVRGOCBieXRlIGxlbmd0aCBvZiBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxuICovXG5mdW5jdGlvbiB1dGY4TGVuZ3RoKHN0cikge1xuICAgIGxldCBsZW4gPSAwLCBjID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4KVxuICAgICAgICAgICAgbGVuICs9IDE7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxuICAgICAgICAgICAgbGVuICs9IDI7XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChzdHIuY2hhckNvZGVBdChpICsgMSkgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGxlbiArPSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlbiArPSAzO1xuICAgIH1cbiAgICByZXR1cm4gbGVuO1xufVxuZXhwb3J0cy51dGY4TGVuZ3RoID0gdXRmOExlbmd0aDtcbi8qKlxuICogUmVhZHMgVVRGOCBieXRlcyBhcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxuICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlYWRcbiAqL1xuZnVuY3Rpb24gdXRmOFJlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgaWYgKGxlbiA8IDEpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIGNvbnN0IGNodW5rID0gW107XG4gICAgbGV0IHBhcnRzID0gW10sIGkgPSAwLCAvLyBjaGFyIG9mZnNldFxuICAgIHQ7IC8vIHRlbXBvcmFyeVxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xuICAgICAgICBpZiAodCA8IDEyOClcbiAgICAgICAgICAgIGNodW5rW2krK10gPSB0O1xuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKCh0ICYgMzEpIDw8IDYpIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKTtcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XG4gICAgICAgICAgICB0ID1cbiAgICAgICAgICAgICAgICAoKCh0ICYgNykgPDwgMTgpIHxcbiAgICAgICAgICAgICAgICAgICAgKChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIpIHxcbiAgICAgICAgICAgICAgICAgICAgKChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW3N0YXJ0KytdICYgNjMpKSAtXG4gICAgICAgICAgICAgICAgICAgIDB4MTAwMDA7XG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhkODAwICsgKHQgPj4gMTApO1xuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4ZGMwMCArICh0ICYgMTAyMyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICgodCAmIDE1KSA8PCAxMikgfCAoKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2KSB8IChidWZmZXJbc3RhcnQrK10gJiA2Myk7XG4gICAgICAgIGlmIChpID4gODE5MSkge1xuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNodW5rKSk7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFydHMpIHtcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uY2h1bmsuc2xpY2UoMCwgaSkpKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNodW5rLnNsaWNlKDAsIGkpKTtcbn1cbmV4cG9ydHMudXRmOFJlYWQgPSB1dGY4UmVhZDtcbi8qKlxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGVzIHdyaXR0ZW5cbiAqL1xuZnVuY3Rpb24gdXRmOFdyaXRlKHN0ciwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBzdGFydCA9IG9mZnNldDtcbiAgICBsZXQgYzEsIC8vIGNoYXJhY3RlciAxXG4gICAgYzI7IC8vIGNoYXJhY3RlciAyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYzEgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYzEgPCAyMDQ4KSB7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKGMxID4+IDYpIHwgMTkyO1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IChjMSAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYzEgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKChjMiA9IHN0ci5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKGMxID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAoKGMxID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAoKGMxID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IChjMSAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAoYzEgPj4gMTIpIHwgMjI0O1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICgoYzEgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKGMxICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcbn1cbmV4cG9ydHMudXRmOFdyaXRlID0gdXRmOFdyaXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/varint.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/varint.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* eslint-disable */\n/**\n * This file and any referenced files were automatically generated by @cosmology/telescope@1.0.7\n * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain\n * and run the transpile command or yarn proto command to regenerate this bundle.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.writeByte = exports.writeFixed32 = exports.int64Length = exports.writeVarint64 = exports.writeVarint32 = exports.readInt32 = exports.readUInt32 = exports.zzDecode = exports.zzEncode = exports.varint32read = exports.varint32write = exports.uInt64ToString = exports.int64ToString = exports.int64FromString = exports.varint64write = exports.varint64read = void 0;\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */\n/**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */\nfunction varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for (let shift = 0; shift < 28; shift += 7) {\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [lowBits, highBits];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [lowBits, highBits];\n    }\n    for (let shift = 3; shift <= 31; shift += 7) {\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [lowBits, highBits];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\nexports.varint64read = varint64read;\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */\nfunction varint64write(lo, hi, bytes) {\n    for (let i = 0; i < 28; i = i + 7) {\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = ((lo >>> 28) & 0x0f) | ((hi & 0x07) << 4);\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for (let i = 3; i < 31; i = i + 7) {\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push((hi >>> 31) & 0x01);\n}\nexports.varint64write = varint64write;\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\nexports.int64FromString = int64FromString;\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\nexports.int64ToString = int64ToString;\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1fffff) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xffffff;\n    const mid = ((lo >>> 24) | (hi << 8)) & 0xffffff;\n    const high = (hi >> 16) & 0xffff;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nexports.uInt64ToString = uInt64ToString;\nfunction toUnsigned(lo, hi) {\n    return { lo: lo >>> 0, hi: hi >>> 0 };\n}\nfunction newBits(lo, hi) {\n    return { lo: lo | 0, hi: hi | 0 };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */\nfunction negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    }\n    else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */\nconst decimalFrom1e7WithLeadingZeros = (digit1e7) => {\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */\nfunction varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while (value > 0x7f) {\n            bytes.push((value & 0x7f) | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    }\n    else {\n        for (let i = 0; i < 9; i++) {\n            bytes.push((value & 127) | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\nexports.varint32write = varint32write;\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */\nfunction varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)\n        b = this.buf[this.pos++];\n    if ((b & 0x80) != 0)\n        throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\nexports.varint32read = varint32read;\n/**\n * encode zig zag\n */\nfunction zzEncode(lo, hi) {\n    let mask = hi >> 31;\n    hi = (((hi << 1) | (lo >>> 31)) ^ mask) >>> 0;\n    lo = ((lo << 1) ^ mask) >>> 0;\n    return [lo, hi];\n}\nexports.zzEncode = zzEncode;\n/**\n * decode zig zag\n */\nfunction zzDecode(lo, hi) {\n    let mask = -(lo & 1);\n    lo = (((lo >>> 1) | (hi << 31)) ^ mask) >>> 0;\n    hi = ((hi >>> 1) ^ mask) >>> 0;\n    return [lo, hi];\n}\nexports.zzDecode = zzDecode;\n/**\n * unsigned int32 without moving pos.\n */\nfunction readUInt32(buf, pos) {\n    return (buf[pos] | (buf[pos + 1] << 8) | (buf[pos + 2] << 16)) + buf[pos + 3] * 0x1000000;\n}\nexports.readUInt32 = readUInt32;\n/**\n * signed int32 without moving pos.\n */\nfunction readInt32(buf, pos) {\n    return (buf[pos] | (buf[pos + 1] << 8) | (buf[pos + 2] << 16)) + (buf[pos + 3] << 24);\n}\nexports.readInt32 = readInt32;\n/**\n * writing varint32 to pos\n */\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = (val & 127) | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\nexports.writeVarint32 = writeVarint32;\n/**\n * writing varint64 to pos\n */\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = (val.lo & 127) | 128;\n        val.lo = ((val.lo >>> 7) | (val.hi << 25)) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = (val.lo & 127) | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\nexports.writeVarint64 = writeVarint64;\nfunction int64Length(lo, hi) {\n    let part0 = lo, part1 = ((lo >>> 28) | (hi << 4)) >>> 0, part2 = hi >>> 24;\n    return part2 === 0\n        ? part1 === 0\n            ? part0 < 16384\n                ? part0 < 128\n                    ? 1\n                    : 2\n                : part0 < 2097152\n                    ? 3\n                    : 4\n            : part1 < 16384\n                ? part1 < 128\n                    ? 5\n                    : 6\n                : part1 < 2097152\n                    ? 7\n                    : 8\n        : part2 < 128\n            ? 9\n            : 10;\n}\nexports.int64Length = int64Length;\nfunction writeFixed32(val, buf, pos) {\n    buf[pos] = val & 255;\n    buf[pos + 1] = (val >>> 8) & 255;\n    buf[pos + 2] = (val >>> 16) & 255;\n    buf[pos + 3] = val >>> 24;\n}\nexports.writeFixed32 = writeFixed32;\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\nexports.writeByte = writeByte;\n//# sourceMappingURL=varint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29zbWpzLXR5cGVzQDAuOS4wL25vZGVfbW9kdWxlcy9jb3NtanMtdHlwZXMvdmFyaW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQjtBQUN0VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFNBQVM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyIvaG9tZS9hYnViYWtyamltb2gvRGVza3RvcC9Db2RpbmcgU3R1ZmZzL2hhY2thdGhvbi9zZWNyZXQtbmV0d29yay9tZW1lQWlfY29pbl9jcmVhdG9yL2FpLW1lbWUtY29pbi1jcmVhdG9yL25vZGVfbW9kdWxlcy8ucG5wbS9jb3NtanMtdHlwZXNAMC45LjAvbm9kZV9tb2R1bGVzL2Nvc21qcy10eXBlcy92YXJpbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBUaGlzIGZpbGUgYW5kIGFueSByZWZlcmVuY2VkIGZpbGVzIHdlcmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgQGNvc21vbG9neS90ZWxlc2NvcGVAMS4wLjdcbiAqIERPIE5PVCBNT0RJRlkgQlkgSEFORC4gSW5zdGVhZCwgZG93bmxvYWQgdGhlIGxhdGVzdCBwcm90byBmaWxlcyBmb3IgeW91ciBjaGFpblxuICogYW5kIHJ1biB0aGUgdHJhbnNwaWxlIGNvbW1hbmQgb3IgeWFybiBwcm90byBjb21tYW5kIHRvIHJlZ2VuZXJhdGUgdGhpcyBidW5kbGUuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud3JpdGVCeXRlID0gZXhwb3J0cy53cml0ZUZpeGVkMzIgPSBleHBvcnRzLmludDY0TGVuZ3RoID0gZXhwb3J0cy53cml0ZVZhcmludDY0ID0gZXhwb3J0cy53cml0ZVZhcmludDMyID0gZXhwb3J0cy5yZWFkSW50MzIgPSBleHBvcnRzLnJlYWRVSW50MzIgPSBleHBvcnRzLnp6RGVjb2RlID0gZXhwb3J0cy56ekVuY29kZSA9IGV4cG9ydHMudmFyaW50MzJyZWFkID0gZXhwb3J0cy52YXJpbnQzMndyaXRlID0gZXhwb3J0cy51SW50NjRUb1N0cmluZyA9IGV4cG9ydHMuaW50NjRUb1N0cmluZyA9IGV4cG9ydHMuaW50NjRGcm9tU3RyaW5nID0gZXhwb3J0cy52YXJpbnQ2NHdyaXRlID0gZXhwb3J0cy52YXJpbnQ2NHJlYWQgPSB2b2lkIDA7XG4vLyBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBQcm90b2NvbCBCdWZmZXIgY29tcGlsZXIgaXMgb3duZWQgYnkgdGhlIG93bmVyXG4vLyBvZiB0aGUgaW5wdXQgZmlsZSB1c2VkIHdoZW4gZ2VuZXJhdGluZyBpdC4gIFRoaXMgY29kZSBpcyBub3Rcbi8vIHN0YW5kYWxvbmUgYW5kIHJlcXVpcmVzIGEgc3VwcG9ydCBsaWJyYXJ5IHRvIGJlIGxpbmtlZCB3aXRoIGl0LiAgVGhpc1xuLy8gc3VwcG9ydCBsaWJyYXJ5IGlzIGl0c2VsZiBjb3ZlcmVkIGJ5IHRoZSBhYm92ZSBsaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzICovXG4vKipcbiAqIFJlYWQgYSA2NCBiaXQgdmFyaW50IGFzIHR3byBKUyBudW1iZXJzLlxuICpcbiAqIFJldHVybnMgdHVwbGU6XG4gKiBbMF06IGxvdyBiaXRzXG4gKiBbMV06IGhpZ2ggYml0c1xuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDE3NVxuICovXG5mdW5jdGlvbiB2YXJpbnQ2NHJlYWQoKSB7XG4gICAgbGV0IGxvd0JpdHMgPSAwO1xuICAgIGxldCBoaWdoQml0cyA9IDA7XG4gICAgZm9yIChsZXQgc2hpZnQgPSAwOyBzaGlmdCA8IDI4OyBzaGlmdCArPSA3KSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIGxvd0JpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICAgICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtaWRkbGVCeXRlID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgLy8gbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGZpcnN0IDMyIGJpdCBudW1iZXJcbiAgICBsb3dCaXRzIHw9IChtaWRkbGVCeXRlICYgMHgwZikgPDwgMjg7XG4gICAgLy8gMyB1cHBlciBiaXRzIGFyZSBwYXJ0IG9mIHRoZSBuZXh0IDMyIGJpdCBudW1iZXJcbiAgICBoaWdoQml0cyA9IChtaWRkbGVCeXRlICYgMHg3MCkgPj4gNDtcbiAgICBpZiAoKG1pZGRsZUJ5dGUgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgIH1cbiAgICBmb3IgKGxldCBzaGlmdCA9IDM7IHNoaWZ0IDw9IDMxOyBzaGlmdCArPSA3KSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIGhpZ2hCaXRzIHw9IChiICYgMHg3ZikgPDwgc2hpZnQ7XG4gICAgICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhcmludFwiKTtcbn1cbmV4cG9ydHMudmFyaW50NjRyZWFkID0gdmFyaW50NjRyZWFkO1xuLyoqXG4gKiBXcml0ZSBhIDY0IGJpdCB2YXJpbnQsIGdpdmVuIGFzIHR3byBKUyBudW1iZXJzLCB0byB0aGUgZ2l2ZW4gYnl0ZXMgYXJyYXkuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC93cml0ZXIuanMjTDM0NFxuICovXG5mdW5jdGlvbiB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgYnl0ZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI4OyBpID0gaSArIDcpIHtcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBsbyA+Pj4gaTtcbiAgICAgICAgY29uc3QgaGFzTmV4dCA9ICEoc2hpZnQgPj4+IDcgPT0gMCAmJiBoaSA9PSAwKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IChoYXNOZXh0ID8gc2hpZnQgfCAweDgwIDogc2hpZnQpICYgMHhmZjtcbiAgICAgICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICAgICAgaWYgKCFoYXNOZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3BsaXRCaXRzID0gKChsbyA+Pj4gMjgpICYgMHgwZikgfCAoKGhpICYgMHgwNykgPDwgNCk7XG4gICAgY29uc3QgaGFzTW9yZUJpdHMgPSAhKGhpID4+IDMgPT0gMCk7XG4gICAgYnl0ZXMucHVzaCgoaGFzTW9yZUJpdHMgPyBzcGxpdEJpdHMgfCAweDgwIDogc3BsaXRCaXRzKSAmIDB4ZmYpO1xuICAgIGlmICghaGFzTW9yZUJpdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IDMxOyBpID0gaSArIDcpIHtcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBoaSA+Pj4gaTtcbiAgICAgICAgY29uc3QgaGFzTmV4dCA9ICEoc2hpZnQgPj4+IDcgPT0gMCk7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ5dGVzLnB1c2goKGhpID4+PiAzMSkgJiAweDAxKTtcbn1cbmV4cG9ydHMudmFyaW50NjR3cml0ZSA9IHZhcmludDY0d3JpdGU7XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gaW50NjRGcm9tU3RyaW5nKGRlYykge1xuICAgIC8vIENoZWNrIGZvciBtaW51cyBzaWduLlxuICAgIGNvbnN0IG1pbnVzID0gZGVjWzBdID09PSBcIi1cIjtcbiAgICBpZiAobWludXMpIHtcbiAgICAgICAgZGVjID0gZGVjLnNsaWNlKDEpO1xuICAgIH1cbiAgICAvLyBXb3JrIDYgZGVjaW1hbCBkaWdpdHMgYXQgYSB0aW1lLCBhY3RpbmcgbGlrZSB3ZSdyZSBjb252ZXJ0aW5nIGJhc2UgMWU2XG4gICAgLy8gZGlnaXRzIHRvIGJpbmFyeS4gVGhpcyBpcyBzYWZlIHRvIGRvIHdpdGggZmxvYXRpbmcgcG9pbnQgbWF0aCBiZWNhdXNlXG4gICAgLy8gTnVtYmVyLmlzU2FmZUludGVnZXIoQUxMXzMyX0JJVFMgKiAxZTYpID09IHRydWUuXG4gICAgY29uc3QgYmFzZSA9IDFlNjtcbiAgICBsZXQgbG93Qml0cyA9IDA7XG4gICAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgICBmdW5jdGlvbiBhZGQxZTZkaWdpdChiZWdpbiwgZW5kKSB7XG4gICAgICAgIC8vIE5vdGU6IE51bWJlcignJykgaXMgMC5cbiAgICAgICAgY29uc3QgZGlnaXQxZTYgPSBOdW1iZXIoZGVjLnNsaWNlKGJlZ2luLCBlbmQpKTtcbiAgICAgICAgaGlnaEJpdHMgKj0gYmFzZTtcbiAgICAgICAgbG93Qml0cyA9IGxvd0JpdHMgKiBiYXNlICsgZGlnaXQxZTY7XG4gICAgICAgIC8vIENhcnJ5IGJpdHMgZnJvbSBsb3dCaXRzIHRvXG4gICAgICAgIGlmIChsb3dCaXRzID49IFRXT19QV1JfMzJfREJMKSB7XG4gICAgICAgICAgICBoaWdoQml0cyA9IGhpZ2hCaXRzICsgKChsb3dCaXRzIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCk7XG4gICAgICAgICAgICBsb3dCaXRzID0gbG93Qml0cyAlIFRXT19QV1JfMzJfREJMO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZDFlNmRpZ2l0KC0yNCwgLTE4KTtcbiAgICBhZGQxZTZkaWdpdCgtMTgsIC0xMik7XG4gICAgYWRkMWU2ZGlnaXQoLTEyLCAtNik7XG4gICAgYWRkMWU2ZGlnaXQoLTYpO1xuICAgIHJldHVybiBtaW51cyA/IG5lZ2F0ZShsb3dCaXRzLCBoaWdoQml0cykgOiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbmV4cG9ydHMuaW50NjRGcm9tU3RyaW5nID0gaW50NjRGcm9tU3RyaW5nO1xuLyoqXG4gKiBMb3NzbGVzc2x5IGNvbnZlcnRzIGEgNjQtYml0IHNpZ25lZCBpbnRlZ2VyIGluIDMyOjMyIHNwbGl0IHJlcHJlc2VudGF0aW9uXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmZ1bmN0aW9uIGludDY0VG9TdHJpbmcobG8sIGhpKSB7XG4gICAgbGV0IGJpdHMgPSBuZXdCaXRzKGxvLCBoaSk7XG4gICAgLy8gSWYgd2UncmUgdHJlYXRpbmcgdGhlIGlucHV0IGFzIGEgc2lnbmVkIHZhbHVlIGFuZCB0aGUgaGlnaCBiaXQgaXMgc2V0LCBkb1xuICAgIC8vIGEgbWFudWFsIHR3bydzIGNvbXBsZW1lbnQgY29udmVyc2lvbiBiZWZvcmUgdGhlIGRlY2ltYWwgY29udmVyc2lvbi5cbiAgICBjb25zdCBuZWdhdGl2ZSA9IGJpdHMuaGkgJiAweDgwMDAwMDAwO1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBiaXRzID0gbmVnYXRlKGJpdHMubG8sIGJpdHMuaGkpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB1SW50NjRUb1N0cmluZyhiaXRzLmxvLCBiaXRzLmhpKTtcbiAgICByZXR1cm4gbmVnYXRpdmUgPyBcIi1cIiArIHJlc3VsdCA6IHJlc3VsdDtcbn1cbmV4cG9ydHMuaW50NjRUb1N0cmluZyA9IGludDY0VG9TdHJpbmc7XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciBpbiAzMjozMiBzcGxpdCByZXByZXNlbnRhdGlvblxuICogaW50byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmLWphdmFzY3JpcHQvYmxvYi9hNDI4YzU4MjczYWJhZDA3YzY2MDcxZDk3NTNiYzRkMTI4OWRlNDI2L2V4cGVyaW1lbnRhbC9ydW50aW1lL2ludDY0LmpzI0wxMFxuICovXG5mdW5jdGlvbiB1SW50NjRUb1N0cmluZyhsbywgaGkpIHtcbiAgICAoeyBsbywgaGkgfSA9IHRvVW5zaWduZWQobG8sIGhpKSk7XG4gICAgLy8gU2tpcCB0aGUgZXhwZW5zaXZlIGNvbnZlcnNpb24gaWYgdGhlIG51bWJlciBpcyBzbWFsbCBlbm91Z2ggdG8gdXNlIHRoZVxuICAgIC8vIGJ1aWx0LWluIGNvbnZlcnNpb25zLlxuICAgIC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSID0gMHgwMDFGRkZGRiBGRkZGRkZGRiwgdGh1cyBhbnkgbnVtYmVyIHdpdGhcbiAgICAvLyBoaWdoQml0cyA8PSAweDFGRkZGRiBjYW4gYmUgc2FmZWx5IGV4cHJlc3NlZCB3aXRoIGEgZG91YmxlIGFuZCByZXRhaW5cbiAgICAvLyBpbnRlZ2VyIHByZWNpc2lvbi5cbiAgICAvLyBQcm92ZW4gYnk6IE51bWJlci5pc1NhZmVJbnRlZ2VyKDB4MUZGRkZGICogMioqMzIgKyAweEZGRkZGRkZGKSA9PSB0cnVlLlxuICAgIGlmIChoaSA8PSAweDFmZmZmZikge1xuICAgICAgICByZXR1cm4gU3RyaW5nKFRXT19QV1JfMzJfREJMICogaGkgKyBsbyk7XG4gICAgfVxuICAgIC8vIFdoYXQgdGhpcyBjb2RlIGlzIGRvaW5nIGlzIGVzc2VudGlhbGx5IGNvbnZlcnRpbmcgdGhlIGlucHV0IG51bWJlciBmcm9tXG4gICAgLy8gYmFzZS0yIHRvIGJhc2UtMWU3LCB3aGljaCBhbGxvd3MgdXMgdG8gcmVwcmVzZW50IHRoZSA2NC1iaXQgcmFuZ2Ugd2l0aFxuICAgIC8vIG9ubHkgMyAodmVyeSBsYXJnZSkgZGlnaXRzLiBUaG9zZSBkaWdpdHMgYXJlIHRoZW4gdHJpdmlhbCB0byBjb252ZXJ0IHRvXG4gICAgLy8gYSBiYXNlLTEwIHN0cmluZy5cbiAgICAvLyBUaGUgbWFnaWMgbnVtYmVycyB1c2VkIGhlcmUgYXJlIC1cbiAgICAvLyAyXjI0ID0gMTY3NzcyMTYgPSAoMSw2Nzc3MjE2KSBpbiBiYXNlLTFlNy5cbiAgICAvLyAyXjQ4ID0gMjgxNDc0OTc2NzEwNjU2ID0gKDIsODE0NzQ5Nyw2NzEwNjU2KSBpbiBiYXNlLTFlNy5cbiAgICAvLyBTcGxpdCAzMjozMiByZXByZXNlbnRhdGlvbiBpbnRvIDE2OjI0OjI0IHJlcHJlc2VudGF0aW9uIHNvIG91clxuICAgIC8vIGludGVybWVkaWF0ZSBkaWdpdHMgZG9uJ3Qgb3ZlcmZsb3cuXG4gICAgY29uc3QgbG93ID0gbG8gJiAweGZmZmZmZjtcbiAgICBjb25zdCBtaWQgPSAoKGxvID4+PiAyNCkgfCAoaGkgPDwgOCkpICYgMHhmZmZmZmY7XG4gICAgY29uc3QgaGlnaCA9IChoaSA+PiAxNikgJiAweGZmZmY7XG4gICAgLy8gQXNzZW1ibGUgb3VyIHRocmVlIGJhc2UtMWU3IGRpZ2l0cywgaWdub3JpbmcgY2Fycmllcy4gVGhlIG1heGltdW1cbiAgICAvLyB2YWx1ZSBpbiBhIGRpZ2l0IGF0IHRoaXMgc3RlcCBpcyByZXByZXNlbnRhYmxlIGFzIGEgNDgtYml0IGludGVnZXIsIHdoaWNoXG4gICAgLy8gY2FuIGJlIHN0b3JlZCBpbiBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAgbGV0IGRpZ2l0QSA9IGxvdyArIG1pZCAqIDY3NzcyMTYgKyBoaWdoICogNjcxMDY1NjtcbiAgICBsZXQgZGlnaXRCID0gbWlkICsgaGlnaCAqIDgxNDc0OTc7XG4gICAgbGV0IGRpZ2l0QyA9IGhpZ2ggKiAyO1xuICAgIC8vIEFwcGx5IGNhcnJpZXMgZnJvbSBBIHRvIEIgYW5kIGZyb20gQiB0byBDLlxuICAgIGNvbnN0IGJhc2UgPSAxMDAwMDAwMDtcbiAgICBpZiAoZGlnaXRBID49IGJhc2UpIHtcbiAgICAgICAgZGlnaXRCICs9IE1hdGguZmxvb3IoZGlnaXRBIC8gYmFzZSk7XG4gICAgICAgIGRpZ2l0QSAlPSBiYXNlO1xuICAgIH1cbiAgICBpZiAoZGlnaXRCID49IGJhc2UpIHtcbiAgICAgICAgZGlnaXRDICs9IE1hdGguZmxvb3IoZGlnaXRCIC8gYmFzZSk7XG4gICAgICAgIGRpZ2l0QiAlPSBiYXNlO1xuICAgIH1cbiAgICAvLyBJZiBkaWdpdEMgaXMgMCwgdGhlbiB3ZSBzaG91bGQgaGF2ZSByZXR1cm5lZCBpbiB0aGUgdHJpdmlhbCBjb2RlIHBhdGhcbiAgICAvLyBhdCB0aGUgdG9wIGZvciBub24tc2FmZSBpbnRlZ2Vycy4gR2l2ZW4gdGhpcywgd2UgY2FuIGFzc3VtZSBib3RoIGRpZ2l0QlxuICAgIC8vIGFuZCBkaWdpdEEgbmVlZCBsZWFkaW5nIHplcm9zLlxuICAgIHJldHVybiBkaWdpdEMudG9TdHJpbmcoKSArIGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyhkaWdpdEIpICsgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QSk7XG59XG5leHBvcnRzLnVJbnQ2NFRvU3RyaW5nID0gdUludDY0VG9TdHJpbmc7XG5mdW5jdGlvbiB0b1Vuc2lnbmVkKGxvLCBoaSkge1xuICAgIHJldHVybiB7IGxvOiBsbyA+Pj4gMCwgaGk6IGhpID4+PiAwIH07XG59XG5mdW5jdGlvbiBuZXdCaXRzKGxvLCBoaSkge1xuICAgIHJldHVybiB7IGxvOiBsbyB8IDAsIGhpOiBoaSB8IDAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0d28ncyBjb21wbGltZW50IG5lZ2F0aW9uIG9mIGlucHV0LlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQml0d2lzZV9PcGVyYXRvcnMjU2lnbmVkXzMyLWJpdF9pbnRlZ2Vyc1xuICovXG5mdW5jdGlvbiBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIHtcbiAgICBoaWdoQml0cyA9IH5oaWdoQml0cztcbiAgICBpZiAobG93Qml0cykge1xuICAgICAgICBsb3dCaXRzID0gfmxvd0JpdHMgKyAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgbG93Qml0cyBpcyAwLCB0aGVuIGJpdHdpc2Utbm90IGlzIDB4RkZGRkZGRkYsXG4gICAgICAgIC8vIGFkZGluZyAxIHRvIHRoYXQsIHJlc3VsdHMgaW4gMHgxMDAwMDAwMDAsIHdoaWNoIGxlYXZlc1xuICAgICAgICAvLyB0aGUgbG93IGJpdHMgMHgwIGFuZCBzaW1wbHkgYWRkcyBvbmUgdG8gdGhlIGhpZ2ggYml0cy5cbiAgICAgICAgaGlnaEJpdHMgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0JpdHMobG93Qml0cywgaGlnaEJpdHMpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgZGlnaXQxZTcgd2l0aCBsZWFkaW5nIHplcm9zLlxuICovXG5jb25zdCBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MgPSAoZGlnaXQxZTcpID0+IHtcbiAgICBjb25zdCBwYXJ0aWFsID0gU3RyaW5nKGRpZ2l0MWU3KTtcbiAgICByZXR1cm4gXCIwMDAwMDAwXCIuc2xpY2UocGFydGlhbC5sZW5ndGgpICsgcGFydGlhbDtcbn07XG4vKipcbiAqIFdyaXRlIGEgMzIgYml0IHZhcmludCwgc2lnbmVkIG9yIHVuc2lnbmVkLiBTYW1lIGFzIGB2YXJpbnQ2NHdyaXRlKDAsIHZhbHVlLCBieXRlcylgXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi8xYjE4ODMzZjRmMmEyZjY4MWY0ZTRhMjVjZGYzYjBhNDMxMTVlYzI2L2pzL2JpbmFyeS9lbmNvZGVyLmpzI0wxNDRcbiAqL1xuZnVuY3Rpb24gdmFyaW50MzJ3cml0ZSh2YWx1ZSwgYnl0ZXMpIHtcbiAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAvLyB3cml0ZSB2YWx1ZSBhcyB2YXJpbnQgMzJcbiAgICAgICAgd2hpbGUgKHZhbHVlID4gMHg3Zikge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgodmFsdWUgJiAweDdmKSB8IDB4ODApO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICAgICAgfVxuICAgICAgICBieXRlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSAmIDEyNykgfCAxMjgpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiA3O1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2goMSk7XG4gICAgfVxufVxuZXhwb3J0cy52YXJpbnQzMndyaXRlID0gdmFyaW50MzJ3cml0ZTtcbi8qKlxuICogUmVhZCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDIyMFxuICovXG5mdW5jdGlvbiB2YXJpbnQzMnJlYWQoKSB7XG4gICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICBsZXQgcmVzdWx0ID0gYiAmIDB4N2Y7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgNztcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAxNDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAyMTtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEV4dHJhY3Qgb25seSBsYXN0IDQgYml0c1xuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDBmKSA8PCAyODtcbiAgICBmb3IgKGxldCByZWFkQnl0ZXMgPSA1OyAoYiAmIDB4ODApICE9PSAwICYmIHJlYWRCeXRlcyA8IDEwOyByZWFkQnl0ZXMrKylcbiAgICAgICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGlmICgoYiAmIDB4ODApICE9IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgLy8gUmVzdWx0IGNhbiBoYXZlIDMyIGJpdHMsIGNvbnZlcnQgaXQgdG8gdW5zaWduZWRcbiAgICByZXR1cm4gcmVzdWx0ID4+PiAwO1xufVxuZXhwb3J0cy52YXJpbnQzMnJlYWQgPSB2YXJpbnQzMnJlYWQ7XG4vKipcbiAqIGVuY29kZSB6aWcgemFnXG4gKi9cbmZ1bmN0aW9uIHp6RW5jb2RlKGxvLCBoaSkge1xuICAgIGxldCBtYXNrID0gaGkgPj4gMzE7XG4gICAgaGkgPSAoKChoaSA8PCAxKSB8IChsbyA+Pj4gMzEpKSBeIG1hc2spID4+PiAwO1xuICAgIGxvID0gKChsbyA8PCAxKSBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiBbbG8sIGhpXTtcbn1cbmV4cG9ydHMuenpFbmNvZGUgPSB6ekVuY29kZTtcbi8qKlxuICogZGVjb2RlIHppZyB6YWdcbiAqL1xuZnVuY3Rpb24genpEZWNvZGUobG8sIGhpKSB7XG4gICAgbGV0IG1hc2sgPSAtKGxvICYgMSk7XG4gICAgbG8gPSAoKChsbyA+Pj4gMSkgfCAoaGkgPDwgMzEpKSBeIG1hc2spID4+PiAwO1xuICAgIGhpID0gKChoaSA+Pj4gMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gW2xvLCBoaV07XG59XG5leHBvcnRzLnp6RGVjb2RlID0genpEZWNvZGU7XG4vKipcbiAqIHVuc2lnbmVkIGludDMyIHdpdGhvdXQgbW92aW5nIHBvcy5cbiAqL1xuZnVuY3Rpb24gcmVhZFVJbnQzMihidWYsIHBvcykge1xuICAgIHJldHVybiAoYnVmW3Bvc10gfCAoYnVmW3BvcyArIDFdIDw8IDgpIHwgKGJ1Zltwb3MgKyAyXSA8PCAxNikpICsgYnVmW3BvcyArIDNdICogMHgxMDAwMDAwO1xufVxuZXhwb3J0cy5yZWFkVUludDMyID0gcmVhZFVJbnQzMjtcbi8qKlxuICogc2lnbmVkIGludDMyIHdpdGhvdXQgbW92aW5nIHBvcy5cbiAqL1xuZnVuY3Rpb24gcmVhZEludDMyKGJ1ZiwgcG9zKSB7XG4gICAgcmV0dXJuIChidWZbcG9zXSB8IChidWZbcG9zICsgMV0gPDwgOCkgfCAoYnVmW3BvcyArIDJdIDw8IDE2KSkgKyAoYnVmW3BvcyArIDNdIDw8IDI0KTtcbn1cbmV4cG9ydHMucmVhZEludDMyID0gcmVhZEludDMyO1xuLyoqXG4gKiB3cml0aW5nIHZhcmludDMyIHRvIHBvc1xuICovXG5mdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSAodmFsICYgMTI3KSB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICB9XG4gICAgYnVmW3Bvc10gPSB2YWw7XG59XG5leHBvcnRzLndyaXRlVmFyaW50MzIgPSB3cml0ZVZhcmludDMyO1xuLyoqXG4gKiB3cml0aW5nIHZhcmludDY0IHRvIHBvc1xuICovXG5mdW5jdGlvbiB3cml0ZVZhcmludDY0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsLmhpKSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSAodmFsLmxvICYgMTI3KSB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKCh2YWwubG8gPj4+IDcpIHwgKHZhbC5oaSA8PCAyNSkpID4+PiAwO1xuICAgICAgICB2YWwuaGkgPj4+PSA3O1xuICAgIH1cbiAgICB3aGlsZSAodmFsLmxvID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSAodmFsLmxvICYgMTI3KSB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgIH1cbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xufVxuZXhwb3J0cy53cml0ZVZhcmludDY0ID0gd3JpdGVWYXJpbnQ2NDtcbmZ1bmN0aW9uIGludDY0TGVuZ3RoKGxvLCBoaSkge1xuICAgIGxldCBwYXJ0MCA9IGxvLCBwYXJ0MSA9ICgobG8gPj4+IDI4KSB8IChoaSA8PCA0KSkgPj4+IDAsIHBhcnQyID0gaGkgPj4+IDI0O1xuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxuICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcbiAgICAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4XG4gICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICA6IDJcbiAgICAgICAgICAgICAgICA6IHBhcnQwIDwgMjA5NzE1MlxuICAgICAgICAgICAgICAgICAgICA/IDNcbiAgICAgICAgICAgICAgICAgICAgOiA0XG4gICAgICAgICAgICA6IHBhcnQxIDwgMTYzODRcbiAgICAgICAgICAgICAgICA/IHBhcnQxIDwgMTI4XG4gICAgICAgICAgICAgICAgICAgID8gNVxuICAgICAgICAgICAgICAgICAgICA6IDZcbiAgICAgICAgICAgICAgICA6IHBhcnQxIDwgMjA5NzE1MlxuICAgICAgICAgICAgICAgICAgICA/IDdcbiAgICAgICAgICAgICAgICAgICAgOiA4XG4gICAgICAgIDogcGFydDIgPCAxMjhcbiAgICAgICAgICAgID8gOVxuICAgICAgICAgICAgOiAxMDtcbn1cbmV4cG9ydHMuaW50NjRMZW5ndGggPSBpbnQ2NExlbmd0aDtcbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG4gICAgYnVmW3BvcyArIDFdID0gKHZhbCA+Pj4gOCkgJiAyNTU7XG4gICAgYnVmW3BvcyArIDJdID0gKHZhbCA+Pj4gMTYpICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAzXSA9IHZhbCA+Pj4gMjQ7XG59XG5leHBvcnRzLndyaXRlRml4ZWQzMiA9IHdyaXRlRml4ZWQzMjtcbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG59XG5leHBvcnRzLndyaXRlQnl0ZSA9IHdyaXRlQnl0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhcmludC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cosmjs-types@0.9.0/node_modules/cosmjs-types/varint.js\n");

/***/ })

};
;