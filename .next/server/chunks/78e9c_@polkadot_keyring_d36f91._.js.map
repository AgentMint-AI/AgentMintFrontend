{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/packageInfo.js"],"sourcesContent":["export const packageInfo = { name: '@polkadot/keyring', path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto', type: 'esm', version: '13.4.3' };\n"],"names":[],"mappings":";;;;;;;;AAAO,MAAM,cAAc;IAAE,MAAM;IAAqB,MAAM,AAAC,iCAAe,8BAAY,GAAG,GAAI,IAAI,IAAI,8BAAY,GAAG,EAAE,QAAQ,CAAC,SAAS,CAAC,GAAG,IAAI,IAAI,8BAAY,GAAG,EAAE,QAAQ,CAAC,WAAW,CAAC,OAAO,KAAK;IAAQ,MAAM;IAAO,SAAS;AAAS","ignoreList":[0]}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 27, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/packageDetect.js"],"sourcesContent":["import { detectPackage } from '@polkadot/util';\nimport { packageInfo as utilInfo } from '@polkadot/util/packageInfo';\nimport { packageInfo as cryptoInfo } from '@polkadot/util-crypto/packageInfo';\nimport { packageInfo } from './packageInfo.js';\ndetectPackage(packageInfo, null, [cryptoInfo, utilInfo]);\n"],"names":[],"mappings":";AAAA;AAGA;AADA;AADA;;;;;AAGA,CAAA,GAAA,qNAAA,CAAA,gBAAa,AAAD,EAAE,oVAAA,CAAA,cAAW,EAAE,MAAM;IAAC,4QAAA,CAAA,cAAU;IAAE,mNAAA,CAAA,cAAQ;CAAC","ignoreList":[0]}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/pairs.js"],"sourcesContent":["import { isHex, isU8a, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nexport class Pairs {\n    __internal__map = {};\n    add(pair) {\n        this.__internal__map[decodeAddress(pair.address).toString()] = pair;\n        return pair;\n    }\n    all() {\n        return Object.values(this.__internal__map);\n    }\n    get(address) {\n        const pair = this.__internal__map[decodeAddress(address).toString()];\n        if (!pair) {\n            throw new Error(`Unable to retrieve keypair '${isU8a(address) || isHex(address)\n                ? u8aToHex(u8aToU8a(address))\n                : address}'`);\n        }\n        return pair;\n    }\n    remove(address) {\n        delete this.__internal__map[decodeAddress(address).toString()];\n    }\n}\n"],"names":[],"mappings":";;;AACA;AADA;AAAA;AAAA;AAAA;;;AAEO,MAAM;IACT,kBAAkB,CAAC,EAAE;IACrB,IAAI,IAAI,EAAE;QACN,IAAI,CAAC,eAAe,CAAC,CAAA,GAAA,kRAAA,CAAA,gBAAa,AAAD,EAAE,KAAK,OAAO,EAAE,QAAQ,GAAG,GAAG;QAC/D,OAAO;IACX;IACA,MAAM;QACF,OAAO,OAAO,MAAM,CAAC,IAAI,CAAC,eAAe;IAC7C;IACA,IAAI,OAAO,EAAE;QACT,MAAM,OAAO,IAAI,CAAC,eAAe,CAAC,CAAA,GAAA,kRAAA,CAAA,gBAAa,AAAD,EAAE,SAAS,QAAQ,GAAG;QACpE,IAAI,CAAC,MAAM;YACP,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,CAAA,GAAA,iNAAA,CAAA,QAAK,AAAD,EAAE,YAAY,CAAA,GAAA,iNAAA,CAAA,QAAK,AAAD,EAAE,WACjE,CAAA,GAAA,oNAAA,CAAA,WAAQ,AAAD,EAAE,CAAA,GAAA,oNAAA,CAAA,WAAQ,AAAD,EAAE,YAClB,QAAQ,CAAC,CAAC;QACpB;QACA,OAAO;IACX;IACA,OAAO,OAAO,EAAE;QACZ,OAAO,IAAI,CAAC,eAAe,CAAC,CAAA,GAAA,kRAAA,CAAA,gBAAa,AAAD,EAAE,SAAS,QAAQ,GAAG;IAClE;AACJ","ignoreList":[0]}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/pair/defaults.js"],"sourcesContent":["/** public/secret section divider (generation 1-3, will change in 4, don't rely on value) */\nexport const PAIR_DIV = new Uint8Array([161, 35, 3, 33, 0]);\n/** public/secret start block (generation 1-3, will change in 4, don't rely on value) */\nexport const PAIR_HDR = new Uint8Array([48, 83, 2, 1, 1, 48, 5, 6, 3, 43, 101, 112, 4, 34, 4, 32]);\n/** length of a public key */\nexport const PUB_LENGTH = 32;\n/** length of a salt */\nexport const SALT_LENGTH = 32;\n/** length of a secret key */\nexport const SEC_LENGTH = 64;\n/** length of a user-input seed */\nexport const SEED_LENGTH = 32;\n"],"names":[],"mappings":"AAAA,0FAA0F;;;;;;;;AACnF,MAAM,WAAW,IAAI,WAAW;IAAC;IAAK;IAAI;IAAG;IAAI;CAAE;AAEnD,MAAM,WAAW,IAAI,WAAW;IAAC;IAAI;IAAI;IAAG;IAAG;IAAG;IAAI;IAAG;IAAG;IAAG;IAAI;IAAK;IAAK;IAAG;IAAI;IAAG;CAAG;AAE1F,MAAM,aAAa;AAEnB,MAAM,cAAc;AAEpB,MAAM,aAAa;AAEnB,MAAM,cAAc","ignoreList":[0]}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/pair/decode.js"],"sourcesContent":["import { u8aEq } from '@polkadot/util';\nimport { jsonDecryptData } from '@polkadot/util-crypto';\nimport { PAIR_DIV, PAIR_HDR, PUB_LENGTH, SEC_LENGTH, SEED_LENGTH } from './defaults.js';\nconst SEED_OFFSET = PAIR_HDR.length;\n/**\n * Decode a pair, taking into account the generation-specific formats and headers\n *\n * For divisor/headers, don't rely on the magic being static. These will\n * change between generations, aka with the long-awaited 4th generation\n * of the format. The external decode interface is the only way to use and decode these.\n **/\nexport function decodePair(passphrase, encrypted, _encType) {\n    const encType = Array.isArray(_encType) || _encType === undefined\n        ? _encType\n        : [_encType];\n    const decrypted = jsonDecryptData(encrypted, passphrase, encType);\n    const header = decrypted.subarray(0, PAIR_HDR.length);\n    // check the start header (generations 1-3)\n    if (!u8aEq(header, PAIR_HDR)) {\n        throw new Error('Invalid encoding header found in body');\n    }\n    // setup for generation 3 format\n    let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);\n    let divOffset = SEED_OFFSET + SEC_LENGTH;\n    let divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);\n    // old-style (generation 1 & 2), we have the seed here\n    if (!u8aEq(divider, PAIR_DIV)) {\n        divOffset = SEED_OFFSET + SEED_LENGTH;\n        secretKey = decrypted.subarray(SEED_OFFSET, divOffset);\n        divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);\n        // check the divisior at this point (already checked for generation 3)\n        if (!u8aEq(divider, PAIR_DIV)) {\n            throw new Error('Invalid encoding divider found in body');\n        }\n    }\n    const pubOffset = divOffset + PAIR_DIV.length;\n    const publicKey = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);\n    return {\n        publicKey,\n        secretKey\n    };\n}\n"],"names":[],"mappings":";;;AAEA;AADA;AADA;;;;AAGA,MAAM,cAAc,yVAAA,CAAA,WAAQ,CAAC,MAAM;AAQ5B,SAAS,WAAW,UAAU,EAAE,SAAS,EAAE,QAAQ;IACtD,MAAM,UAAU,MAAM,OAAO,CAAC,aAAa,aAAa,YAClD,WACA;QAAC;KAAS;IAChB,MAAM,YAAY,CAAA,GAAA,oRAAA,CAAA,kBAAe,AAAD,EAAE,WAAW,YAAY;IACzD,MAAM,SAAS,UAAU,QAAQ,CAAC,GAAG,yVAAA,CAAA,WAAQ,CAAC,MAAM;IACpD,2CAA2C;IAC3C,IAAI,CAAC,CAAA,GAAA,iNAAA,CAAA,QAAK,AAAD,EAAE,QAAQ,yVAAA,CAAA,WAAQ,GAAG;QAC1B,MAAM,IAAI,MAAM;IACpB;IACA,gCAAgC;IAChC,IAAI,YAAY,UAAU,QAAQ,CAAC,aAAa,cAAc,yVAAA,CAAA,aAAU;IACxE,IAAI,YAAY,cAAc,yVAAA,CAAA,aAAU;IACxC,IAAI,UAAU,UAAU,QAAQ,CAAC,WAAW,YAAY,yVAAA,CAAA,WAAQ,CAAC,MAAM;IACvE,sDAAsD;IACtD,IAAI,CAAC,CAAA,GAAA,iNAAA,CAAA,QAAK,AAAD,EAAE,SAAS,yVAAA,CAAA,WAAQ,GAAG;QAC3B,YAAY,cAAc,yVAAA,CAAA,cAAW;QACrC,YAAY,UAAU,QAAQ,CAAC,aAAa;QAC5C,UAAU,UAAU,QAAQ,CAAC,WAAW,YAAY,yVAAA,CAAA,WAAQ,CAAC,MAAM;QACnE,sEAAsE;QACtE,IAAI,CAAC,CAAA,GAAA,iNAAA,CAAA,QAAK,AAAD,EAAE,SAAS,yVAAA,CAAA,WAAQ,GAAG;YAC3B,MAAM,IAAI,MAAM;QACpB;IACJ;IACA,MAAM,YAAY,YAAY,yVAAA,CAAA,WAAQ,CAAC,MAAM;IAC7C,MAAM,YAAY,UAAU,QAAQ,CAAC,WAAW,YAAY,yVAAA,CAAA,aAAU;IACtE,OAAO;QACH;QACA;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 166, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/pair/encode.js"],"sourcesContent":["import { u8aConcat } from '@polkadot/util';\nimport { naclEncrypt, scryptEncode, scryptToU8a } from '@polkadot/util-crypto';\nimport { PAIR_DIV, PAIR_HDR } from './defaults.js';\n/**\n * Encode a pair with the latest generation format (generation 3)\n **/\nexport function encodePair({ publicKey, secretKey }, passphrase) {\n    if (!secretKey) {\n        throw new Error('Expected a valid secretKey to be passed to encode');\n    }\n    const encoded = u8aConcat(PAIR_HDR, secretKey, PAIR_DIV, publicKey);\n    if (!passphrase) {\n        return encoded;\n    }\n    // this is only for generation 3 (previous generations are only handled in decoding)\n    const { params, password, salt } = scryptEncode(passphrase);\n    const { encrypted, nonce } = naclEncrypt(encoded, password.subarray(0, 32));\n    return u8aConcat(scryptToU8a(salt, params), nonce, encrypted);\n}\n"],"names":[],"mappings":";;;AAAA;AAEA;AADA;AAAA;AAAA;;;;AAKO,SAAS,WAAW,EAAE,SAAS,EAAE,SAAS,EAAE,EAAE,UAAU;IAC3D,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,UAAU,CAAA,GAAA,qNAAA,CAAA,YAAS,AAAD,EAAE,yVAAA,CAAA,WAAQ,EAAE,WAAW,yVAAA,CAAA,WAAQ,EAAE;IACzD,IAAI,CAAC,YAAY;QACb,OAAO;IACX;IACA,oFAAoF;IACpF,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG,CAAA,GAAA,iRAAA,CAAA,eAAY,AAAD,EAAE;IAChD,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,gRAAA,CAAA,cAAW,AAAD,EAAE,SAAS,SAAS,QAAQ,CAAC,GAAG;IACvE,OAAO,CAAA,GAAA,qNAAA,CAAA,YAAS,AAAD,EAAE,CAAA,GAAA,gRAAA,CAAA,cAAW,AAAD,EAAE,MAAM,SAAS,OAAO;AACvD","ignoreList":[0]}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/pair/toJson.js"],"sourcesContent":["import { objectSpread } from '@polkadot/util';\nimport { jsonEncryptFormat } from '@polkadot/util-crypto';\nexport function pairToJson(type, { address, meta }, encoded, isEncrypted) {\n    return objectSpread(jsonEncryptFormat(encoded, ['pkcs8', type], isEncrypted), {\n        address,\n        meta\n    });\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AACO,SAAS,WAAW,IAAI,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,EAAE,OAAO,EAAE,WAAW;IACpE,OAAO,CAAA,GAAA,wNAAA,CAAA,eAAY,AAAD,EAAE,CAAA,GAAA,sRAAA,CAAA,oBAAiB,AAAD,EAAE,SAAS;QAAC;QAAS;KAAK,EAAE,cAAc;QAC1E;QACA;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 218, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/pair/index.js"],"sourcesContent":["import { objectSpread, u8aConcat, u8aEmpty, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsU8a, ed25519PairFromSeed as ed25519FromSeed, ed25519Sign, ethereumEncode, keccakAsU8a, keyExtractPath, keyFromPath, secp256k1Compress, secp256k1Expand, secp256k1PairFromSeed as secp256k1FromSeed, secp256k1Sign, signatureVerify, sr25519PairFromSeed as sr25519FromSeed, sr25519Sign, sr25519VrfSign, sr25519VrfVerify } from '@polkadot/util-crypto';\nimport { decodePair } from './decode.js';\nimport { encodePair } from './encode.js';\nimport { pairToJson } from './toJson.js';\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n    ecdsa: secp256k1FromSeed,\n    ed25519: ed25519FromSeed,\n    ethereum: secp256k1FromSeed,\n    sr25519: sr25519FromSeed\n};\nconst TYPE_PREFIX = {\n    ecdsa: new Uint8Array([2]),\n    ed25519: new Uint8Array([0]),\n    ethereum: new Uint8Array([2]),\n    sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n    ecdsa: (m, p) => secp256k1Sign(m, p, 'blake2'),\n    ed25519: ed25519Sign,\n    ethereum: (m, p) => secp256k1Sign(m, p, 'keccak'),\n    sr25519: sr25519Sign\n};\nconst TYPE_ADDRESS = {\n    ecdsa: (p) => p.length > 32 ? blake2AsU8a(p) : p,\n    ed25519: (p) => p,\n    ethereum: (p) => p.length === 20 ? p : keccakAsU8a(secp256k1Expand(p)),\n    sr25519: (p) => p\n};\nfunction isLocked(secretKey) {\n    return !secretKey || u8aEmpty(secretKey);\n}\nfunction vrfHash(proof, context, extra) {\n    return blake2AsU8a(u8aConcat(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\nexport function createPair({ toSS58, type }, { publicKey, secretKey }, meta = {}, encoded = null, encTypes) {\n    const decodePkcs8 = (passphrase, userEncoded) => {\n        const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);\n        if (decoded.secretKey.length === 64) {\n            publicKey = decoded.publicKey;\n            secretKey = decoded.secretKey;\n        }\n        else {\n            const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n            publicKey = pair.publicKey;\n            secretKey = pair.secretKey;\n        }\n    };\n    const recode = (passphrase) => {\n        isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n        encoded = encodePair({ publicKey, secretKey }, passphrase); // re-encode, latest version\n        encTypes = undefined; // swap to defaults, latest version follows\n        return encoded;\n    };\n    const encodeAddress = () => {\n        const raw = TYPE_ADDRESS[type](publicKey);\n        return type === 'ethereum'\n            ? ethereumEncode(raw)\n            : toSS58(raw);\n    };\n    return {\n        get address() {\n            return encodeAddress();\n        },\n        get addressRaw() {\n            const raw = TYPE_ADDRESS[type](publicKey);\n            return type === 'ethereum'\n                ? raw.slice(-20)\n                : raw;\n        },\n        get isLocked() {\n            return isLocked(secretKey);\n        },\n        get meta() {\n            return meta;\n        },\n        get publicKey() {\n            return publicKey;\n        },\n        get type() {\n            return type;\n        },\n        // eslint-disable-next-line sort-keys\n        decodePkcs8,\n        derive: (suri, meta) => {\n            if (type === 'ethereum') {\n                throw new Error('Unable to derive on this keypair');\n            }\n            else if (isLocked(secretKey)) {\n                throw new Error('Cannot derive on a locked keypair');\n            }\n            const { path } = keyExtractPath(suri);\n            const derived = keyFromPath({ publicKey, secretKey }, path, type);\n            return createPair({ toSS58, type }, derived, meta, null);\n        },\n        encodePkcs8: (passphrase) => {\n            return recode(passphrase);\n        },\n        lock: () => {\n            secretKey = new Uint8Array();\n        },\n        setMeta: (additional) => {\n            meta = objectSpread({}, meta, additional);\n        },\n        sign: (message, options = {}) => {\n            if (isLocked(secretKey)) {\n                throw new Error('Cannot sign with a locked key pair');\n            }\n            return u8aConcat(options.withType\n                ? TYPE_PREFIX[type]\n                : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), { publicKey, secretKey }));\n        },\n        toJson: (passphrase) => {\n            // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these\n            // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)\n            // unless the publicKey is already an address\n            const address = ['ecdsa', 'ethereum'].includes(type)\n                ? publicKey.length === 20\n                    ? u8aToHex(publicKey)\n                    : u8aToHex(secp256k1Compress(publicKey))\n                : encodeAddress();\n            return pairToJson(type, { address, meta }, recode(passphrase), !!passphrase);\n        },\n        unlock: (passphrase) => {\n            return decodePkcs8(passphrase);\n        },\n        verify: (message, signature, signerPublic) => {\n            return signatureVerify(message, signature, TYPE_ADDRESS[type](u8aToU8a(signerPublic))).isValid;\n        },\n        vrfSign: (message, context, extra) => {\n            if (isLocked(secretKey)) {\n                throw new Error('Cannot sign with a locked key pair');\n            }\n            if (type === 'sr25519') {\n                return sr25519VrfSign(message, { secretKey }, context, extra);\n            }\n            const proof = TYPE_SIGNATURE[type](u8aToU8a(message), { publicKey, secretKey });\n            return u8aConcat(vrfHash(proof, context, extra), proof);\n        },\n        vrfVerify: (message, vrfResult, signerPublic, context, extra) => {\n            if (type === 'sr25519') {\n                return sr25519VrfVerify(message, vrfResult, publicKey, context, extra);\n            }\n            const result = signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](u8aToU8a(signerPublic)));\n            return result.isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n        }\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 420, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 426, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/defaults.js"],"sourcesContent":["export const DEV_PHRASE = 'bottom drive obey lake curtain smoke basket hold race lonely fit walk';\nexport const DEV_SEED = '0xfac7959dbfe72f052e5a0c3c8d6530f202b02fd8f9f5ca3580ec8deb7797479e';\n"],"names":[],"mappings":";;;;AAAO,MAAM,aAAa;AACnB,MAAM,WAAW","ignoreList":[0]}},
    {"offset": {"line": 432, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 438, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/keyring.js"],"sourcesContent":["import { hexToU8a, isHex, stringToU8a } from '@polkadot/util';\nimport { base64Decode, decodeAddress, ed25519PairFromSeed as ed25519FromSeed, encodeAddress, ethereumEncode, hdEthereum, keyExtractSuri, keyFromPath, mnemonicToLegacySeed, mnemonicToMiniSecret, secp256k1PairFromSeed as secp256k1FromSeed, sr25519PairFromSeed as sr25519FromSeed } from '@polkadot/util-crypto';\nimport { createPair } from './pair/index.js';\nimport { DEV_PHRASE } from './defaults.js';\nimport { Pairs } from './pairs.js';\nconst PairFromSeed = {\n    ecdsa: (seed) => secp256k1FromSeed(seed),\n    ed25519: (seed) => ed25519FromSeed(seed),\n    ethereum: (seed) => secp256k1FromSeed(seed),\n    sr25519: (seed) => sr25519FromSeed(seed)\n};\nfunction pairToPublic({ publicKey }) {\n    return publicKey;\n}\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\nexport class Keyring {\n    __internal__pairs;\n    __internal__type;\n    __internal__ss58;\n    decodeAddress = decodeAddress;\n    constructor(options = {}) {\n        options.type = options.type || 'ed25519';\n        if (!['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined')) {\n            throw new Error(`Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || 'unknown'}`);\n        }\n        this.__internal__pairs = new Pairs();\n        this.__internal__ss58 = options.ss58Format;\n        this.__internal__type = options.type;\n    }\n    /**\n     * @description retrieve the pairs (alias for getPairs)\n     */\n    get pairs() {\n        return this.getPairs();\n    }\n    /**\n     * @description retrieve the publicKeys (alias for getPublicKeys)\n     */\n    get publicKeys() {\n        return this.getPublicKeys();\n    }\n    /**\n     * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n     */\n    get type() {\n        return this.__internal__type;\n    }\n    /**\n     * @name addPair\n     * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     */\n    addPair(pair) {\n        return this.__internal__pairs.add(pair);\n    }\n    /**\n     * @name addFromAddress\n     * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally\n     * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from them that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {\n        const publicKey = this.decodeAddress(address, ignoreChecksum);\n        return this.addPair(createPair({ toSS58: this.encodeAddress, type }, { publicKey, secretKey: new Uint8Array() }, meta, encoded, encType));\n    }\n    /**\n     * @name addFromJson\n     * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromJson(json, ignoreChecksum) {\n        return this.addPair(this.createFromJson(json, ignoreChecksum));\n    }\n    /**\n     * @name addFromMnemonic\n     * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n     * argument and a metadata argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromMnemonic(mnemonic, meta = {}, type = this.type, wordlist) {\n        return this.addFromUri(mnemonic, meta, type, wordlist);\n    }\n    /**\n     * @name addFromPair\n     * @summary Stores an account created from an explicit publicKey/secreteKey combination\n     */\n    addFromPair(pair, meta = {}, type = this.type) {\n        return this.addPair(this.createFromPair(pair, meta, type));\n    }\n    /**\n     * @name addFromSeed\n     * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n     * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n     * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromSeed(seed, meta = {}, type = this.type) {\n        return this.addPair(createPair({ toSS58: this.encodeAddress, type }, PairFromSeed[type](seed), meta, null));\n    }\n    /**\n     * @name addFromUri\n     * @summary Creates an account via an suri\n     * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n     */\n    addFromUri(suri, meta = {}, type = this.type, wordlist) {\n        return this.addPair(this.createFromUri(suri, meta, type, wordlist));\n    }\n    /**\n     * @name createFromJson\n     * @description Creates a pair from a JSON keyfile\n     */\n    createFromJson({ address, encoded, encoding: { content, type, version }, meta }, ignoreChecksum) {\n        if (version === '3' && content[0] !== 'pkcs8') {\n            throw new Error(`Unable to decode non-pkcs8 type, [${content.join(',')}] found}`);\n        }\n        const cryptoType = version === '0' || !Array.isArray(content)\n            ? this.type\n            : content[1];\n        const encType = !Array.isArray(type)\n            ? [type]\n            : type;\n        if (!['ed25519', 'sr25519', 'ecdsa', 'ethereum'].includes(cryptoType)) {\n            throw new Error(`Unknown crypto type ${cryptoType}`);\n        }\n        // Here the address and publicKey are 32 bytes and isomorphic. This is why the address field needs to be the public key for ethereum type pairs\n        const publicKey = isHex(address)\n            ? hexToU8a(address)\n            : this.decodeAddress(address, ignoreChecksum);\n        const decoded = isHex(encoded)\n            ? hexToU8a(encoded)\n            : base64Decode(encoded);\n        return createPair({ toSS58: this.encodeAddress, type: cryptoType }, { publicKey, secretKey: new Uint8Array() }, meta, decoded, encType);\n    }\n    /**\n     * @name createFromPair\n     * @summary Creates a pair from an explicit publicKey/secreteKey combination\n     */\n    createFromPair(pair, meta = {}, type = this.type) {\n        return createPair({ toSS58: this.encodeAddress, type }, pair, meta, null);\n    }\n    /**\n     * @name createFromUri\n     * @summary Creates a Keypair from an suri\n     * @description This creates a pair from the suri, but does not add it to the keyring\n     */\n    createFromUri(_suri, meta = {}, type = this.type, wordlist) {\n        // here we only aut-add the dev phrase if we have a hard-derived path\n        const suri = _suri.startsWith('//')\n            ? `${DEV_PHRASE}${_suri}`\n            : _suri;\n        const { derivePath, password, path, phrase } = keyExtractSuri(suri);\n        let seed;\n        const isPhraseHex = isHex(phrase, 256);\n        if (isPhraseHex) {\n            seed = hexToU8a(phrase);\n        }\n        else {\n            const parts = phrase.split(' ');\n            if ([12, 15, 18, 21, 24].includes(parts.length)) {\n                seed = type === 'ethereum'\n                    ? mnemonicToLegacySeed(phrase, '', false, 64)\n                    : mnemonicToMiniSecret(phrase, password, wordlist);\n            }\n            else {\n                if (phrase.length > 32) {\n                    throw new Error('specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n                }\n                seed = stringToU8a(phrase.padEnd(32));\n            }\n        }\n        const derived = type === 'ethereum'\n            ? isPhraseHex\n                ? PairFromSeed[type](seed) // for eth, if the private key is provided as suri, it must be derived only once\n                : hdEthereum(seed, derivePath.substring(1))\n            : keyFromPath(PairFromSeed[type](seed), path, type);\n        return createPair({ toSS58: this.encodeAddress, type }, derived, meta, null);\n    }\n    /**\n     * @name encodeAddress\n     * @description Encodes the input into an ss58 representation\n     */\n    encodeAddress = (address, ss58Format) => {\n        return this.type === 'ethereum'\n            ? ethereumEncode(address)\n            : encodeAddress(address, ss58Format ?? this.__internal__ss58);\n    };\n    /**\n     * @name getPair\n     * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n     * @description Returns a keyring pair value from the keyring pair dictionary by performing\n     * a key lookup using the provided account address or public key (after decoding it).\n     */\n    getPair(address) {\n        return this.__internal__pairs.get(address);\n    }\n    /**\n     * @name getPairs\n     * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n     * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n     */\n    getPairs() {\n        return this.__internal__pairs.all();\n    }\n    /**\n     * @name getPublicKeys\n     * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n     * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n     */\n    getPublicKeys() {\n        return this.__internal__pairs.all().map(pairToPublic);\n    }\n    /**\n     * @name removePair\n     * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n     */\n    removePair(address) {\n        this.__internal__pairs.remove(address);\n    }\n    /**\n     * @name setSS58Format;\n     * @description Sets the ss58 format for the keyring\n     */\n    setSS58Format(ss58) {\n        this.__internal__ss58 = ss58;\n    }\n    /**\n     * @name toJson\n     * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n     * @description Returns a JSON object containing the metadata associated with an account\n     * when valid address or public key and when the account passphrase is provided if the account secret\n     * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n     * may backup their account to a JSON file that contains this information.\n     */\n    toJson(address, passphrase) {\n        return this.__internal__pairs.get(address).toJson(passphrase);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 700, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 706, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/index.js"],"sourcesContent":["import './packageDetect.js';\nimport { Keyring } from './bundle.js';\nexport * from './bundle.js';\nexport default Keyring;\n"],"names":[],"mappings":";;;AACA;;;;uCAEe,gVAAA,CAAA,UAAO","ignoreList":[0]}},
    {"offset": {"line": 714, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 729, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 737, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 751, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/testing.js"],"sourcesContent":["import { hexToU8a } from '@polkadot/util';\nimport { createPair } from './pair/index.js';\nimport { Keyring } from './keyring.js';\nexport const PAIRSSR25519 = [\n    {\n        p: '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d',\n        s: '0x98319d4ff8a9508c4bb0cf0b5a78d760a0b2082c02775e6e82370816fedfff48925a225d97aa00682d6a59b95b18780c10d7032336e88f3442b42361f4a66011', // nosemgrep\n        seed: 'Alice',\n        type: 'sr25519'\n    },\n    {\n        p: '0xbe5ddb1579b72e84524fc29e78609e3caf42e85aa118ebfe0b0ad404b5bdd25f',\n        s: '0xe8da6c9d810e020f5e3c7f5af2dea314cbeaa0d72bc6421e92c0808a0c584a6046ab28e97c3ffc77fe12b5a4d37e8cd4afbfebbf2391ffc7cb07c0f38c023efd', // nosemgrep\n        seed: 'Alice//stash',\n        type: 'sr25519'\n    },\n    {\n        p: '0x8eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48',\n        s: '0x081ff694633e255136bdb456c20a5fc8fed21f8b964c11bb17ff534ce80ebd5941ae88f85d0c1bfc37be41c904e1dfc01de8c8067b0d6d5df25dd1ac0894a325', // nosemgrep\n        seed: 'Bob',\n        type: 'sr25519'\n    },\n    {\n        p: '0xfe65717dad0447d715f660a0a58411de509b42e6efb8375f562f58a554d5860e',\n        s: '0xc006507cdfc267a21532394c49ca9b754ca71de21e15a1cdf807c7ceab6d0b6c3ed408d9d35311540dcd54931933e67cf1ea10d46f75408f82b789d9bd212fde', // nosemgrep\n        seed: 'Bob//stash',\n        type: 'sr25519'\n    },\n    {\n        p: '0x90b5ab205c6974c9ea841be688864633dc9ca8a357843eeacf2314649965fe22',\n        s: '0xa8f2d83016052e5d6d77b2f6fd5d59418922a09024cda701b3c34369ec43a7668faf12ff39cd4e5d92bb773972f41a7a5279ebc2ed92264bed8f47d344f8f18c', // nosemgrep\n        seed: 'Charlie',\n        type: 'sr25519'\n    },\n    {\n        p: '0x306721211d5404bd9da88e0204360a1a9ab8b87c66c1bc2fcdd37f3c2222cc20',\n        s: '0x20e05482ca4677e0edbc58ae9a3a59f6ed3b1a9484ba17e64d6fe8688b2b7b5d108c4487b9323b98b11fe36cb301b084e920f7b7895536809a6d62a451b25568', // nosemgrep\n        seed: 'Dave',\n        type: 'sr25519'\n    },\n    {\n        p: '0xe659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df4e',\n        s: '0x683576abfd5dc35273e4264c23095a1bf21c14517bece57c7f0cc5c0ed4ce06a3dbf386b7828f348abe15d76973a72009e6ef86a5c91db2990cb36bb657c6587', // nosemgrep\n        seed: 'Eve',\n        type: 'sr25519'\n    },\n    {\n        p: '0x1cbd2d43530a44705ad088af313e18f80b53ef16b36177cd4b77b846f2a5f07c',\n        s: '0xb835c20f450079cf4f513900ae9faf8df06ad86c681884122c752a4b2bf74d4303e4f21bc6cc62bb4eeed5a9cce642c25e2d2ac1464093b50f6196d78e3a7426', // nosemgrep\n        seed: 'Ferdie',\n        type: 'sr25519'\n    }\n];\nexport const PAIRSETHEREUM = [\n    {\n        name: 'Alith',\n        p: '0x02509540919faacf9ab52146c9aa40db68172d83777250b28e4679176e49ccdd9f',\n        s: '0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Baltathar',\n        p: '0x033bc19e36ff1673910575b6727a974a9abd80c9a875d41ab3e2648dbfb9e4b518',\n        s: '0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Charleth',\n        p: '0x0234637bdc0e89b5d46543bcbf8edff329d2702bc995e27e9af4b1ba009a3c2a5e',\n        s: '0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Dorothy',\n        p: '0x02a00d60b2b408c2a14c5d70cdd2c205db8985ef737a7e55ad20ea32cc9e7c417c',\n        s: '0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Ethan',\n        p: '0x025cdc005b752651cd3f728fb9192182acb3a9c89e19072cbd5b03f3ee1f1b3ffa',\n        s: '0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Faith',\n        p: '0x037964b6c9d546da4646ada28a99e34acaa1d14e7aba861a9055f9bd200c8abf74',\n        s: '0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df', // nosemgrep\n        type: 'ethereum'\n    }\n];\nfunction createMeta(name, seed) {\n    if (!name && !seed) {\n        throw new Error('Testing pair should have either a name or a seed');\n    }\n    return {\n        isTesting: true,\n        name: name || seed?.replace('//', '_').toLowerCase()\n    };\n}\n/**\n * @name testKeyring\n * @summary Create an instance of Keyring pre-populated with locked test accounts\n * @description The test accounts (i.e. alice, bob, dave, eve, ferdie)\n * are available on the dev chain and each test account is initialized with DOT funds.\n */\nexport function createTestKeyring(options = {}, isDerived = true) {\n    const keyring = new Keyring(options);\n    const pairs = options.type === 'ethereum'\n        ? PAIRSETHEREUM\n        : PAIRSSR25519;\n    for (const { name, p, s, seed, type } of pairs) {\n        const meta = createMeta(name, seed);\n        const pair = !isDerived && !name && seed\n            ? keyring.addFromUri(seed, meta, options.type)\n            : keyring.addPair(createPair({ toSS58: keyring.encodeAddress, type }, { publicKey: hexToU8a(p), secretKey: hexToU8a(s) }, meta));\n        pair.lock = () => {\n            // we don't have lock/unlock functionality here\n        };\n    }\n    return keyring;\n}\n"],"names":[],"mappings":";;;;;AAEA;AADA;AADA;;;;AAGO,MAAM,eAAe;IACxB;QACI,GAAG;QACH,GAAG;QACH,MAAM;QACN,MAAM;IACV;IACA;QACI,GAAG;QACH,GAAG;QACH,MAAM;QACN,MAAM;IACV;IACA;QACI,GAAG;QACH,GAAG;QACH,MAAM;QACN,MAAM;IACV;IACA;QACI,GAAG;QACH,GAAG;QACH,MAAM;QACN,MAAM;IACV;IACA;QACI,GAAG;QACH,GAAG;QACH,MAAM;QACN,MAAM;IACV;IACA;QACI,GAAG;QACH,GAAG;QACH,MAAM;QACN,MAAM;IACV;IACA;QACI,GAAG;QACH,GAAG;QACH,MAAM;QACN,MAAM;IACV;IACA;QACI,GAAG;QACH,GAAG;QACH,MAAM;QACN,MAAM;IACV;CACH;AACM,MAAM,gBAAgB;IACzB;QACI,MAAM;QACN,GAAG;QACH,GAAG;QACH,MAAM;IACV;IACA;QACI,MAAM;QACN,GAAG;QACH,GAAG;QACH,MAAM;IACV;IACA;QACI,MAAM;QACN,GAAG;QACH,GAAG;QACH,MAAM;IACV;IACA;QACI,MAAM;QACN,GAAG;QACH,GAAG;QACH,MAAM;IACV;IACA;QACI,MAAM;QACN,GAAG;QACH,GAAG;QACH,MAAM;IACV;IACA;QACI,MAAM;QACN,GAAG;QACH,GAAG;QACH,MAAM;IACV;CACH;AACD,SAAS,WAAW,IAAI,EAAE,IAAI;IAC1B,IAAI,CAAC,QAAQ,CAAC,MAAM;QAChB,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;QACH,WAAW;QACX,MAAM,QAAQ,MAAM,QAAQ,MAAM,KAAK;IAC3C;AACJ;AAOO,SAAS,kBAAkB,UAAU,CAAC,CAAC,EAAE,YAAY,IAAI;IAC5D,MAAM,UAAU,IAAI,gVAAA,CAAA,UAAO,CAAC;IAC5B,MAAM,QAAQ,QAAQ,IAAI,KAAK,aACzB,gBACA;IACN,KAAK,MAAM,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,MAAO;QAC5C,MAAM,OAAO,WAAW,MAAM;QAC9B,MAAM,OAAO,CAAC,aAAa,CAAC,QAAQ,OAC9B,QAAQ,UAAU,CAAC,MAAM,MAAM,QAAQ,IAAI,IAC3C,QAAQ,OAAO,CAAC,CAAA,GAAA,sVAAA,CAAA,aAAU,AAAD,EAAE;YAAE,QAAQ,QAAQ,aAAa;YAAE;QAAK,GAAG;YAAE,WAAW,CAAA,GAAA,oNAAA,CAAA,WAAQ,AAAD,EAAE;YAAI,WAAW,CAAA,GAAA,oNAAA,CAAA,WAAQ,AAAD,EAAE;QAAG,GAAG;QAC9H,KAAK,IAAI,GAAG;QACR,+CAA+C;QACnD;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 877, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 883, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/pair/nobody.js"],"sourcesContent":["const publicKey = new Uint8Array(32);\nconst address = '5C4hrfjw9DjXZTzV3MwzrrAr9P1MJhSrvWGWqi1eSuyUpnhM';\nconst meta = {\n    isTesting: true,\n    name: 'nobody'\n};\nconst json = {\n    address,\n    encoded: '',\n    encoding: {\n        content: ['pkcs8', 'ed25519'],\n        type: 'none',\n        version: '0'\n    },\n    meta\n};\nconst pair = {\n    address,\n    addressRaw: publicKey,\n    decodePkcs8: (_passphrase, _encoded) => undefined,\n    derive: (_suri, _meta) => pair,\n    encodePkcs8: (_passphrase) => new Uint8Array(0),\n    isLocked: true,\n    lock: () => {\n        // no locking, it is always locked\n    },\n    meta,\n    publicKey,\n    setMeta: (_meta) => undefined,\n    sign: (_message) => new Uint8Array(64),\n    toJson: (_passphrase) => json,\n    type: 'ed25519',\n    unlock: (_passphrase) => undefined,\n    verify: (_message, _signature) => false,\n    vrfSign: (_message, _context, _extra) => new Uint8Array(96),\n    vrfVerify: (_message, _vrfResult, _context, _extra) => false\n};\nexport function nobody() {\n    return pair;\n}\n"],"names":[],"mappings":";;;AAAA,MAAM,YAAY,IAAI,WAAW;AACjC,MAAM,UAAU;AAChB,MAAM,OAAO;IACT,WAAW;IACX,MAAM;AACV;AACA,MAAM,OAAO;IACT;IACA,SAAS;IACT,UAAU;QACN,SAAS;YAAC;YAAS;SAAU;QAC7B,MAAM;QACN,SAAS;IACb;IACA;AACJ;AACA,MAAM,OAAO;IACT;IACA,YAAY;IACZ,aAAa,CAAC,aAAa,WAAa;IACxC,QAAQ,CAAC,OAAO,QAAU;IAC1B,aAAa,CAAC,cAAgB,IAAI,WAAW;IAC7C,UAAU;IACV,MAAM;IACF,kCAAkC;IACtC;IACA;IACA;IACA,SAAS,CAAC,QAAU;IACpB,MAAM,CAAC,WAAa,IAAI,WAAW;IACnC,QAAQ,CAAC,cAAgB;IACzB,MAAM;IACN,QAAQ,CAAC,cAAgB;IACzB,QAAQ,CAAC,UAAU,aAAe;IAClC,SAAS,CAAC,UAAU,UAAU,SAAW,IAAI,WAAW;IACxD,WAAW,CAAC,UAAU,YAAY,UAAU,SAAW;AAC3D;AACO,SAAS;IACZ,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 929, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 935, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/node_modules/.pnpm/%40polkadot%2Bkeyring%4013.4.3_%40polkadot%2Butil-crypto%4013.4.3_%40polkadot%2Butil%4013.4.3__%40polkadot%2Butil%4013.4.3/node_modules/%40polkadot/keyring/testingPairs.js"],"sourcesContent":["import { nobody } from './pair/nobody.js';\nimport { createTestKeyring } from './testing.js';\nexport function createTestPairs(options, isDerived = true) {\n    const keyring = createTestKeyring(options, isDerived);\n    const pairs = keyring.getPairs();\n    const map = { nobody: nobody() };\n    for (const p of pairs) {\n        if (p.meta.name) {\n            map[p.meta.name] = p;\n        }\n    }\n    return map;\n}\n"],"names":[],"mappings":";;;AACA;AADA;;;AAEO,SAAS,gBAAgB,OAAO,EAAE,YAAY,IAAI;IACrD,MAAM,UAAU,CAAA,GAAA,gVAAA,CAAA,oBAAiB,AAAD,EAAE,SAAS;IAC3C,MAAM,QAAQ,QAAQ,QAAQ;IAC9B,MAAM,MAAM;QAAE,QAAQ,CAAA,GAAA,uVAAA,CAAA,SAAM,AAAD;IAAI;IAC/B,KAAK,MAAM,KAAK,MAAO;QACnB,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE;YACb,GAAG,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG;QACvB;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 955, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}