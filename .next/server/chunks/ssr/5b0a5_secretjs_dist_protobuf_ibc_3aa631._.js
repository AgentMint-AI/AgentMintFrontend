module.exports = {

"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/client/v1/client.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/core/client/v1/client.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpgradeProposal = exports.ClientUpdateProposal = exports.Params = exports.Height = exports.ClientConsensusStates = exports.ConsensusStateWithHeight = exports.IdentifiedClientState = exports.protobufPackage = void 0;
/* eslint-disable */ const long_1 = __importDefault(__turbopack_require__("[project]/node_modules/.pnpm/long@5.3.1/node_modules/long/umd/index.js [app-ssr] (ecmascript)"));
const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const upgrade_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/cosmos/upgrade/v1beta1/upgrade.js [app-ssr] (ecmascript)");
const any_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/google/protobuf/any.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.core.client.v1";
function createBaseIdentifiedClientState() {
    return {
        client_id: "",
        client_state: undefined
    };
}
exports.IdentifiedClientState = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_id !== "") {
            writer.uint32(10).string(message.client_id);
        }
        if (message.client_state !== undefined) {
            any_1.Any.encode(message.client_state, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedClientState();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.client_state = any_1.Any.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            client_state: isSet(object.client_state) ? any_1.Any.fromJSON(object.client_state) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if (message.client_state !== undefined) {
            obj.client_state = any_1.Any.toJSON(message.client_state);
        }
        return obj;
    },
    create (base) {
        return exports.IdentifiedClientState.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseIdentifiedClientState();
        message.client_id = (_a = object.client_id) !== null && _a !== void 0 ? _a : "";
        message.client_state = object.client_state !== undefined && object.client_state !== null ? any_1.Any.fromPartial(object.client_state) : undefined;
        return message;
    }
};
function createBaseConsensusStateWithHeight() {
    return {
        height: undefined,
        consensus_state: undefined
    };
}
exports.ConsensusStateWithHeight = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.height !== undefined) {
            exports.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensus_state !== undefined) {
            any_1.Any.encode(message.consensus_state, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsensusStateWithHeight();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.height = exports.Height.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.consensus_state = any_1.Any.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            height: isSet(object.height) ? exports.Height.fromJSON(object.height) : undefined,
            consensus_state: isSet(object.consensus_state) ? any_1.Any.fromJSON(object.consensus_state) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.height !== undefined) {
            obj.height = exports.Height.toJSON(message.height);
        }
        if (message.consensus_state !== undefined) {
            obj.consensus_state = any_1.Any.toJSON(message.consensus_state);
        }
        return obj;
    },
    create (base) {
        return exports.ConsensusStateWithHeight.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        const message = createBaseConsensusStateWithHeight();
        message.height = object.height !== undefined && object.height !== null ? exports.Height.fromPartial(object.height) : undefined;
        message.consensus_state = object.consensus_state !== undefined && object.consensus_state !== null ? any_1.Any.fromPartial(object.consensus_state) : undefined;
        return message;
    }
};
function createBaseClientConsensusStates() {
    return {
        client_id: "",
        consensus_states: []
    };
}
exports.ClientConsensusStates = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_id !== "") {
            writer.uint32(10).string(message.client_id);
        }
        for (const v of message.consensus_states){
            exports.ConsensusStateWithHeight.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientConsensusStates();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.consensus_states.push(exports.ConsensusStateWithHeight.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            consensus_states: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.consensus_states) ? object.consensus_states.map((e)=>exports.ConsensusStateWithHeight.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if ((_a = message.consensus_states) === null || _a === void 0 ? void 0 : _a.length) {
            obj.consensus_states = message.consensus_states.map((e)=>exports.ConsensusStateWithHeight.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return exports.ClientConsensusStates.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseClientConsensusStates();
        message.client_id = (_a = object.client_id) !== null && _a !== void 0 ? _a : "";
        message.consensus_states = ((_b = object.consensus_states) === null || _b === void 0 ? void 0 : _b.map((e)=>exports.ConsensusStateWithHeight.fromPartial(e))) || [];
        return message;
    }
};
function createBaseHeight() {
    return {
        revision_number: "0",
        revision_height: "0"
    };
}
exports.Height = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.revision_number !== "0") {
            writer.uint32(8).uint64(message.revision_number);
        }
        if (message.revision_height !== "0") {
            writer.uint32(16).uint64(message.revision_height);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeight();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.revision_number = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.revision_height = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            revision_number: isSet(object.revision_number) ? globalThis.String(object.revision_number) : "0",
            revision_height: isSet(object.revision_height) ? globalThis.String(object.revision_height) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.revision_number !== "0") {
            obj.revision_number = message.revision_number;
        }
        if (message.revision_height !== "0") {
            obj.revision_height = message.revision_height;
        }
        return obj;
    },
    create (base) {
        return exports.Height.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseHeight();
        message.revision_number = (_a = object.revision_number) !== null && _a !== void 0 ? _a : "0";
        message.revision_height = (_b = object.revision_height) !== null && _b !== void 0 ? _b : "0";
        return message;
    }
};
function createBaseParams() {
    return {
        allowed_clients: []
    };
}
exports.Params = {
    encode (message, writer = _m0.Writer.create()) {
        for (const v of message.allowed_clients){
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.allowed_clients.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            allowed_clients: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.allowed_clients) ? object.allowed_clients.map((e)=>globalThis.String(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if ((_a = message.allowed_clients) === null || _a === void 0 ? void 0 : _a.length) {
            obj.allowed_clients = message.allowed_clients;
        }
        return obj;
    },
    create (base) {
        return exports.Params.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseParams();
        message.allowed_clients = ((_a = object.allowed_clients) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBaseClientUpdateProposal() {
    return {
        title: "",
        description: "",
        subject_client_id: "",
        substitute_client_id: ""
    };
}
exports.ClientUpdateProposal = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.subject_client_id !== "") {
            writer.uint32(26).string(message.subject_client_id);
        }
        if (message.substitute_client_id !== "") {
            writer.uint32(34).string(message.substitute_client_id);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientUpdateProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.subject_client_id = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.substitute_client_id = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            title: isSet(object.title) ? globalThis.String(object.title) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            subject_client_id: isSet(object.subject_client_id) ? globalThis.String(object.subject_client_id) : "",
            substitute_client_id: isSet(object.substitute_client_id) ? globalThis.String(object.substitute_client_id) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.subject_client_id !== "") {
            obj.subject_client_id = message.subject_client_id;
        }
        if (message.substitute_client_id !== "") {
            obj.substitute_client_id = message.substitute_client_id;
        }
        return obj;
    },
    create (base) {
        return exports.ClientUpdateProposal.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseClientUpdateProposal();
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.subject_client_id = (_c = object.subject_client_id) !== null && _c !== void 0 ? _c : "";
        message.substitute_client_id = (_d = object.substitute_client_id) !== null && _d !== void 0 ? _d : "";
        return message;
    }
};
function createBaseUpgradeProposal() {
    return {
        title: "",
        description: "",
        plan: undefined,
        upgraded_client_state: undefined
    };
}
exports.UpgradeProposal = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.plan !== undefined) {
            upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        if (message.upgraded_client_state !== undefined) {
            any_1.Any.encode(message.upgraded_client_state, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpgradeProposal();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.upgraded_client_state = any_1.Any.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            title: isSet(object.title) ? globalThis.String(object.title) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            plan: isSet(object.plan) ? upgrade_1.Plan.fromJSON(object.plan) : undefined,
            upgraded_client_state: isSet(object.upgraded_client_state) ? any_1.Any.fromJSON(object.upgraded_client_state) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.plan !== undefined) {
            obj.plan = upgrade_1.Plan.toJSON(message.plan);
        }
        if (message.upgraded_client_state !== undefined) {
            obj.upgraded_client_state = any_1.Any.toJSON(message.upgraded_client_state);
        }
        return obj;
    },
    create (base) {
        return exports.UpgradeProposal.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseUpgradeProposal();
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.plan = object.plan !== undefined && object.plan !== null ? upgrade_1.Plan.fromPartial(object.plan) : undefined;
        message.upgraded_client_state = object.upgraded_client_state !== undefined && object.upgraded_client_state !== null ? any_1.Any.fromPartial(object.upgraded_client_state) : undefined;
        return message;
    }
};
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=client.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/channel/v1/channel.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/core/channel/v1/channel.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.Timeout = exports.Acknowledgement = exports.PacketId = exports.PacketState = exports.Packet = exports.Counterparty = exports.IdentifiedChannel = exports.Channel = exports.orderToJSON = exports.orderFromJSON = exports.Order = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;
/* eslint-disable */ const long_1 = __importDefault(__turbopack_require__("[project]/node_modules/.pnpm/long@5.3.1/node_modules/long/umd/index.js [app-ssr] (ecmascript)"));
const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const client_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/client/v1/client.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.core.channel.v1";
/**
 * State defines if a channel is in one of the following states:
 * CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
 */ var State;
(function(State) {
    /** STATE_UNINITIALIZED_UNSPECIFIED - Default State */ State[State["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
    /** STATE_INIT - A channel has just started the opening handshake. */ State[State["STATE_INIT"] = 1] = "STATE_INIT";
    /** STATE_TRYOPEN - A channel has acknowledged the handshake step on the counterparty chain. */ State[State["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
    /**
     * STATE_OPEN - A channel has completed the handshake. Open channels are
     * ready to send and receive packets.
     */ State[State["STATE_OPEN"] = 3] = "STATE_OPEN";
    /**
     * STATE_CLOSED - A channel has been closed and can no longer be used to send or receive
     * packets.
     */ State[State["STATE_CLOSED"] = 4] = "STATE_CLOSED";
    /** STATE_FLUSHING - A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets. */ State[State["STATE_FLUSHING"] = 5] = "STATE_FLUSHING";
    /** STATE_FLUSHCOMPLETE - A channel has just completed flushing any in-flight packets. */ State[State["STATE_FLUSHCOMPLETE"] = 6] = "STATE_FLUSHCOMPLETE";
    State[State["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(State = exports.State || (exports.State = {}));
function stateFromJSON(object) {
    switch(object){
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
            return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
            return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
            return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
            return State.STATE_OPEN;
        case 4:
        case "STATE_CLOSED":
            return State.STATE_CLOSED;
        case 5:
        case "STATE_FLUSHING":
            return State.STATE_FLUSHING;
        case 6:
        case "STATE_FLUSHCOMPLETE":
            return State.STATE_FLUSHCOMPLETE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return State.UNRECOGNIZED;
    }
}
exports.stateFromJSON = stateFromJSON;
function stateToJSON(object) {
    switch(object){
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
            return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
            return "STATE_INIT";
        case State.STATE_TRYOPEN:
            return "STATE_TRYOPEN";
        case State.STATE_OPEN:
            return "STATE_OPEN";
        case State.STATE_CLOSED:
            return "STATE_CLOSED";
        case State.STATE_FLUSHING:
            return "STATE_FLUSHING";
        case State.STATE_FLUSHCOMPLETE:
            return "STATE_FLUSHCOMPLETE";
        case State.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.stateToJSON = stateToJSON;
/** Order defines if a channel is ORDERED or UNORDERED */ var Order;
(function(Order) {
    /** ORDER_NONE_UNSPECIFIED - zero-value for channel ordering */ Order[Order["ORDER_NONE_UNSPECIFIED"] = 0] = "ORDER_NONE_UNSPECIFIED";
    /**
     * ORDER_UNORDERED - packets can be delivered in any order, which may differ from the order in
     * which they were sent.
     */ Order[Order["ORDER_UNORDERED"] = 1] = "ORDER_UNORDERED";
    /** ORDER_ORDERED - packets are delivered exactly in the order which they were sent */ Order[Order["ORDER_ORDERED"] = 2] = "ORDER_ORDERED";
    Order[Order["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Order = exports.Order || (exports.Order = {}));
function orderFromJSON(object) {
    switch(object){
        case 0:
        case "ORDER_NONE_UNSPECIFIED":
            return Order.ORDER_NONE_UNSPECIFIED;
        case 1:
        case "ORDER_UNORDERED":
            return Order.ORDER_UNORDERED;
        case 2:
        case "ORDER_ORDERED":
            return Order.ORDER_ORDERED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Order.UNRECOGNIZED;
    }
}
exports.orderFromJSON = orderFromJSON;
function orderToJSON(object) {
    switch(object){
        case Order.ORDER_NONE_UNSPECIFIED:
            return "ORDER_NONE_UNSPECIFIED";
        case Order.ORDER_UNORDERED:
            return "ORDER_UNORDERED";
        case Order.ORDER_ORDERED:
            return "ORDER_ORDERED";
        case Order.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.orderToJSON = orderToJSON;
function createBaseChannel() {
    return {
        state: 0,
        ordering: 0,
        counterparty: undefined,
        connection_hops: [],
        version: "",
        upgrade_sequence: "0"
    };
}
exports.Channel = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.state !== 0) {
            writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
            writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== undefined) {
            exports.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connection_hops){
            writer.uint32(34).string(v);
        }
        if (message.version !== "") {
            writer.uint32(42).string(message.version);
        }
        if (message.upgrade_sequence !== "0") {
            writer.uint32(48).uint64(message.upgrade_sequence);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChannel();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.state = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.ordering = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.connection_hops.push(reader.string());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.upgrade_sequence = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            state: isSet(object.state) ? stateFromJSON(object.state) : 0,
            ordering: isSet(object.ordering) ? orderFromJSON(object.ordering) : 0,
            counterparty: isSet(object.counterparty) ? exports.Counterparty.fromJSON(object.counterparty) : undefined,
            connection_hops: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.connection_hops) ? object.connection_hops.map((e)=>globalThis.String(e)) : [],
            version: isSet(object.version) ? globalThis.String(object.version) : "",
            upgrade_sequence: isSet(object.upgrade_sequence) ? globalThis.String(object.upgrade_sequence) : "0"
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.state !== 0) {
            obj.state = stateToJSON(message.state);
        }
        if (message.ordering !== 0) {
            obj.ordering = orderToJSON(message.ordering);
        }
        if (message.counterparty !== undefined) {
            obj.counterparty = exports.Counterparty.toJSON(message.counterparty);
        }
        if ((_a = message.connection_hops) === null || _a === void 0 ? void 0 : _a.length) {
            obj.connection_hops = message.connection_hops;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.upgrade_sequence !== "0") {
            obj.upgrade_sequence = message.upgrade_sequence;
        }
        return obj;
    },
    create (base) {
        return exports.Channel.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseChannel();
        message.state = (_a = object.state) !== null && _a !== void 0 ? _a : 0;
        message.ordering = (_b = object.ordering) !== null && _b !== void 0 ? _b : 0;
        message.counterparty = object.counterparty !== undefined && object.counterparty !== null ? exports.Counterparty.fromPartial(object.counterparty) : undefined;
        message.connection_hops = ((_c = object.connection_hops) === null || _c === void 0 ? void 0 : _c.map((e)=>e)) || [];
        message.version = (_d = object.version) !== null && _d !== void 0 ? _d : "";
        message.upgrade_sequence = (_e = object.upgrade_sequence) !== null && _e !== void 0 ? _e : "0";
        return message;
    }
};
function createBaseIdentifiedChannel() {
    return {
        state: 0,
        ordering: 0,
        counterparty: undefined,
        connection_hops: [],
        version: "",
        port_id: "",
        channel_id: "",
        upgrade_sequence: "0"
    };
}
exports.IdentifiedChannel = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.state !== 0) {
            writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
            writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== undefined) {
            exports.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connection_hops){
            writer.uint32(34).string(v);
        }
        if (message.version !== "") {
            writer.uint32(42).string(message.version);
        }
        if (message.port_id !== "") {
            writer.uint32(50).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(58).string(message.channel_id);
        }
        if (message.upgrade_sequence !== "0") {
            writer.uint32(64).uint64(message.upgrade_sequence);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedChannel();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.state = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.ordering = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.connection_hops.push(reader.string());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.upgrade_sequence = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            state: isSet(object.state) ? stateFromJSON(object.state) : 0,
            ordering: isSet(object.ordering) ? orderFromJSON(object.ordering) : 0,
            counterparty: isSet(object.counterparty) ? exports.Counterparty.fromJSON(object.counterparty) : undefined,
            connection_hops: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.connection_hops) ? object.connection_hops.map((e)=>globalThis.String(e)) : [],
            version: isSet(object.version) ? globalThis.String(object.version) : "",
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            upgrade_sequence: isSet(object.upgrade_sequence) ? globalThis.String(object.upgrade_sequence) : "0"
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.state !== 0) {
            obj.state = stateToJSON(message.state);
        }
        if (message.ordering !== 0) {
            obj.ordering = orderToJSON(message.ordering);
        }
        if (message.counterparty !== undefined) {
            obj.counterparty = exports.Counterparty.toJSON(message.counterparty);
        }
        if ((_a = message.connection_hops) === null || _a === void 0 ? void 0 : _a.length) {
            obj.connection_hops = message.connection_hops;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.upgrade_sequence !== "0") {
            obj.upgrade_sequence = message.upgrade_sequence;
        }
        return obj;
    },
    create (base) {
        return exports.IdentifiedChannel.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseIdentifiedChannel();
        message.state = (_a = object.state) !== null && _a !== void 0 ? _a : 0;
        message.ordering = (_b = object.ordering) !== null && _b !== void 0 ? _b : 0;
        message.counterparty = object.counterparty !== undefined && object.counterparty !== null ? exports.Counterparty.fromPartial(object.counterparty) : undefined;
        message.connection_hops = ((_c = object.connection_hops) === null || _c === void 0 ? void 0 : _c.map((e)=>e)) || [];
        message.version = (_d = object.version) !== null && _d !== void 0 ? _d : "";
        message.port_id = (_e = object.port_id) !== null && _e !== void 0 ? _e : "";
        message.channel_id = (_f = object.channel_id) !== null && _f !== void 0 ? _f : "";
        message.upgrade_sequence = (_g = object.upgrade_sequence) !== null && _g !== void 0 ? _g : "0";
        return message;
    }
};
function createBaseCounterparty() {
    return {
        port_id: "",
        channel_id: ""
    };
}
exports.Counterparty = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        return obj;
    },
    create (base) {
        return exports.Counterparty.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseCounterparty();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBasePacket() {
    return {
        sequence: "0",
        source_port: "",
        source_channel: "",
        destination_port: "",
        destination_channel: "",
        data: new Uint8Array(0),
        timeout_height: undefined,
        timeout_timestamp: "0"
    };
}
exports.Packet = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.sequence !== "0") {
            writer.uint32(8).uint64(message.sequence);
        }
        if (message.source_port !== "") {
            writer.uint32(18).string(message.source_port);
        }
        if (message.source_channel !== "") {
            writer.uint32(26).string(message.source_channel);
        }
        if (message.destination_port !== "") {
            writer.uint32(34).string(message.destination_port);
        }
        if (message.destination_channel !== "") {
            writer.uint32(42).string(message.destination_channel);
        }
        if (message.data.length !== 0) {
            writer.uint32(50).bytes(message.data);
        }
        if (message.timeout_height !== undefined) {
            client_1.Height.encode(message.timeout_height, writer.uint32(58).fork()).ldelim();
        }
        if (message.timeout_timestamp !== "0") {
            writer.uint32(64).uint64(message.timeout_timestamp);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePacket();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.sequence = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.source_port = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.source_channel = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.destination_port = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.destination_channel = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.timeout_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.timeout_timestamp = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            sequence: isSet(object.sequence) ? globalThis.String(object.sequence) : "0",
            source_port: isSet(object.source_port) ? globalThis.String(object.source_port) : "",
            source_channel: isSet(object.source_channel) ? globalThis.String(object.source_channel) : "",
            destination_port: isSet(object.destination_port) ? globalThis.String(object.destination_port) : "",
            destination_channel: isSet(object.destination_channel) ? globalThis.String(object.destination_channel) : "",
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
            timeout_height: isSet(object.timeout_height) ? client_1.Height.fromJSON(object.timeout_height) : undefined,
            timeout_timestamp: isSet(object.timeout_timestamp) ? globalThis.String(object.timeout_timestamp) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.sequence !== "0") {
            obj.sequence = message.sequence;
        }
        if (message.source_port !== "") {
            obj.source_port = message.source_port;
        }
        if (message.source_channel !== "") {
            obj.source_channel = message.source_channel;
        }
        if (message.destination_port !== "") {
            obj.destination_port = message.destination_port;
        }
        if (message.destination_channel !== "") {
            obj.destination_channel = message.destination_channel;
        }
        if (message.data.length !== 0) {
            obj.data = base64FromBytes(message.data);
        }
        if (message.timeout_height !== undefined) {
            obj.timeout_height = client_1.Height.toJSON(message.timeout_height);
        }
        if (message.timeout_timestamp !== "0") {
            obj.timeout_timestamp = message.timeout_timestamp;
        }
        return obj;
    },
    create (base) {
        return exports.Packet.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBasePacket();
        message.sequence = (_a = object.sequence) !== null && _a !== void 0 ? _a : "0";
        message.source_port = (_b = object.source_port) !== null && _b !== void 0 ? _b : "";
        message.source_channel = (_c = object.source_channel) !== null && _c !== void 0 ? _c : "";
        message.destination_port = (_d = object.destination_port) !== null && _d !== void 0 ? _d : "";
        message.destination_channel = (_e = object.destination_channel) !== null && _e !== void 0 ? _e : "";
        message.data = (_f = object.data) !== null && _f !== void 0 ? _f : new Uint8Array(0);
        message.timeout_height = object.timeout_height !== undefined && object.timeout_height !== null ? client_1.Height.fromPartial(object.timeout_height) : undefined;
        message.timeout_timestamp = (_g = object.timeout_timestamp) !== null && _g !== void 0 ? _g : "0";
        return message;
    }
};
function createBasePacketState() {
    return {
        port_id: "",
        channel_id: "",
        sequence: "0",
        data: new Uint8Array(0)
    };
}
exports.PacketState = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.sequence !== "0") {
            writer.uint32(24).uint64(message.sequence);
        }
        if (message.data.length !== 0) {
            writer.uint32(34).bytes(message.data);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePacketState();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.sequence = longToString(reader.uint64());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            sequence: isSet(object.sequence) ? globalThis.String(object.sequence) : "0",
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0)
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.sequence !== "0") {
            obj.sequence = message.sequence;
        }
        if (message.data.length !== 0) {
            obj.data = base64FromBytes(message.data);
        }
        return obj;
    },
    create (base) {
        return exports.PacketState.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBasePacketState();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.sequence = (_c = object.sequence) !== null && _c !== void 0 ? _c : "0";
        message.data = (_d = object.data) !== null && _d !== void 0 ? _d : new Uint8Array(0);
        return message;
    }
};
function createBasePacketId() {
    return {
        port_id: "",
        channel_id: "",
        sequence: "0"
    };
}
exports.PacketId = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.sequence !== "0") {
            writer.uint32(24).uint64(message.sequence);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePacketId();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.sequence = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            sequence: isSet(object.sequence) ? globalThis.String(object.sequence) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.sequence !== "0") {
            obj.sequence = message.sequence;
        }
        return obj;
    },
    create (base) {
        return exports.PacketId.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBasePacketId();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.sequence = (_c = object.sequence) !== null && _c !== void 0 ? _c : "0";
        return message;
    }
};
function createBaseAcknowledgement() {
    return {
        result: undefined,
        error: undefined
    };
}
exports.Acknowledgement = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.result !== undefined) {
            writer.uint32(170).bytes(message.result);
        }
        if (message.error !== undefined) {
            writer.uint32(178).string(message.error);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAcknowledgement();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 21:
                    if (tag !== 170) {
                        break;
                    }
                    message.result = reader.bytes();
                    continue;
                case 22:
                    if (tag !== 178) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? bytesFromBase64(object.result) : undefined,
            error: isSet(object.error) ? globalThis.String(object.error) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.result !== undefined) {
            obj.result = base64FromBytes(message.result);
        }
        if (message.error !== undefined) {
            obj.error = message.error;
        }
        return obj;
    },
    create (base) {
        return exports.Acknowledgement.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseAcknowledgement();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : undefined;
        message.error = (_b = object.error) !== null && _b !== void 0 ? _b : undefined;
        return message;
    }
};
function createBaseTimeout() {
    return {
        height: undefined,
        timestamp: "0"
    };
}
exports.Timeout = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.height !== undefined) {
            client_1.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.timestamp !== "0") {
            writer.uint32(16).uint64(message.timestamp);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTimeout();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.timestamp = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            height: isSet(object.height) ? client_1.Height.fromJSON(object.height) : undefined,
            timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.height !== undefined) {
            obj.height = client_1.Height.toJSON(message.height);
        }
        if (message.timestamp !== "0") {
            obj.timestamp = message.timestamp;
        }
        return obj;
    },
    create (base) {
        return exports.Timeout.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseTimeout();
        message.height = object.height !== undefined && object.height !== null ? client_1.Height.fromPartial(object.height) : undefined;
        message.timestamp = (_a = object.timestamp) !== null && _a !== void 0 ? _a : "0";
        return message;
    }
};
function createBaseParams() {
    return {
        upgrade_timeout: undefined
    };
}
exports.Params = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.upgrade_timeout !== undefined) {
            exports.Timeout.encode(message.upgrade_timeout, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.upgrade_timeout = exports.Timeout.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            upgrade_timeout: isSet(object.upgrade_timeout) ? exports.Timeout.fromJSON(object.upgrade_timeout) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.upgrade_timeout !== undefined) {
            obj.upgrade_timeout = exports.Timeout.toJSON(message.upgrade_timeout);
        }
        return obj;
    },
    create (base) {
        return exports.Params.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        const message = createBaseParams();
        message.upgrade_timeout = object.upgrade_timeout !== undefined && object.upgrade_timeout !== null ? exports.Timeout.fromPartial(object.upgrade_timeout) : undefined;
        return message;
    }
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    } else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i){
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    } else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=channel.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/interchain_accounts/v1/packet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/applications/interchain_accounts/v1/packet.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CosmosTx = exports.InterchainAccountPacketData = exports.typeToJSON = exports.typeFromJSON = exports.Type = exports.protobufPackage = void 0;
/* eslint-disable */ const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const any_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/google/protobuf/any.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.applications.interchain_accounts.v1";
/**
 * Type defines a classification of message issued from a controller chain to its associated interchain accounts
 * host
 */ var Type;
(function(Type) {
    /** TYPE_UNSPECIFIED - Default zero value enumeration */ Type[Type["TYPE_UNSPECIFIED"] = 0] = "TYPE_UNSPECIFIED";
    /** TYPE_EXECUTE_TX - Execute a transaction on an interchain accounts host chain */ Type[Type["TYPE_EXECUTE_TX"] = 1] = "TYPE_EXECUTE_TX";
    Type[Type["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Type = exports.Type || (exports.Type = {}));
function typeFromJSON(object) {
    switch(object){
        case 0:
        case "TYPE_UNSPECIFIED":
            return Type.TYPE_UNSPECIFIED;
        case 1:
        case "TYPE_EXECUTE_TX":
            return Type.TYPE_EXECUTE_TX;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Type.UNRECOGNIZED;
    }
}
exports.typeFromJSON = typeFromJSON;
function typeToJSON(object) {
    switch(object){
        case Type.TYPE_UNSPECIFIED:
            return "TYPE_UNSPECIFIED";
        case Type.TYPE_EXECUTE_TX:
            return "TYPE_EXECUTE_TX";
        case Type.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.typeToJSON = typeToJSON;
function createBaseInterchainAccountPacketData() {
    return {
        type: 0,
        data: new Uint8Array(0),
        memo: ""
    };
}
exports.InterchainAccountPacketData = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        if (message.memo !== "") {
            writer.uint32(26).string(message.memo);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInterchainAccountPacketData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.memo = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            type: isSet(object.type) ? typeFromJSON(object.type) : 0,
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
            memo: isSet(object.memo) ? globalThis.String(object.memo) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = typeToJSON(message.type);
        }
        if (message.data.length !== 0) {
            obj.data = base64FromBytes(message.data);
        }
        if (message.memo !== "") {
            obj.memo = message.memo;
        }
        return obj;
    },
    create (base) {
        return exports.InterchainAccountPacketData.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseInterchainAccountPacketData();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.memo = (_c = object.memo) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseCosmosTx() {
    return {
        messages: []
    };
}
exports.CosmosTx = {
    encode (message, writer = _m0.Writer.create()) {
        for (const v of message.messages){
            any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCosmosTx();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.messages.push(any_1.Any.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            messages: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.messages) ? object.messages.map((e)=>any_1.Any.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if ((_a = message.messages) === null || _a === void 0 ? void 0 : _a.length) {
            obj.messages = message.messages.map((e)=>any_1.Any.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return exports.CosmosTx.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseCosmosTx();
        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e)=>any_1.Any.fromPartial(e))) || [];
        return message;
    }
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    } else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i){
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    } else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=packet.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/interchain_accounts/controller/v1/controller.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/applications/interchain_accounts/controller/v1/controller.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.protobufPackage = void 0;
/* eslint-disable */ const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
exports.protobufPackage = "ibc.applications.interchain_accounts.controller.v1";
function createBaseParams() {
    return {
        controller_enabled: false
    };
}
exports.Params = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.controller_enabled !== false) {
            writer.uint32(8).bool(message.controller_enabled);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.controller_enabled = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            controller_enabled: isSet(object.controller_enabled) ? globalThis.Boolean(object.controller_enabled) : false
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.controller_enabled !== false) {
            obj.controller_enabled = message.controller_enabled;
        }
        return obj;
    },
    create (base) {
        return exports.Params.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseParams();
        message.controller_enabled = (_a = object.controller_enabled) !== null && _a !== void 0 ? _a : false;
        return message;
    }
};
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=controller.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/interchain_accounts/controller/v1/tx.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/applications/interchain_accounts/controller/v1/tx.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgServiceName = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgSendTxResponse = exports.MsgSendTx = exports.MsgRegisterInterchainAccountResponse = exports.MsgRegisterInterchainAccount = exports.protobufPackage = void 0;
/* eslint-disable */ const long_1 = __importDefault(__turbopack_require__("[project]/node_modules/.pnpm/long@5.3.1/node_modules/long/umd/index.js [app-ssr] (ecmascript)"));
const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const channel_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/channel/v1/channel.js [app-ssr] (ecmascript)");
const packet_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/interchain_accounts/v1/packet.js [app-ssr] (ecmascript)");
const controller_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/interchain_accounts/controller/v1/controller.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.applications.interchain_accounts.controller.v1";
function createBaseMsgRegisterInterchainAccount() {
    return {
        owner: "",
        connection_id: "",
        version: "",
        ordering: 0
    };
}
exports.MsgRegisterInterchainAccount = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.owner !== "") {
            writer.uint32(10).string(message.owner);
        }
        if (message.connection_id !== "") {
            writer.uint32(18).string(message.connection_id);
        }
        if (message.version !== "") {
            writer.uint32(26).string(message.version);
        }
        if (message.ordering !== 0) {
            writer.uint32(32).int32(message.ordering);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterInterchainAccount();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.owner = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.connection_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.ordering = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
            connection_id: isSet(object.connection_id) ? globalThis.String(object.connection_id) : "",
            version: isSet(object.version) ? globalThis.String(object.version) : "",
            ordering: isSet(object.ordering) ? (0, channel_1.orderFromJSON)(object.ordering) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.owner !== "") {
            obj.owner = message.owner;
        }
        if (message.connection_id !== "") {
            obj.connection_id = message.connection_id;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.ordering !== 0) {
            obj.ordering = (0, channel_1.orderToJSON)(message.ordering);
        }
        return obj;
    },
    create (base) {
        return exports.MsgRegisterInterchainAccount.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgRegisterInterchainAccount();
        message.owner = (_a = object.owner) !== null && _a !== void 0 ? _a : "";
        message.connection_id = (_b = object.connection_id) !== null && _b !== void 0 ? _b : "";
        message.version = (_c = object.version) !== null && _c !== void 0 ? _c : "";
        message.ordering = (_d = object.ordering) !== null && _d !== void 0 ? _d : 0;
        return message;
    }
};
function createBaseMsgRegisterInterchainAccountResponse() {
    return {
        channel_id: "",
        port_id: ""
    };
}
exports.MsgRegisterInterchainAccountResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.channel_id !== "") {
            writer.uint32(10).string(message.channel_id);
        }
        if (message.port_id !== "") {
            writer.uint32(18).string(message.port_id);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterInterchainAccountResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        return obj;
    },
    create (base) {
        return exports.MsgRegisterInterchainAccountResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseMsgRegisterInterchainAccountResponse();
        message.channel_id = (_a = object.channel_id) !== null && _a !== void 0 ? _a : "";
        message.port_id = (_b = object.port_id) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseMsgSendTx() {
    return {
        owner: "",
        connection_id: "",
        packet_data: undefined,
        relative_timeout: "0"
    };
}
exports.MsgSendTx = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.owner !== "") {
            writer.uint32(10).string(message.owner);
        }
        if (message.connection_id !== "") {
            writer.uint32(18).string(message.connection_id);
        }
        if (message.packet_data !== undefined) {
            packet_1.InterchainAccountPacketData.encode(message.packet_data, writer.uint32(26).fork()).ldelim();
        }
        if (message.relative_timeout !== "0") {
            writer.uint32(32).uint64(message.relative_timeout);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSendTx();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.owner = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.connection_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.packet_data = packet_1.InterchainAccountPacketData.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.relative_timeout = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
            connection_id: isSet(object.connection_id) ? globalThis.String(object.connection_id) : "",
            packet_data: isSet(object.packet_data) ? packet_1.InterchainAccountPacketData.fromJSON(object.packet_data) : undefined,
            relative_timeout: isSet(object.relative_timeout) ? globalThis.String(object.relative_timeout) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.owner !== "") {
            obj.owner = message.owner;
        }
        if (message.connection_id !== "") {
            obj.connection_id = message.connection_id;
        }
        if (message.packet_data !== undefined) {
            obj.packet_data = packet_1.InterchainAccountPacketData.toJSON(message.packet_data);
        }
        if (message.relative_timeout !== "0") {
            obj.relative_timeout = message.relative_timeout;
        }
        return obj;
    },
    create (base) {
        return exports.MsgSendTx.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseMsgSendTx();
        message.owner = (_a = object.owner) !== null && _a !== void 0 ? _a : "";
        message.connection_id = (_b = object.connection_id) !== null && _b !== void 0 ? _b : "";
        message.packet_data = object.packet_data !== undefined && object.packet_data !== null ? packet_1.InterchainAccountPacketData.fromPartial(object.packet_data) : undefined;
        message.relative_timeout = (_c = object.relative_timeout) !== null && _c !== void 0 ? _c : "0";
        return message;
    }
};
function createBaseMsgSendTxResponse() {
    return {
        sequence: "0"
    };
}
exports.MsgSendTxResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.sequence !== "0") {
            writer.uint32(8).uint64(message.sequence);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSendTxResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.sequence = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            sequence: isSet(object.sequence) ? globalThis.String(object.sequence) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.sequence !== "0") {
            obj.sequence = message.sequence;
        }
        return obj;
    },
    create (base) {
        return exports.MsgSendTxResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgSendTxResponse();
        message.sequence = (_a = object.sequence) !== null && _a !== void 0 ? _a : "0";
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        signer: "",
        params: undefined
    };
}
exports.MsgUpdateParams = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.signer !== "") {
            writer.uint32(10).string(message.signer);
        }
        if (message.params !== undefined) {
            controller_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.params = controller_1.Params.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
            params: isSet(object.params) ? controller_1.Params.fromJSON(object.params) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        if (message.params !== undefined) {
            obj.params = controller_1.Params.toJSON(message.params);
        }
        return obj;
    },
    create (base) {
        return exports.MsgUpdateParams.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgUpdateParams();
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        message.params = object.params !== undefined && object.params !== null ? controller_1.Params.fromPartial(object.params) : undefined;
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgUpdateParamsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
exports.MsgServiceName = "ibc.applications.interchain_accounts.controller.v1.Msg";
class MsgClientImpl {
    constructor(rpc, opts){
        this.service = (opts === null || opts === void 0 ? void 0 : opts.service) || exports.MsgServiceName;
        this.rpc = rpc;
        this.RegisterInterchainAccount = this.RegisterInterchainAccount.bind(this);
        this.SendTx = this.SendTx.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
    }
    RegisterInterchainAccount(request) {
        const data = exports.MsgRegisterInterchainAccount.encode(request).finish();
        const promise = this.rpc.request(this.service, "RegisterInterchainAccount", data);
        return promise.then((data)=>exports.MsgRegisterInterchainAccountResponse.decode(_m0.Reader.create(data)));
    }
    SendTx(request) {
        const data = exports.MsgSendTx.encode(request).finish();
        const promise = this.rpc.request(this.service, "SendTx", data);
        return promise.then((data)=>exports.MsgSendTxResponse.decode(_m0.Reader.create(data)));
    }
    UpdateParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request(this.service, "UpdateParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(_m0.Reader.create(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=tx.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/fee/v1/fee.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/applications/fee/v1/fee.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IdentifiedPacketFees = exports.PacketFees = exports.PacketFee = exports.Fee = exports.protobufPackage = void 0;
/* eslint-disable */ const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const coin_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/cosmos/base/v1beta1/coin.js [app-ssr] (ecmascript)");
const channel_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/channel/v1/channel.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.applications.fee.v1";
function createBaseFee() {
    return {
        recv_fee: [],
        ack_fee: [],
        timeout_fee: []
    };
}
exports.Fee = {
    encode (message, writer = _m0.Writer.create()) {
        for (const v of message.recv_fee){
            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.ack_fee){
            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.timeout_fee){
            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFee();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.recv_fee.push(coin_1.Coin.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ack_fee.push(coin_1.Coin.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.timeout_fee.push(coin_1.Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            recv_fee: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.recv_fee) ? object.recv_fee.map((e)=>coin_1.Coin.fromJSON(e)) : [],
            ack_fee: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.ack_fee) ? object.ack_fee.map((e)=>coin_1.Coin.fromJSON(e)) : [],
            timeout_fee: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.timeout_fee) ? object.timeout_fee.map((e)=>coin_1.Coin.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _a, _b, _c;
        const obj = {};
        if ((_a = message.recv_fee) === null || _a === void 0 ? void 0 : _a.length) {
            obj.recv_fee = message.recv_fee.map((e)=>coin_1.Coin.toJSON(e));
        }
        if ((_b = message.ack_fee) === null || _b === void 0 ? void 0 : _b.length) {
            obj.ack_fee = message.ack_fee.map((e)=>coin_1.Coin.toJSON(e));
        }
        if ((_c = message.timeout_fee) === null || _c === void 0 ? void 0 : _c.length) {
            obj.timeout_fee = message.timeout_fee.map((e)=>coin_1.Coin.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return exports.Fee.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseFee();
        message.recv_fee = ((_a = object.recv_fee) === null || _a === void 0 ? void 0 : _a.map((e)=>coin_1.Coin.fromPartial(e))) || [];
        message.ack_fee = ((_b = object.ack_fee) === null || _b === void 0 ? void 0 : _b.map((e)=>coin_1.Coin.fromPartial(e))) || [];
        message.timeout_fee = ((_c = object.timeout_fee) === null || _c === void 0 ? void 0 : _c.map((e)=>coin_1.Coin.fromPartial(e))) || [];
        return message;
    }
};
function createBasePacketFee() {
    return {
        fee: undefined,
        refund_address: "",
        relayers: []
    };
}
exports.PacketFee = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.fee !== undefined) {
            exports.Fee.encode(message.fee, writer.uint32(10).fork()).ldelim();
        }
        if (message.refund_address !== "") {
            writer.uint32(18).string(message.refund_address);
        }
        for (const v of message.relayers){
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePacketFee();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fee = exports.Fee.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.refund_address = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.relayers.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            fee: isSet(object.fee) ? exports.Fee.fromJSON(object.fee) : undefined,
            refund_address: isSet(object.refund_address) ? globalThis.String(object.refund_address) : "",
            relayers: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.relayers) ? object.relayers.map((e)=>globalThis.String(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.fee !== undefined) {
            obj.fee = exports.Fee.toJSON(message.fee);
        }
        if (message.refund_address !== "") {
            obj.refund_address = message.refund_address;
        }
        if ((_a = message.relayers) === null || _a === void 0 ? void 0 : _a.length) {
            obj.relayers = message.relayers;
        }
        return obj;
    },
    create (base) {
        return exports.PacketFee.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBasePacketFee();
        message.fee = object.fee !== undefined && object.fee !== null ? exports.Fee.fromPartial(object.fee) : undefined;
        message.refund_address = (_a = object.refund_address) !== null && _a !== void 0 ? _a : "";
        message.relayers = ((_b = object.relayers) === null || _b === void 0 ? void 0 : _b.map((e)=>e)) || [];
        return message;
    }
};
function createBasePacketFees() {
    return {
        packet_fees: []
    };
}
exports.PacketFees = {
    encode (message, writer = _m0.Writer.create()) {
        for (const v of message.packet_fees){
            exports.PacketFee.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePacketFees();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.packet_fees.push(exports.PacketFee.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            packet_fees: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.packet_fees) ? object.packet_fees.map((e)=>exports.PacketFee.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if ((_a = message.packet_fees) === null || _a === void 0 ? void 0 : _a.length) {
            obj.packet_fees = message.packet_fees.map((e)=>exports.PacketFee.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return exports.PacketFees.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBasePacketFees();
        message.packet_fees = ((_a = object.packet_fees) === null || _a === void 0 ? void 0 : _a.map((e)=>exports.PacketFee.fromPartial(e))) || [];
        return message;
    }
};
function createBaseIdentifiedPacketFees() {
    return {
        packet_id: undefined,
        packet_fees: []
    };
}
exports.IdentifiedPacketFees = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.packet_id !== undefined) {
            channel_1.PacketId.encode(message.packet_id, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.packet_fees){
            exports.PacketFee.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedPacketFees();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.packet_id = channel_1.PacketId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.packet_fees.push(exports.PacketFee.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            packet_id: isSet(object.packet_id) ? channel_1.PacketId.fromJSON(object.packet_id) : undefined,
            packet_fees: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.packet_fees) ? object.packet_fees.map((e)=>exports.PacketFee.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.packet_id !== undefined) {
            obj.packet_id = channel_1.PacketId.toJSON(message.packet_id);
        }
        if ((_a = message.packet_fees) === null || _a === void 0 ? void 0 : _a.length) {
            obj.packet_fees = message.packet_fees.map((e)=>exports.PacketFee.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return exports.IdentifiedPacketFees.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseIdentifiedPacketFees();
        message.packet_id = object.packet_id !== undefined && object.packet_id !== null ? channel_1.PacketId.fromPartial(object.packet_id) : undefined;
        message.packet_fees = ((_a = object.packet_fees) === null || _a === void 0 ? void 0 : _a.map((e)=>exports.PacketFee.fromPartial(e))) || [];
        return message;
    }
};
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=fee.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/fee/v1/tx.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/applications/fee/v1/tx.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgServiceName = exports.MsgPayPacketFeeAsyncResponse = exports.MsgPayPacketFeeAsync = exports.MsgPayPacketFeeResponse = exports.MsgPayPacketFee = exports.MsgRegisterCounterpartyPayeeResponse = exports.MsgRegisterCounterpartyPayee = exports.MsgRegisterPayeeResponse = exports.MsgRegisterPayee = exports.protobufPackage = void 0;
/* eslint-disable */ const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const channel_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/channel/v1/channel.js [app-ssr] (ecmascript)");
const fee_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/fee/v1/fee.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.applications.fee.v1";
function createBaseMsgRegisterPayee() {
    return {
        port_id: "",
        channel_id: "",
        relayer: "",
        payee: ""
    };
}
exports.MsgRegisterPayee = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.relayer !== "") {
            writer.uint32(26).string(message.relayer);
        }
        if (message.payee !== "") {
            writer.uint32(34).string(message.payee);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterPayee();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.relayer = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.payee = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            relayer: isSet(object.relayer) ? globalThis.String(object.relayer) : "",
            payee: isSet(object.payee) ? globalThis.String(object.payee) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.relayer !== "") {
            obj.relayer = message.relayer;
        }
        if (message.payee !== "") {
            obj.payee = message.payee;
        }
        return obj;
    },
    create (base) {
        return exports.MsgRegisterPayee.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgRegisterPayee();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.relayer = (_c = object.relayer) !== null && _c !== void 0 ? _c : "";
        message.payee = (_d = object.payee) !== null && _d !== void 0 ? _d : "";
        return message;
    }
};
function createBaseMsgRegisterPayeeResponse() {
    return {};
}
exports.MsgRegisterPayeeResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterPayeeResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgRegisterPayeeResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgRegisterPayeeResponse();
        return message;
    }
};
function createBaseMsgRegisterCounterpartyPayee() {
    return {
        port_id: "",
        channel_id: "",
        relayer: "",
        counterparty_payee: ""
    };
}
exports.MsgRegisterCounterpartyPayee = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.relayer !== "") {
            writer.uint32(26).string(message.relayer);
        }
        if (message.counterparty_payee !== "") {
            writer.uint32(34).string(message.counterparty_payee);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterCounterpartyPayee();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.relayer = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.counterparty_payee = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            relayer: isSet(object.relayer) ? globalThis.String(object.relayer) : "",
            counterparty_payee: isSet(object.counterparty_payee) ? globalThis.String(object.counterparty_payee) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.relayer !== "") {
            obj.relayer = message.relayer;
        }
        if (message.counterparty_payee !== "") {
            obj.counterparty_payee = message.counterparty_payee;
        }
        return obj;
    },
    create (base) {
        return exports.MsgRegisterCounterpartyPayee.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgRegisterCounterpartyPayee();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.relayer = (_c = object.relayer) !== null && _c !== void 0 ? _c : "";
        message.counterparty_payee = (_d = object.counterparty_payee) !== null && _d !== void 0 ? _d : "";
        return message;
    }
};
function createBaseMsgRegisterCounterpartyPayeeResponse() {
    return {};
}
exports.MsgRegisterCounterpartyPayeeResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterCounterpartyPayeeResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgRegisterCounterpartyPayeeResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgRegisterCounterpartyPayeeResponse();
        return message;
    }
};
function createBaseMsgPayPacketFee() {
    return {
        fee: undefined,
        source_port_id: "",
        source_channel_id: "",
        signer: "",
        relayers: []
    };
}
exports.MsgPayPacketFee = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.fee !== undefined) {
            fee_1.Fee.encode(message.fee, writer.uint32(10).fork()).ldelim();
        }
        if (message.source_port_id !== "") {
            writer.uint32(18).string(message.source_port_id);
        }
        if (message.source_channel_id !== "") {
            writer.uint32(26).string(message.source_channel_id);
        }
        if (message.signer !== "") {
            writer.uint32(34).string(message.signer);
        }
        for (const v of message.relayers){
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPayPacketFee();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fee = fee_1.Fee.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.source_port_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.source_channel_id = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.relayers.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            fee: isSet(object.fee) ? fee_1.Fee.fromJSON(object.fee) : undefined,
            source_port_id: isSet(object.source_port_id) ? globalThis.String(object.source_port_id) : "",
            source_channel_id: isSet(object.source_channel_id) ? globalThis.String(object.source_channel_id) : "",
            signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
            relayers: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.relayers) ? object.relayers.map((e)=>globalThis.String(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.fee !== undefined) {
            obj.fee = fee_1.Fee.toJSON(message.fee);
        }
        if (message.source_port_id !== "") {
            obj.source_port_id = message.source_port_id;
        }
        if (message.source_channel_id !== "") {
            obj.source_channel_id = message.source_channel_id;
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        if ((_a = message.relayers) === null || _a === void 0 ? void 0 : _a.length) {
            obj.relayers = message.relayers;
        }
        return obj;
    },
    create (base) {
        return exports.MsgPayPacketFee.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgPayPacketFee();
        message.fee = object.fee !== undefined && object.fee !== null ? fee_1.Fee.fromPartial(object.fee) : undefined;
        message.source_port_id = (_a = object.source_port_id) !== null && _a !== void 0 ? _a : "";
        message.source_channel_id = (_b = object.source_channel_id) !== null && _b !== void 0 ? _b : "";
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        message.relayers = ((_d = object.relayers) === null || _d === void 0 ? void 0 : _d.map((e)=>e)) || [];
        return message;
    }
};
function createBaseMsgPayPacketFeeResponse() {
    return {};
}
exports.MsgPayPacketFeeResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPayPacketFeeResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgPayPacketFeeResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgPayPacketFeeResponse();
        return message;
    }
};
function createBaseMsgPayPacketFeeAsync() {
    return {
        packet_id: undefined,
        packet_fee: undefined
    };
}
exports.MsgPayPacketFeeAsync = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.packet_id !== undefined) {
            channel_1.PacketId.encode(message.packet_id, writer.uint32(10).fork()).ldelim();
        }
        if (message.packet_fee !== undefined) {
            fee_1.PacketFee.encode(message.packet_fee, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPayPacketFeeAsync();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.packet_id = channel_1.PacketId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.packet_fee = fee_1.PacketFee.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            packet_id: isSet(object.packet_id) ? channel_1.PacketId.fromJSON(object.packet_id) : undefined,
            packet_fee: isSet(object.packet_fee) ? fee_1.PacketFee.fromJSON(object.packet_fee) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.packet_id !== undefined) {
            obj.packet_id = channel_1.PacketId.toJSON(message.packet_id);
        }
        if (message.packet_fee !== undefined) {
            obj.packet_fee = fee_1.PacketFee.toJSON(message.packet_fee);
        }
        return obj;
    },
    create (base) {
        return exports.MsgPayPacketFeeAsync.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        const message = createBaseMsgPayPacketFeeAsync();
        message.packet_id = object.packet_id !== undefined && object.packet_id !== null ? channel_1.PacketId.fromPartial(object.packet_id) : undefined;
        message.packet_fee = object.packet_fee !== undefined && object.packet_fee !== null ? fee_1.PacketFee.fromPartial(object.packet_fee) : undefined;
        return message;
    }
};
function createBaseMsgPayPacketFeeAsyncResponse() {
    return {};
}
exports.MsgPayPacketFeeAsyncResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPayPacketFeeAsyncResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgPayPacketFeeAsyncResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgPayPacketFeeAsyncResponse();
        return message;
    }
};
exports.MsgServiceName = "ibc.applications.fee.v1.Msg";
class MsgClientImpl {
    constructor(rpc, opts){
        this.service = (opts === null || opts === void 0 ? void 0 : opts.service) || exports.MsgServiceName;
        this.rpc = rpc;
        this.RegisterPayee = this.RegisterPayee.bind(this);
        this.RegisterCounterpartyPayee = this.RegisterCounterpartyPayee.bind(this);
        this.PayPacketFee = this.PayPacketFee.bind(this);
        this.PayPacketFeeAsync = this.PayPacketFeeAsync.bind(this);
    }
    RegisterPayee(request) {
        const data = exports.MsgRegisterPayee.encode(request).finish();
        const promise = this.rpc.request(this.service, "RegisterPayee", data);
        return promise.then((data)=>exports.MsgRegisterPayeeResponse.decode(_m0.Reader.create(data)));
    }
    RegisterCounterpartyPayee(request) {
        const data = exports.MsgRegisterCounterpartyPayee.encode(request).finish();
        const promise = this.rpc.request(this.service, "RegisterCounterpartyPayee", data);
        return promise.then((data)=>exports.MsgRegisterCounterpartyPayeeResponse.decode(_m0.Reader.create(data)));
    }
    PayPacketFee(request) {
        const data = exports.MsgPayPacketFee.encode(request).finish();
        const promise = this.rpc.request(this.service, "PayPacketFee", data);
        return promise.then((data)=>exports.MsgPayPacketFeeResponse.decode(_m0.Reader.create(data)));
    }
    PayPacketFeeAsync(request) {
        const data = exports.MsgPayPacketFeeAsync.encode(request).finish();
        const promise = this.rpc.request(this.service, "PayPacketFeeAsync", data);
        return promise.then((data)=>exports.MsgPayPacketFeeAsyncResponse.decode(_m0.Reader.create(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=tx.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/transfer/v1/transfer.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/applications/transfer/v1/transfer.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.DenomTrace = exports.protobufPackage = void 0;
/* eslint-disable */ const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
exports.protobufPackage = "ibc.applications.transfer.v1";
function createBaseDenomTrace() {
    return {
        path: "",
        base_denom: ""
    };
}
exports.DenomTrace = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.path !== "") {
            writer.uint32(10).string(message.path);
        }
        if (message.base_denom !== "") {
            writer.uint32(18).string(message.base_denom);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDenomTrace();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.path = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.base_denom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            path: isSet(object.path) ? globalThis.String(object.path) : "",
            base_denom: isSet(object.base_denom) ? globalThis.String(object.base_denom) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.path !== "") {
            obj.path = message.path;
        }
        if (message.base_denom !== "") {
            obj.base_denom = message.base_denom;
        }
        return obj;
    },
    create (base) {
        return exports.DenomTrace.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseDenomTrace();
        message.path = (_a = object.path) !== null && _a !== void 0 ? _a : "";
        message.base_denom = (_b = object.base_denom) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseParams() {
    return {
        send_enabled: false,
        receive_enabled: false
    };
}
exports.Params = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.send_enabled !== false) {
            writer.uint32(8).bool(message.send_enabled);
        }
        if (message.receive_enabled !== false) {
            writer.uint32(16).bool(message.receive_enabled);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.send_enabled = reader.bool();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.receive_enabled = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            send_enabled: isSet(object.send_enabled) ? globalThis.Boolean(object.send_enabled) : false,
            receive_enabled: isSet(object.receive_enabled) ? globalThis.Boolean(object.receive_enabled) : false
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.send_enabled !== false) {
            obj.send_enabled = message.send_enabled;
        }
        if (message.receive_enabled !== false) {
            obj.receive_enabled = message.receive_enabled;
        }
        return obj;
    },
    create (base) {
        return exports.Params.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseParams();
        message.send_enabled = (_a = object.send_enabled) !== null && _a !== void 0 ? _a : false;
        message.receive_enabled = (_b = object.receive_enabled) !== null && _b !== void 0 ? _b : false;
        return message;
    }
};
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=transfer.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/transfer/v1/tx.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/applications/transfer/v1/tx.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgServiceName = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgTransferResponse = exports.MsgTransfer = exports.protobufPackage = void 0;
/* eslint-disable */ const long_1 = __importDefault(__turbopack_require__("[project]/node_modules/.pnpm/long@5.3.1/node_modules/long/umd/index.js [app-ssr] (ecmascript)"));
const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const coin_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/cosmos/base/v1beta1/coin.js [app-ssr] (ecmascript)");
const client_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/client/v1/client.js [app-ssr] (ecmascript)");
const transfer_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/applications/transfer/v1/transfer.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.applications.transfer.v1";
function createBaseMsgTransfer() {
    return {
        source_port: "",
        source_channel: "",
        token: undefined,
        sender: "",
        receiver: "",
        timeout_height: undefined,
        timeout_timestamp: "0",
        memo: ""
    };
}
exports.MsgTransfer = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.source_port !== "") {
            writer.uint32(10).string(message.source_port);
        }
        if (message.source_channel !== "") {
            writer.uint32(18).string(message.source_channel);
        }
        if (message.token !== undefined) {
            coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();
        }
        if (message.sender !== "") {
            writer.uint32(34).string(message.sender);
        }
        if (message.receiver !== "") {
            writer.uint32(42).string(message.receiver);
        }
        if (message.timeout_height !== undefined) {
            client_1.Height.encode(message.timeout_height, writer.uint32(50).fork()).ldelim();
        }
        if (message.timeout_timestamp !== "0") {
            writer.uint32(56).uint64(message.timeout_timestamp);
        }
        if (message.memo !== "") {
            writer.uint32(66).string(message.memo);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTransfer();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.source_port = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.source_channel = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.token = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.receiver = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.timeout_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.timeout_timestamp = longToString(reader.uint64());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.memo = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            source_port: isSet(object.source_port) ? globalThis.String(object.source_port) : "",
            source_channel: isSet(object.source_channel) ? globalThis.String(object.source_channel) : "",
            token: isSet(object.token) ? coin_1.Coin.fromJSON(object.token) : undefined,
            sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
            receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
            timeout_height: isSet(object.timeout_height) ? client_1.Height.fromJSON(object.timeout_height) : undefined,
            timeout_timestamp: isSet(object.timeout_timestamp) ? globalThis.String(object.timeout_timestamp) : "0",
            memo: isSet(object.memo) ? globalThis.String(object.memo) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.source_port !== "") {
            obj.source_port = message.source_port;
        }
        if (message.source_channel !== "") {
            obj.source_channel = message.source_channel;
        }
        if (message.token !== undefined) {
            obj.token = coin_1.Coin.toJSON(message.token);
        }
        if (message.sender !== "") {
            obj.sender = message.sender;
        }
        if (message.receiver !== "") {
            obj.receiver = message.receiver;
        }
        if (message.timeout_height !== undefined) {
            obj.timeout_height = client_1.Height.toJSON(message.timeout_height);
        }
        if (message.timeout_timestamp !== "0") {
            obj.timeout_timestamp = message.timeout_timestamp;
        }
        if (message.memo !== "") {
            obj.memo = message.memo;
        }
        return obj;
    },
    create (base) {
        return exports.MsgTransfer.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseMsgTransfer();
        message.source_port = (_a = object.source_port) !== null && _a !== void 0 ? _a : "";
        message.source_channel = (_b = object.source_channel) !== null && _b !== void 0 ? _b : "";
        message.token = object.token !== undefined && object.token !== null ? coin_1.Coin.fromPartial(object.token) : undefined;
        message.sender = (_c = object.sender) !== null && _c !== void 0 ? _c : "";
        message.receiver = (_d = object.receiver) !== null && _d !== void 0 ? _d : "";
        message.timeout_height = object.timeout_height !== undefined && object.timeout_height !== null ? client_1.Height.fromPartial(object.timeout_height) : undefined;
        message.timeout_timestamp = (_e = object.timeout_timestamp) !== null && _e !== void 0 ? _e : "0";
        message.memo = (_f = object.memo) !== null && _f !== void 0 ? _f : "";
        return message;
    }
};
function createBaseMsgTransferResponse() {
    return {
        sequence: "0"
    };
}
exports.MsgTransferResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.sequence !== "0") {
            writer.uint32(8).uint64(message.sequence);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.sequence = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            sequence: isSet(object.sequence) ? globalThis.String(object.sequence) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.sequence !== "0") {
            obj.sequence = message.sequence;
        }
        return obj;
    },
    create (base) {
        return exports.MsgTransferResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgTransferResponse();
        message.sequence = (_a = object.sequence) !== null && _a !== void 0 ? _a : "0";
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        signer: "",
        params: undefined
    };
}
exports.MsgUpdateParams = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.signer !== "") {
            writer.uint32(10).string(message.signer);
        }
        if (message.params !== undefined) {
            transfer_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.params = transfer_1.Params.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
            params: isSet(object.params) ? transfer_1.Params.fromJSON(object.params) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        if (message.params !== undefined) {
            obj.params = transfer_1.Params.toJSON(message.params);
        }
        return obj;
    },
    create (base) {
        return exports.MsgUpdateParams.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgUpdateParams();
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        message.params = object.params !== undefined && object.params !== null ? transfer_1.Params.fromPartial(object.params) : undefined;
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgUpdateParamsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
exports.MsgServiceName = "ibc.applications.transfer.v1.Msg";
class MsgClientImpl {
    constructor(rpc, opts){
        this.service = (opts === null || opts === void 0 ? void 0 : opts.service) || exports.MsgServiceName;
        this.rpc = rpc;
        this.Transfer = this.Transfer.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
    }
    Transfer(request) {
        const data = exports.MsgTransfer.encode(request).finish();
        const promise = this.rpc.request(this.service, "Transfer", data);
        return promise.then((data)=>exports.MsgTransferResponse.decode(_m0.Reader.create(data)));
    }
    UpdateParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request(this.service, "UpdateParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(_m0.Reader.create(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=tx.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/channel/v1/channel_upgrade.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/core/channel/v1/channel_upgrade.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorReceipt = exports.UpgradeFields = exports.Upgrade = exports.protobufPackage = void 0;
/* eslint-disable */ const long_1 = __importDefault(__turbopack_require__("[project]/node_modules/.pnpm/long@5.3.1/node_modules/long/umd/index.js [app-ssr] (ecmascript)"));
const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const channel_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/channel/v1/channel.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.core.channel.v1";
function createBaseUpgrade() {
    return {
        fields: undefined,
        timeout: undefined,
        next_sequence_send: "0"
    };
}
exports.Upgrade = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.fields !== undefined) {
            exports.UpgradeFields.encode(message.fields, writer.uint32(10).fork()).ldelim();
        }
        if (message.timeout !== undefined) {
            channel_1.Timeout.encode(message.timeout, writer.uint32(18).fork()).ldelim();
        }
        if (message.next_sequence_send !== "0") {
            writer.uint32(24).uint64(message.next_sequence_send);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpgrade();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fields = exports.UpgradeFields.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.timeout = channel_1.Timeout.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.next_sequence_send = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            fields: isSet(object.fields) ? exports.UpgradeFields.fromJSON(object.fields) : undefined,
            timeout: isSet(object.timeout) ? channel_1.Timeout.fromJSON(object.timeout) : undefined,
            next_sequence_send: isSet(object.next_sequence_send) ? globalThis.String(object.next_sequence_send) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.fields !== undefined) {
            obj.fields = exports.UpgradeFields.toJSON(message.fields);
        }
        if (message.timeout !== undefined) {
            obj.timeout = channel_1.Timeout.toJSON(message.timeout);
        }
        if (message.next_sequence_send !== "0") {
            obj.next_sequence_send = message.next_sequence_send;
        }
        return obj;
    },
    create (base) {
        return exports.Upgrade.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseUpgrade();
        message.fields = object.fields !== undefined && object.fields !== null ? exports.UpgradeFields.fromPartial(object.fields) : undefined;
        message.timeout = object.timeout !== undefined && object.timeout !== null ? channel_1.Timeout.fromPartial(object.timeout) : undefined;
        message.next_sequence_send = (_a = object.next_sequence_send) !== null && _a !== void 0 ? _a : "0";
        return message;
    }
};
function createBaseUpgradeFields() {
    return {
        ordering: 0,
        connection_hops: [],
        version: ""
    };
}
exports.UpgradeFields = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.ordering !== 0) {
            writer.uint32(8).int32(message.ordering);
        }
        for (const v of message.connection_hops){
            writer.uint32(18).string(v);
        }
        if (message.version !== "") {
            writer.uint32(26).string(message.version);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpgradeFields();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.ordering = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.connection_hops.push(reader.string());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            ordering: isSet(object.ordering) ? (0, channel_1.orderFromJSON)(object.ordering) : 0,
            connection_hops: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.connection_hops) ? object.connection_hops.map((e)=>globalThis.String(e)) : [],
            version: isSet(object.version) ? globalThis.String(object.version) : ""
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.ordering !== 0) {
            obj.ordering = (0, channel_1.orderToJSON)(message.ordering);
        }
        if ((_a = message.connection_hops) === null || _a === void 0 ? void 0 : _a.length) {
            obj.connection_hops = message.connection_hops;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        return obj;
    },
    create (base) {
        return exports.UpgradeFields.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseUpgradeFields();
        message.ordering = (_a = object.ordering) !== null && _a !== void 0 ? _a : 0;
        message.connection_hops = ((_b = object.connection_hops) === null || _b === void 0 ? void 0 : _b.map((e)=>e)) || [];
        message.version = (_c = object.version) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseErrorReceipt() {
    return {
        sequence: "0",
        message: ""
    };
}
exports.ErrorReceipt = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.sequence !== "0") {
            writer.uint32(8).uint64(message.sequence);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseErrorReceipt();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.sequence = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            sequence: isSet(object.sequence) ? globalThis.String(object.sequence) : "0",
            message: isSet(object.message) ? globalThis.String(object.message) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.sequence !== "0") {
            obj.sequence = message.sequence;
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        return obj;
    },
    create (base) {
        return exports.ErrorReceipt.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseErrorReceipt();
        message.sequence = (_a = object.sequence) !== null && _a !== void 0 ? _a : "0";
        message.message = (_b = object.message) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=channel_upgrade.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/channel/v1/tx.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/core/channel/v1/tx.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgServiceName = exports.MsgPruneAcknowledgementsResponse = exports.MsgPruneAcknowledgements = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgChannelUpgradeCancelResponse = exports.MsgChannelUpgradeCancel = exports.MsgChannelUpgradeTimeoutResponse = exports.MsgChannelUpgradeTimeout = exports.MsgChannelUpgradeOpenResponse = exports.MsgChannelUpgradeOpen = exports.MsgChannelUpgradeConfirmResponse = exports.MsgChannelUpgradeConfirm = exports.MsgChannelUpgradeAckResponse = exports.MsgChannelUpgradeAck = exports.MsgChannelUpgradeTryResponse = exports.MsgChannelUpgradeTry = exports.MsgChannelUpgradeInitResponse = exports.MsgChannelUpgradeInit = exports.MsgAcknowledgementResponse = exports.MsgAcknowledgement = exports.MsgTimeoutOnCloseResponse = exports.MsgTimeoutOnClose = exports.MsgTimeoutResponse = exports.MsgTimeout = exports.MsgRecvPacketResponse = exports.MsgRecvPacket = exports.MsgChannelCloseConfirmResponse = exports.MsgChannelCloseConfirm = exports.MsgChannelCloseInitResponse = exports.MsgChannelCloseInit = exports.MsgChannelOpenConfirmResponse = exports.MsgChannelOpenConfirm = exports.MsgChannelOpenAckResponse = exports.MsgChannelOpenAck = exports.MsgChannelOpenTryResponse = exports.MsgChannelOpenTry = exports.MsgChannelOpenInitResponse = exports.MsgChannelOpenInit = exports.responseResultTypeToJSON = exports.responseResultTypeFromJSON = exports.ResponseResultType = exports.protobufPackage = void 0;
/* eslint-disable */ const long_1 = __importDefault(__turbopack_require__("[project]/node_modules/.pnpm/long@5.3.1/node_modules/long/umd/index.js [app-ssr] (ecmascript)"));
const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const client_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/client/v1/client.js [app-ssr] (ecmascript)");
const channel_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/channel/v1/channel.js [app-ssr] (ecmascript)");
const channel_upgrade_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/channel/v1/channel_upgrade.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.core.channel.v1";
/** ResponseResultType defines the possible outcomes of the execution of a message */ var ResponseResultType;
(function(ResponseResultType) {
    /** RESPONSE_RESULT_TYPE_UNSPECIFIED - Default zero value enumeration */ ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_UNSPECIFIED"] = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED";
    /** RESPONSE_RESULT_TYPE_NOOP - The message did not call the IBC application callbacks (because, for example, the packet had already been relayed) */ ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_NOOP"] = 1] = "RESPONSE_RESULT_TYPE_NOOP";
    /** RESPONSE_RESULT_TYPE_SUCCESS - The message was executed successfully */ ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_SUCCESS"] = 2] = "RESPONSE_RESULT_TYPE_SUCCESS";
    /** RESPONSE_RESULT_TYPE_FAILURE - The message was executed unsuccessfully */ ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_FAILURE"] = 3] = "RESPONSE_RESULT_TYPE_FAILURE";
    ResponseResultType[ResponseResultType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseResultType = exports.ResponseResultType || (exports.ResponseResultType = {}));
function responseResultTypeFromJSON(object) {
    switch(object){
        case 0:
        case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
            return ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED;
        case 1:
        case "RESPONSE_RESULT_TYPE_NOOP":
            return ResponseResultType.RESPONSE_RESULT_TYPE_NOOP;
        case 2:
        case "RESPONSE_RESULT_TYPE_SUCCESS":
            return ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS;
        case 3:
        case "RESPONSE_RESULT_TYPE_FAILURE":
            return ResponseResultType.RESPONSE_RESULT_TYPE_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ResponseResultType.UNRECOGNIZED;
    }
}
exports.responseResultTypeFromJSON = responseResultTypeFromJSON;
function responseResultTypeToJSON(object) {
    switch(object){
        case ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED:
            return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
        case ResponseResultType.RESPONSE_RESULT_TYPE_NOOP:
            return "RESPONSE_RESULT_TYPE_NOOP";
        case ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS:
            return "RESPONSE_RESULT_TYPE_SUCCESS";
        case ResponseResultType.RESPONSE_RESULT_TYPE_FAILURE:
            return "RESPONSE_RESULT_TYPE_FAILURE";
        case ResponseResultType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.responseResultTypeToJSON = responseResultTypeToJSON;
function createBaseMsgChannelOpenInit() {
    return {
        port_id: "",
        channel: undefined,
        signer: ""
    };
}
exports.MsgChannelOpenInit = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel !== undefined) {
            channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(26).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel = channel_1.Channel.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel: isSet(object.channel) ? channel_1.Channel.fromJSON(object.channel) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel !== undefined) {
            obj.channel = channel_1.Channel.toJSON(message.channel);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelOpenInit.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseMsgChannelOpenInit();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel = object.channel !== undefined && object.channel !== null ? channel_1.Channel.fromPartial(object.channel) : undefined;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseMsgChannelOpenInitResponse() {
    return {
        channel_id: "",
        version: ""
    };
}
exports.MsgChannelOpenInitResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.channel_id !== "") {
            writer.uint32(10).string(message.channel_id);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInitResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            version: isSet(object.version) ? globalThis.String(object.version) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelOpenInitResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseMsgChannelOpenInitResponse();
        message.channel_id = (_a = object.channel_id) !== null && _a !== void 0 ? _a : "";
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseMsgChannelOpenTry() {
    return {
        port_id: "",
        previous_channel_id: "",
        channel: undefined,
        counterparty_version: "",
        proof_init: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgChannelOpenTry = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.previous_channel_id !== "") {
            writer.uint32(18).string(message.previous_channel_id);
        }
        if (message.channel !== undefined) {
            channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterparty_version !== "") {
            writer.uint32(34).string(message.counterparty_version);
        }
        if (message.proof_init.length !== 0) {
            writer.uint32(42).bytes(message.proof_init);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(58).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.previous_channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.channel = channel_1.Channel.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.counterparty_version = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.proof_init = reader.bytes();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            previous_channel_id: isSet(object.previous_channel_id) ? globalThis.String(object.previous_channel_id) : "",
            channel: isSet(object.channel) ? channel_1.Channel.fromJSON(object.channel) : undefined,
            counterparty_version: isSet(object.counterparty_version) ? globalThis.String(object.counterparty_version) : "",
            proof_init: isSet(object.proof_init) ? bytesFromBase64(object.proof_init) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.previous_channel_id !== "") {
            obj.previous_channel_id = message.previous_channel_id;
        }
        if (message.channel !== undefined) {
            obj.channel = channel_1.Channel.toJSON(message.channel);
        }
        if (message.counterparty_version !== "") {
            obj.counterparty_version = message.counterparty_version;
        }
        if (message.proof_init.length !== 0) {
            obj.proof_init = base64FromBytes(message.proof_init);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelOpenTry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgChannelOpenTry();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.previous_channel_id = (_b = object.previous_channel_id) !== null && _b !== void 0 ? _b : "";
        message.channel = object.channel !== undefined && object.channel !== null ? channel_1.Channel.fromPartial(object.channel) : undefined;
        message.counterparty_version = (_c = object.counterparty_version) !== null && _c !== void 0 ? _c : "";
        message.proof_init = (_d = object.proof_init) !== null && _d !== void 0 ? _d : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_e = object.signer) !== null && _e !== void 0 ? _e : "";
        return message;
    }
};
function createBaseMsgChannelOpenTryResponse() {
    return {
        version: "",
        channel_id: ""
    };
}
exports.MsgChannelOpenTryResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.version !== "") {
            writer.uint32(10).string(message.version);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTryResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            version: isSet(object.version) ? globalThis.String(object.version) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelOpenTryResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseMsgChannelOpenTryResponse();
        message.version = (_a = object.version) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseMsgChannelOpenAck() {
    return {
        port_id: "",
        channel_id: "",
        counterparty_channel_id: "",
        counterparty_version: "",
        proof_try: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgChannelOpenAck = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.counterparty_channel_id !== "") {
            writer.uint32(26).string(message.counterparty_channel_id);
        }
        if (message.counterparty_version !== "") {
            writer.uint32(34).string(message.counterparty_version);
        }
        if (message.proof_try.length !== 0) {
            writer.uint32(42).bytes(message.proof_try);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(58).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAck();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.counterparty_channel_id = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.counterparty_version = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.proof_try = reader.bytes();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            counterparty_channel_id: isSet(object.counterparty_channel_id) ? globalThis.String(object.counterparty_channel_id) : "",
            counterparty_version: isSet(object.counterparty_version) ? globalThis.String(object.counterparty_version) : "",
            proof_try: isSet(object.proof_try) ? bytesFromBase64(object.proof_try) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.counterparty_channel_id !== "") {
            obj.counterparty_channel_id = message.counterparty_channel_id;
        }
        if (message.counterparty_version !== "") {
            obj.counterparty_version = message.counterparty_version;
        }
        if (message.proof_try.length !== 0) {
            obj.proof_try = base64FromBytes(message.proof_try);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelOpenAck.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseMsgChannelOpenAck();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.counterparty_channel_id = (_c = object.counterparty_channel_id) !== null && _c !== void 0 ? _c : "";
        message.counterparty_version = (_d = object.counterparty_version) !== null && _d !== void 0 ? _d : "";
        message.proof_try = (_e = object.proof_try) !== null && _e !== void 0 ? _e : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : "";
        return message;
    }
};
function createBaseMsgChannelOpenAckResponse() {
    return {};
}
exports.MsgChannelOpenAckResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAckResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgChannelOpenAckResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgChannelOpenAckResponse();
        return message;
    }
};
function createBaseMsgChannelOpenConfirm() {
    return {
        port_id: "",
        channel_id: "",
        proof_ack: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgChannelOpenConfirm = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.proof_ack.length !== 0) {
            writer.uint32(26).bytes(message.proof_ack);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(42).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirm();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proof_ack = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            proof_ack: isSet(object.proof_ack) ? bytesFromBase64(object.proof_ack) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.proof_ack.length !== 0) {
            obj.proof_ack = base64FromBytes(message.proof_ack);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelOpenConfirm.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgChannelOpenConfirm();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.proof_ack = (_c = object.proof_ack) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
    }
};
function createBaseMsgChannelOpenConfirmResponse() {
    return {};
}
exports.MsgChannelOpenConfirmResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirmResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgChannelOpenConfirmResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgChannelOpenConfirmResponse();
        return message;
    }
};
function createBaseMsgChannelCloseInit() {
    return {
        port_id: "",
        channel_id: "",
        signer: ""
    };
}
exports.MsgChannelCloseInit = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.signer !== "") {
            writer.uint32(26).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelCloseInit.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseMsgChannelCloseInit();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseMsgChannelCloseInitResponse() {
    return {};
}
exports.MsgChannelCloseInitResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInitResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgChannelCloseInitResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgChannelCloseInitResponse();
        return message;
    }
};
function createBaseMsgChannelCloseConfirm() {
    return {
        port_id: "",
        channel_id: "",
        proof_init: new Uint8Array(0),
        proof_height: undefined,
        signer: "",
        counterparty_upgrade_sequence: "0"
    };
}
exports.MsgChannelCloseConfirm = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.proof_init.length !== 0) {
            writer.uint32(26).bytes(message.proof_init);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(42).string(message.signer);
        }
        if (message.counterparty_upgrade_sequence !== "0") {
            writer.uint32(48).uint64(message.counterparty_upgrade_sequence);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirm();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proof_init = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.counterparty_upgrade_sequence = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            proof_init: isSet(object.proof_init) ? bytesFromBase64(object.proof_init) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
            counterparty_upgrade_sequence: isSet(object.counterparty_upgrade_sequence) ? globalThis.String(object.counterparty_upgrade_sequence) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.proof_init.length !== 0) {
            obj.proof_init = base64FromBytes(message.proof_init);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        if (message.counterparty_upgrade_sequence !== "0") {
            obj.counterparty_upgrade_sequence = message.counterparty_upgrade_sequence;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelCloseConfirm.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgChannelCloseConfirm();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.proof_init = (_c = object.proof_init) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        message.counterparty_upgrade_sequence = (_e = object.counterparty_upgrade_sequence) !== null && _e !== void 0 ? _e : "0";
        return message;
    }
};
function createBaseMsgChannelCloseConfirmResponse() {
    return {};
}
exports.MsgChannelCloseConfirmResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirmResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgChannelCloseConfirmResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgChannelCloseConfirmResponse();
        return message;
    }
};
function createBaseMsgRecvPacket() {
    return {
        packet: undefined,
        proof_commitment: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgRecvPacket = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.packet !== undefined) {
            channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof_commitment.length !== 0) {
            writer.uint32(18).bytes(message.proof_commitment);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(34).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacket();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.packet = channel_1.Packet.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.proof_commitment = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : undefined,
            proof_commitment: isSet(object.proof_commitment) ? bytesFromBase64(object.proof_commitment) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.packet !== undefined) {
            obj.packet = channel_1.Packet.toJSON(message.packet);
        }
        if (message.proof_commitment.length !== 0) {
            obj.proof_commitment = base64FromBytes(message.proof_commitment);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgRecvPacket.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseMsgRecvPacket();
        message.packet = object.packet !== undefined && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : undefined;
        message.proof_commitment = (_a = object.proof_commitment) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseMsgRecvPacketResponse() {
    return {
        result: 0
    };
}
exports.MsgRecvPacketResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacketResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.result = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.result !== 0) {
            obj.result = responseResultTypeToJSON(message.result);
        }
        return obj;
    },
    create (base) {
        return exports.MsgRecvPacketResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgRecvPacketResponse();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseMsgTimeout() {
    return {
        packet: undefined,
        proof_unreceived: new Uint8Array(0),
        proof_height: undefined,
        next_sequence_recv: "0",
        signer: ""
    };
}
exports.MsgTimeout = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.packet !== undefined) {
            channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof_unreceived.length !== 0) {
            writer.uint32(18).bytes(message.proof_unreceived);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(26).fork()).ldelim();
        }
        if (message.next_sequence_recv !== "0") {
            writer.uint32(32).uint64(message.next_sequence_recv);
        }
        if (message.signer !== "") {
            writer.uint32(42).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeout();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.packet = channel_1.Packet.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.proof_unreceived = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.next_sequence_recv = longToString(reader.uint64());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : undefined,
            proof_unreceived: isSet(object.proof_unreceived) ? bytesFromBase64(object.proof_unreceived) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            next_sequence_recv: isSet(object.next_sequence_recv) ? globalThis.String(object.next_sequence_recv) : "0",
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.packet !== undefined) {
            obj.packet = channel_1.Packet.toJSON(message.packet);
        }
        if (message.proof_unreceived.length !== 0) {
            obj.proof_unreceived = base64FromBytes(message.proof_unreceived);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.next_sequence_recv !== "0") {
            obj.next_sequence_recv = message.next_sequence_recv;
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgTimeout.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseMsgTimeout();
        message.packet = object.packet !== undefined && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : undefined;
        message.proof_unreceived = (_a = object.proof_unreceived) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.next_sequence_recv = (_b = object.next_sequence_recv) !== null && _b !== void 0 ? _b : "0";
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseMsgTimeoutResponse() {
    return {
        result: 0
    };
}
exports.MsgTimeoutResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.result = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.result !== 0) {
            obj.result = responseResultTypeToJSON(message.result);
        }
        return obj;
    },
    create (base) {
        return exports.MsgTimeoutResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgTimeoutResponse();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseMsgTimeoutOnClose() {
    return {
        packet: undefined,
        proof_unreceived: new Uint8Array(0),
        proof_close: new Uint8Array(0),
        proof_height: undefined,
        next_sequence_recv: "0",
        signer: "",
        counterparty_upgrade_sequence: "0"
    };
}
exports.MsgTimeoutOnClose = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.packet !== undefined) {
            channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof_unreceived.length !== 0) {
            writer.uint32(18).bytes(message.proof_unreceived);
        }
        if (message.proof_close.length !== 0) {
            writer.uint32(26).bytes(message.proof_close);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(34).fork()).ldelim();
        }
        if (message.next_sequence_recv !== "0") {
            writer.uint32(40).uint64(message.next_sequence_recv);
        }
        if (message.signer !== "") {
            writer.uint32(50).string(message.signer);
        }
        if (message.counterparty_upgrade_sequence !== "0") {
            writer.uint32(56).uint64(message.counterparty_upgrade_sequence);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnClose();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.packet = channel_1.Packet.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.proof_unreceived = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proof_close = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.next_sequence_recv = longToString(reader.uint64());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.counterparty_upgrade_sequence = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : undefined,
            proof_unreceived: isSet(object.proof_unreceived) ? bytesFromBase64(object.proof_unreceived) : new Uint8Array(0),
            proof_close: isSet(object.proof_close) ? bytesFromBase64(object.proof_close) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            next_sequence_recv: isSet(object.next_sequence_recv) ? globalThis.String(object.next_sequence_recv) : "0",
            signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
            counterparty_upgrade_sequence: isSet(object.counterparty_upgrade_sequence) ? globalThis.String(object.counterparty_upgrade_sequence) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.packet !== undefined) {
            obj.packet = channel_1.Packet.toJSON(message.packet);
        }
        if (message.proof_unreceived.length !== 0) {
            obj.proof_unreceived = base64FromBytes(message.proof_unreceived);
        }
        if (message.proof_close.length !== 0) {
            obj.proof_close = base64FromBytes(message.proof_close);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.next_sequence_recv !== "0") {
            obj.next_sequence_recv = message.next_sequence_recv;
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        if (message.counterparty_upgrade_sequence !== "0") {
            obj.counterparty_upgrade_sequence = message.counterparty_upgrade_sequence;
        }
        return obj;
    },
    create (base) {
        return exports.MsgTimeoutOnClose.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgTimeoutOnClose();
        message.packet = object.packet !== undefined && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : undefined;
        message.proof_unreceived = (_a = object.proof_unreceived) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.proof_close = (_b = object.proof_close) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.next_sequence_recv = (_c = object.next_sequence_recv) !== null && _c !== void 0 ? _c : "0";
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        message.counterparty_upgrade_sequence = (_e = object.counterparty_upgrade_sequence) !== null && _e !== void 0 ? _e : "0";
        return message;
    }
};
function createBaseMsgTimeoutOnCloseResponse() {
    return {
        result: 0
    };
}
exports.MsgTimeoutOnCloseResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnCloseResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.result = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.result !== 0) {
            obj.result = responseResultTypeToJSON(message.result);
        }
        return obj;
    },
    create (base) {
        return exports.MsgTimeoutOnCloseResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgTimeoutOnCloseResponse();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseMsgAcknowledgement() {
    return {
        packet: undefined,
        acknowledgement: new Uint8Array(0),
        proof_acked: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgAcknowledgement = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.packet !== undefined) {
            channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.acknowledgement.length !== 0) {
            writer.uint32(18).bytes(message.acknowledgement);
        }
        if (message.proof_acked.length !== 0) {
            writer.uint32(26).bytes(message.proof_acked);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(42).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgement();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.packet = channel_1.Packet.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.acknowledgement = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proof_acked = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            packet: isSet(object.packet) ? channel_1.Packet.fromJSON(object.packet) : undefined,
            acknowledgement: isSet(object.acknowledgement) ? bytesFromBase64(object.acknowledgement) : new Uint8Array(0),
            proof_acked: isSet(object.proof_acked) ? bytesFromBase64(object.proof_acked) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.packet !== undefined) {
            obj.packet = channel_1.Packet.toJSON(message.packet);
        }
        if (message.acknowledgement.length !== 0) {
            obj.acknowledgement = base64FromBytes(message.acknowledgement);
        }
        if (message.proof_acked.length !== 0) {
            obj.proof_acked = base64FromBytes(message.proof_acked);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgAcknowledgement.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseMsgAcknowledgement();
        message.packet = object.packet !== undefined && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : undefined;
        message.acknowledgement = (_a = object.acknowledgement) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.proof_acked = (_b = object.proof_acked) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseMsgAcknowledgementResponse() {
    return {
        result: 0
    };
}
exports.MsgAcknowledgementResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgementResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.result = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.result !== 0) {
            obj.result = responseResultTypeToJSON(message.result);
        }
        return obj;
    },
    create (base) {
        return exports.MsgAcknowledgementResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgAcknowledgementResponse();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseMsgChannelUpgradeInit() {
    return {
        port_id: "",
        channel_id: "",
        fields: undefined,
        signer: ""
    };
}
exports.MsgChannelUpgradeInit = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.fields !== undefined) {
            channel_upgrade_1.UpgradeFields.encode(message.fields, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(34).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeInit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.fields = channel_upgrade_1.UpgradeFields.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            fields: isSet(object.fields) ? channel_upgrade_1.UpgradeFields.fromJSON(object.fields) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.fields !== undefined) {
            obj.fields = channel_upgrade_1.UpgradeFields.toJSON(message.fields);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeInit.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseMsgChannelUpgradeInit();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.fields = object.fields !== undefined && object.fields !== null ? channel_upgrade_1.UpgradeFields.fromPartial(object.fields) : undefined;
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseMsgChannelUpgradeInitResponse() {
    return {
        upgrade: undefined,
        upgrade_sequence: "0"
    };
}
exports.MsgChannelUpgradeInitResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.upgrade !== undefined) {
            channel_upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgrade_sequence !== "0") {
            writer.uint32(16).uint64(message.upgrade_sequence);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeInitResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.upgrade = channel_upgrade_1.Upgrade.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.upgrade_sequence = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            upgrade: isSet(object.upgrade) ? channel_upgrade_1.Upgrade.fromJSON(object.upgrade) : undefined,
            upgrade_sequence: isSet(object.upgrade_sequence) ? globalThis.String(object.upgrade_sequence) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.upgrade !== undefined) {
            obj.upgrade = channel_upgrade_1.Upgrade.toJSON(message.upgrade);
        }
        if (message.upgrade_sequence !== "0") {
            obj.upgrade_sequence = message.upgrade_sequence;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeInitResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgChannelUpgradeInitResponse();
        message.upgrade = object.upgrade !== undefined && object.upgrade !== null ? channel_upgrade_1.Upgrade.fromPartial(object.upgrade) : undefined;
        message.upgrade_sequence = (_a = object.upgrade_sequence) !== null && _a !== void 0 ? _a : "0";
        return message;
    }
};
function createBaseMsgChannelUpgradeTry() {
    return {
        port_id: "",
        channel_id: "",
        proposed_upgrade_connection_hops: [],
        counterparty_upgrade_fields: undefined,
        counterparty_upgrade_sequence: "0",
        proof_channel: new Uint8Array(0),
        proof_upgrade: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgChannelUpgradeTry = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        for (const v of message.proposed_upgrade_connection_hops){
            writer.uint32(26).string(v);
        }
        if (message.counterparty_upgrade_fields !== undefined) {
            channel_upgrade_1.UpgradeFields.encode(message.counterparty_upgrade_fields, writer.uint32(34).fork()).ldelim();
        }
        if (message.counterparty_upgrade_sequence !== "0") {
            writer.uint32(40).uint64(message.counterparty_upgrade_sequence);
        }
        if (message.proof_channel.length !== 0) {
            writer.uint32(50).bytes(message.proof_channel);
        }
        if (message.proof_upgrade.length !== 0) {
            writer.uint32(58).bytes(message.proof_upgrade);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(66).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(74).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proposed_upgrade_connection_hops.push(reader.string());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.counterparty_upgrade_fields = channel_upgrade_1.UpgradeFields.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.counterparty_upgrade_sequence = longToString(reader.uint64());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.proof_channel = reader.bytes();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.proof_upgrade = reader.bytes();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            proposed_upgrade_connection_hops: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.proposed_upgrade_connection_hops) ? object.proposed_upgrade_connection_hops.map((e)=>globalThis.String(e)) : [],
            counterparty_upgrade_fields: isSet(object.counterparty_upgrade_fields) ? channel_upgrade_1.UpgradeFields.fromJSON(object.counterparty_upgrade_fields) : undefined,
            counterparty_upgrade_sequence: isSet(object.counterparty_upgrade_sequence) ? globalThis.String(object.counterparty_upgrade_sequence) : "0",
            proof_channel: isSet(object.proof_channel) ? bytesFromBase64(object.proof_channel) : new Uint8Array(0),
            proof_upgrade: isSet(object.proof_upgrade) ? bytesFromBase64(object.proof_upgrade) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if ((_a = message.proposed_upgrade_connection_hops) === null || _a === void 0 ? void 0 : _a.length) {
            obj.proposed_upgrade_connection_hops = message.proposed_upgrade_connection_hops;
        }
        if (message.counterparty_upgrade_fields !== undefined) {
            obj.counterparty_upgrade_fields = channel_upgrade_1.UpgradeFields.toJSON(message.counterparty_upgrade_fields);
        }
        if (message.counterparty_upgrade_sequence !== "0") {
            obj.counterparty_upgrade_sequence = message.counterparty_upgrade_sequence;
        }
        if (message.proof_channel.length !== 0) {
            obj.proof_channel = base64FromBytes(message.proof_channel);
        }
        if (message.proof_upgrade.length !== 0) {
            obj.proof_upgrade = base64FromBytes(message.proof_upgrade);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeTry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseMsgChannelUpgradeTry();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.proposed_upgrade_connection_hops = ((_c = object.proposed_upgrade_connection_hops) === null || _c === void 0 ? void 0 : _c.map((e)=>e)) || [];
        message.counterparty_upgrade_fields = object.counterparty_upgrade_fields !== undefined && object.counterparty_upgrade_fields !== null ? channel_upgrade_1.UpgradeFields.fromPartial(object.counterparty_upgrade_fields) : undefined;
        message.counterparty_upgrade_sequence = (_d = object.counterparty_upgrade_sequence) !== null && _d !== void 0 ? _d : "0";
        message.proof_channel = (_e = object.proof_channel) !== null && _e !== void 0 ? _e : new Uint8Array(0);
        message.proof_upgrade = (_f = object.proof_upgrade) !== null && _f !== void 0 ? _f : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_g = object.signer) !== null && _g !== void 0 ? _g : "";
        return message;
    }
};
function createBaseMsgChannelUpgradeTryResponse() {
    return {
        upgrade: undefined,
        upgrade_sequence: "0",
        result: 0
    };
}
exports.MsgChannelUpgradeTryResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.upgrade !== undefined) {
            channel_upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgrade_sequence !== "0") {
            writer.uint32(16).uint64(message.upgrade_sequence);
        }
        if (message.result !== 0) {
            writer.uint32(24).int32(message.result);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTryResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.upgrade = channel_upgrade_1.Upgrade.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.upgrade_sequence = longToString(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.result = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            upgrade: isSet(object.upgrade) ? channel_upgrade_1.Upgrade.fromJSON(object.upgrade) : undefined,
            upgrade_sequence: isSet(object.upgrade_sequence) ? globalThis.String(object.upgrade_sequence) : "0",
            result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.upgrade !== undefined) {
            obj.upgrade = channel_upgrade_1.Upgrade.toJSON(message.upgrade);
        }
        if (message.upgrade_sequence !== "0") {
            obj.upgrade_sequence = message.upgrade_sequence;
        }
        if (message.result !== 0) {
            obj.result = responseResultTypeToJSON(message.result);
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeTryResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseMsgChannelUpgradeTryResponse();
        message.upgrade = object.upgrade !== undefined && object.upgrade !== null ? channel_upgrade_1.Upgrade.fromPartial(object.upgrade) : undefined;
        message.upgrade_sequence = (_a = object.upgrade_sequence) !== null && _a !== void 0 ? _a : "0";
        message.result = (_b = object.result) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseMsgChannelUpgradeAck() {
    return {
        port_id: "",
        channel_id: "",
        counterparty_upgrade: undefined,
        proof_channel: new Uint8Array(0),
        proof_upgrade: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgChannelUpgradeAck = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.counterparty_upgrade !== undefined) {
            channel_upgrade_1.Upgrade.encode(message.counterparty_upgrade, writer.uint32(26).fork()).ldelim();
        }
        if (message.proof_channel.length !== 0) {
            writer.uint32(34).bytes(message.proof_channel);
        }
        if (message.proof_upgrade.length !== 0) {
            writer.uint32(42).bytes(message.proof_upgrade);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(58).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeAck();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.counterparty_upgrade = channel_upgrade_1.Upgrade.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.proof_channel = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.proof_upgrade = reader.bytes();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            counterparty_upgrade: isSet(object.counterparty_upgrade) ? channel_upgrade_1.Upgrade.fromJSON(object.counterparty_upgrade) : undefined,
            proof_channel: isSet(object.proof_channel) ? bytesFromBase64(object.proof_channel) : new Uint8Array(0),
            proof_upgrade: isSet(object.proof_upgrade) ? bytesFromBase64(object.proof_upgrade) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.counterparty_upgrade !== undefined) {
            obj.counterparty_upgrade = channel_upgrade_1.Upgrade.toJSON(message.counterparty_upgrade);
        }
        if (message.proof_channel.length !== 0) {
            obj.proof_channel = base64FromBytes(message.proof_channel);
        }
        if (message.proof_upgrade.length !== 0) {
            obj.proof_upgrade = base64FromBytes(message.proof_upgrade);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeAck.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgChannelUpgradeAck();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.counterparty_upgrade = object.counterparty_upgrade !== undefined && object.counterparty_upgrade !== null ? channel_upgrade_1.Upgrade.fromPartial(object.counterparty_upgrade) : undefined;
        message.proof_channel = (_c = object.proof_channel) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.proof_upgrade = (_d = object.proof_upgrade) !== null && _d !== void 0 ? _d : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_e = object.signer) !== null && _e !== void 0 ? _e : "";
        return message;
    }
};
function createBaseMsgChannelUpgradeAckResponse() {
    return {
        result: 0
    };
}
exports.MsgChannelUpgradeAckResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeAckResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.result = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.result !== 0) {
            obj.result = responseResultTypeToJSON(message.result);
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeAckResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgChannelUpgradeAckResponse();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseMsgChannelUpgradeConfirm() {
    return {
        port_id: "",
        channel_id: "",
        counterparty_channel_state: 0,
        counterparty_upgrade: undefined,
        proof_channel: new Uint8Array(0),
        proof_upgrade: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgChannelUpgradeConfirm = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.counterparty_channel_state !== 0) {
            writer.uint32(24).int32(message.counterparty_channel_state);
        }
        if (message.counterparty_upgrade !== undefined) {
            channel_upgrade_1.Upgrade.encode(message.counterparty_upgrade, writer.uint32(34).fork()).ldelim();
        }
        if (message.proof_channel.length !== 0) {
            writer.uint32(42).bytes(message.proof_channel);
        }
        if (message.proof_upgrade.length !== 0) {
            writer.uint32(50).bytes(message.proof_upgrade);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(58).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(66).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeConfirm();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.counterparty_channel_state = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.counterparty_upgrade = channel_upgrade_1.Upgrade.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.proof_channel = reader.bytes();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.proof_upgrade = reader.bytes();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            counterparty_channel_state: isSet(object.counterparty_channel_state) ? (0, channel_1.stateFromJSON)(object.counterparty_channel_state) : 0,
            counterparty_upgrade: isSet(object.counterparty_upgrade) ? channel_upgrade_1.Upgrade.fromJSON(object.counterparty_upgrade) : undefined,
            proof_channel: isSet(object.proof_channel) ? bytesFromBase64(object.proof_channel) : new Uint8Array(0),
            proof_upgrade: isSet(object.proof_upgrade) ? bytesFromBase64(object.proof_upgrade) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.counterparty_channel_state !== 0) {
            obj.counterparty_channel_state = (0, channel_1.stateToJSON)(message.counterparty_channel_state);
        }
        if (message.counterparty_upgrade !== undefined) {
            obj.counterparty_upgrade = channel_upgrade_1.Upgrade.toJSON(message.counterparty_upgrade);
        }
        if (message.proof_channel.length !== 0) {
            obj.proof_channel = base64FromBytes(message.proof_channel);
        }
        if (message.proof_upgrade.length !== 0) {
            obj.proof_upgrade = base64FromBytes(message.proof_upgrade);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeConfirm.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseMsgChannelUpgradeConfirm();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.counterparty_channel_state = (_c = object.counterparty_channel_state) !== null && _c !== void 0 ? _c : 0;
        message.counterparty_upgrade = object.counterparty_upgrade !== undefined && object.counterparty_upgrade !== null ? channel_upgrade_1.Upgrade.fromPartial(object.counterparty_upgrade) : undefined;
        message.proof_channel = (_d = object.proof_channel) !== null && _d !== void 0 ? _d : new Uint8Array(0);
        message.proof_upgrade = (_e = object.proof_upgrade) !== null && _e !== void 0 ? _e : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : "";
        return message;
    }
};
function createBaseMsgChannelUpgradeConfirmResponse() {
    return {
        result: 0
    };
}
exports.MsgChannelUpgradeConfirmResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeConfirmResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.result = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? responseResultTypeFromJSON(object.result) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.result !== 0) {
            obj.result = responseResultTypeToJSON(message.result);
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeConfirmResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgChannelUpgradeConfirmResponse();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseMsgChannelUpgradeOpen() {
    return {
        port_id: "",
        channel_id: "",
        counterparty_channel_state: 0,
        counterparty_upgrade_sequence: "0",
        proof_channel: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgChannelUpgradeOpen = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.counterparty_channel_state !== 0) {
            writer.uint32(24).int32(message.counterparty_channel_state);
        }
        if (message.counterparty_upgrade_sequence !== "0") {
            writer.uint32(32).uint64(message.counterparty_upgrade_sequence);
        }
        if (message.proof_channel.length !== 0) {
            writer.uint32(42).bytes(message.proof_channel);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(58).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeOpen();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.counterparty_channel_state = reader.int32();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.counterparty_upgrade_sequence = longToString(reader.uint64());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.proof_channel = reader.bytes();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            counterparty_channel_state: isSet(object.counterparty_channel_state) ? (0, channel_1.stateFromJSON)(object.counterparty_channel_state) : 0,
            counterparty_upgrade_sequence: isSet(object.counterparty_upgrade_sequence) ? globalThis.String(object.counterparty_upgrade_sequence) : "0",
            proof_channel: isSet(object.proof_channel) ? bytesFromBase64(object.proof_channel) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.counterparty_channel_state !== 0) {
            obj.counterparty_channel_state = (0, channel_1.stateToJSON)(message.counterparty_channel_state);
        }
        if (message.counterparty_upgrade_sequence !== "0") {
            obj.counterparty_upgrade_sequence = message.counterparty_upgrade_sequence;
        }
        if (message.proof_channel.length !== 0) {
            obj.proof_channel = base64FromBytes(message.proof_channel);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeOpen.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseMsgChannelUpgradeOpen();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.counterparty_channel_state = (_c = object.counterparty_channel_state) !== null && _c !== void 0 ? _c : 0;
        message.counterparty_upgrade_sequence = (_d = object.counterparty_upgrade_sequence) !== null && _d !== void 0 ? _d : "0";
        message.proof_channel = (_e = object.proof_channel) !== null && _e !== void 0 ? _e : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : "";
        return message;
    }
};
function createBaseMsgChannelUpgradeOpenResponse() {
    return {};
}
exports.MsgChannelUpgradeOpenResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeOpenResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeOpenResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgChannelUpgradeOpenResponse();
        return message;
    }
};
function createBaseMsgChannelUpgradeTimeout() {
    return {
        port_id: "",
        channel_id: "",
        counterparty_channel: undefined,
        proof_channel: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgChannelUpgradeTimeout = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.counterparty_channel !== undefined) {
            channel_1.Channel.encode(message.counterparty_channel, writer.uint32(26).fork()).ldelim();
        }
        if (message.proof_channel.length !== 0) {
            writer.uint32(34).bytes(message.proof_channel);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(42).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(50).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTimeout();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.counterparty_channel = channel_1.Channel.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.proof_channel = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            counterparty_channel: isSet(object.counterparty_channel) ? channel_1.Channel.fromJSON(object.counterparty_channel) : undefined,
            proof_channel: isSet(object.proof_channel) ? bytesFromBase64(object.proof_channel) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.counterparty_channel !== undefined) {
            obj.counterparty_channel = channel_1.Channel.toJSON(message.counterparty_channel);
        }
        if (message.proof_channel.length !== 0) {
            obj.proof_channel = base64FromBytes(message.proof_channel);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeTimeout.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgChannelUpgradeTimeout();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.counterparty_channel = object.counterparty_channel !== undefined && object.counterparty_channel !== null ? channel_1.Channel.fromPartial(object.counterparty_channel) : undefined;
        message.proof_channel = (_c = object.proof_channel) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
    }
};
function createBaseMsgChannelUpgradeTimeoutResponse() {
    return {};
}
exports.MsgChannelUpgradeTimeoutResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTimeoutResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeTimeoutResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgChannelUpgradeTimeoutResponse();
        return message;
    }
};
function createBaseMsgChannelUpgradeCancel() {
    return {
        port_id: "",
        channel_id: "",
        error_receipt: undefined,
        proof_error_receipt: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgChannelUpgradeCancel = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.error_receipt !== undefined) {
            channel_upgrade_1.ErrorReceipt.encode(message.error_receipt, writer.uint32(26).fork()).ldelim();
        }
        if (message.proof_error_receipt.length !== 0) {
            writer.uint32(34).bytes(message.proof_error_receipt);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(42).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(50).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeCancel();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.error_receipt = channel_upgrade_1.ErrorReceipt.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.proof_error_receipt = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            error_receipt: isSet(object.error_receipt) ? channel_upgrade_1.ErrorReceipt.fromJSON(object.error_receipt) : undefined,
            proof_error_receipt: isSet(object.proof_error_receipt) ? bytesFromBase64(object.proof_error_receipt) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.error_receipt !== undefined) {
            obj.error_receipt = channel_upgrade_1.ErrorReceipt.toJSON(message.error_receipt);
        }
        if (message.proof_error_receipt.length !== 0) {
            obj.proof_error_receipt = base64FromBytes(message.proof_error_receipt);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeCancel.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgChannelUpgradeCancel();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.error_receipt = object.error_receipt !== undefined && object.error_receipt !== null ? channel_upgrade_1.ErrorReceipt.fromPartial(object.error_receipt) : undefined;
        message.proof_error_receipt = (_c = object.proof_error_receipt) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
    }
};
function createBaseMsgChannelUpgradeCancelResponse() {
    return {};
}
exports.MsgChannelUpgradeCancelResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeCancelResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgChannelUpgradeCancelResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgChannelUpgradeCancelResponse();
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        authority: "",
        params: undefined
    };
}
exports.MsgUpdateParams = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.authority !== "") {
            writer.uint32(10).string(message.authority);
        }
        if (message.params !== undefined) {
            channel_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.authority = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.params = channel_1.Params.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
            params: isSet(object.params) ? channel_1.Params.fromJSON(object.params) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.authority !== "") {
            obj.authority = message.authority;
        }
        if (message.params !== undefined) {
            obj.params = channel_1.Params.toJSON(message.params);
        }
        return obj;
    },
    create (base) {
        return exports.MsgUpdateParams.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgUpdateParams();
        message.authority = (_a = object.authority) !== null && _a !== void 0 ? _a : "";
        message.params = object.params !== undefined && object.params !== null ? channel_1.Params.fromPartial(object.params) : undefined;
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgUpdateParamsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
function createBaseMsgPruneAcknowledgements() {
    return {
        port_id: "",
        channel_id: "",
        limit: "0",
        signer: ""
    };
}
exports.MsgPruneAcknowledgements = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.port_id !== "") {
            writer.uint32(10).string(message.port_id);
        }
        if (message.channel_id !== "") {
            writer.uint32(18).string(message.channel_id);
        }
        if (message.limit !== "0") {
            writer.uint32(24).uint64(message.limit);
        }
        if (message.signer !== "") {
            writer.uint32(34).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAcknowledgements();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.port_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.channel_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.limit = longToString(reader.uint64());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            port_id: isSet(object.port_id) ? globalThis.String(object.port_id) : "",
            channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
            limit: isSet(object.limit) ? globalThis.String(object.limit) : "0",
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.port_id !== "") {
            obj.port_id = message.port_id;
        }
        if (message.channel_id !== "") {
            obj.channel_id = message.channel_id;
        }
        if (message.limit !== "0") {
            obj.limit = message.limit;
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgPruneAcknowledgements.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgPruneAcknowledgements();
        message.port_id = (_a = object.port_id) !== null && _a !== void 0 ? _a : "";
        message.channel_id = (_b = object.channel_id) !== null && _b !== void 0 ? _b : "";
        message.limit = (_c = object.limit) !== null && _c !== void 0 ? _c : "0";
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
    }
};
function createBaseMsgPruneAcknowledgementsResponse() {
    return {
        total_pruned_sequences: "0",
        total_remaining_sequences: "0"
    };
}
exports.MsgPruneAcknowledgementsResponse = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.total_pruned_sequences !== "0") {
            writer.uint32(8).uint64(message.total_pruned_sequences);
        }
        if (message.total_remaining_sequences !== "0") {
            writer.uint32(16).uint64(message.total_remaining_sequences);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAcknowledgementsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.total_pruned_sequences = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.total_remaining_sequences = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            total_pruned_sequences: isSet(object.total_pruned_sequences) ? globalThis.String(object.total_pruned_sequences) : "0",
            total_remaining_sequences: isSet(object.total_remaining_sequences) ? globalThis.String(object.total_remaining_sequences) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.total_pruned_sequences !== "0") {
            obj.total_pruned_sequences = message.total_pruned_sequences;
        }
        if (message.total_remaining_sequences !== "0") {
            obj.total_remaining_sequences = message.total_remaining_sequences;
        }
        return obj;
    },
    create (base) {
        return exports.MsgPruneAcknowledgementsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseMsgPruneAcknowledgementsResponse();
        message.total_pruned_sequences = (_a = object.total_pruned_sequences) !== null && _a !== void 0 ? _a : "0";
        message.total_remaining_sequences = (_b = object.total_remaining_sequences) !== null && _b !== void 0 ? _b : "0";
        return message;
    }
};
exports.MsgServiceName = "ibc.core.channel.v1.Msg";
class MsgClientImpl {
    constructor(rpc, opts){
        this.service = (opts === null || opts === void 0 ? void 0 : opts.service) || exports.MsgServiceName;
        this.rpc = rpc;
        this.ChannelOpenInit = this.ChannelOpenInit.bind(this);
        this.ChannelOpenTry = this.ChannelOpenTry.bind(this);
        this.ChannelOpenAck = this.ChannelOpenAck.bind(this);
        this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this);
        this.ChannelCloseInit = this.ChannelCloseInit.bind(this);
        this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this);
        this.RecvPacket = this.RecvPacket.bind(this);
        this.Timeout = this.Timeout.bind(this);
        this.TimeoutOnClose = this.TimeoutOnClose.bind(this);
        this.Acknowledgement = this.Acknowledgement.bind(this);
        this.ChannelUpgradeInit = this.ChannelUpgradeInit.bind(this);
        this.ChannelUpgradeTry = this.ChannelUpgradeTry.bind(this);
        this.ChannelUpgradeAck = this.ChannelUpgradeAck.bind(this);
        this.ChannelUpgradeConfirm = this.ChannelUpgradeConfirm.bind(this);
        this.ChannelUpgradeOpen = this.ChannelUpgradeOpen.bind(this);
        this.ChannelUpgradeTimeout = this.ChannelUpgradeTimeout.bind(this);
        this.ChannelUpgradeCancel = this.ChannelUpgradeCancel.bind(this);
        this.UpdateChannelParams = this.UpdateChannelParams.bind(this);
        this.PruneAcknowledgements = this.PruneAcknowledgements.bind(this);
    }
    ChannelOpenInit(request) {
        const data = exports.MsgChannelOpenInit.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelOpenInit", data);
        return promise.then((data)=>exports.MsgChannelOpenInitResponse.decode(_m0.Reader.create(data)));
    }
    ChannelOpenTry(request) {
        const data = exports.MsgChannelOpenTry.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelOpenTry", data);
        return promise.then((data)=>exports.MsgChannelOpenTryResponse.decode(_m0.Reader.create(data)));
    }
    ChannelOpenAck(request) {
        const data = exports.MsgChannelOpenAck.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelOpenAck", data);
        return promise.then((data)=>exports.MsgChannelOpenAckResponse.decode(_m0.Reader.create(data)));
    }
    ChannelOpenConfirm(request) {
        const data = exports.MsgChannelOpenConfirm.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelOpenConfirm", data);
        return promise.then((data)=>exports.MsgChannelOpenConfirmResponse.decode(_m0.Reader.create(data)));
    }
    ChannelCloseInit(request) {
        const data = exports.MsgChannelCloseInit.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelCloseInit", data);
        return promise.then((data)=>exports.MsgChannelCloseInitResponse.decode(_m0.Reader.create(data)));
    }
    ChannelCloseConfirm(request) {
        const data = exports.MsgChannelCloseConfirm.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelCloseConfirm", data);
        return promise.then((data)=>exports.MsgChannelCloseConfirmResponse.decode(_m0.Reader.create(data)));
    }
    RecvPacket(request) {
        const data = exports.MsgRecvPacket.encode(request).finish();
        const promise = this.rpc.request(this.service, "RecvPacket", data);
        return promise.then((data)=>exports.MsgRecvPacketResponse.decode(_m0.Reader.create(data)));
    }
    Timeout(request) {
        const data = exports.MsgTimeout.encode(request).finish();
        const promise = this.rpc.request(this.service, "Timeout", data);
        return promise.then((data)=>exports.MsgTimeoutResponse.decode(_m0.Reader.create(data)));
    }
    TimeoutOnClose(request) {
        const data = exports.MsgTimeoutOnClose.encode(request).finish();
        const promise = this.rpc.request(this.service, "TimeoutOnClose", data);
        return promise.then((data)=>exports.MsgTimeoutOnCloseResponse.decode(_m0.Reader.create(data)));
    }
    Acknowledgement(request) {
        const data = exports.MsgAcknowledgement.encode(request).finish();
        const promise = this.rpc.request(this.service, "Acknowledgement", data);
        return promise.then((data)=>exports.MsgAcknowledgementResponse.decode(_m0.Reader.create(data)));
    }
    ChannelUpgradeInit(request) {
        const data = exports.MsgChannelUpgradeInit.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelUpgradeInit", data);
        return promise.then((data)=>exports.MsgChannelUpgradeInitResponse.decode(_m0.Reader.create(data)));
    }
    ChannelUpgradeTry(request) {
        const data = exports.MsgChannelUpgradeTry.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelUpgradeTry", data);
        return promise.then((data)=>exports.MsgChannelUpgradeTryResponse.decode(_m0.Reader.create(data)));
    }
    ChannelUpgradeAck(request) {
        const data = exports.MsgChannelUpgradeAck.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelUpgradeAck", data);
        return promise.then((data)=>exports.MsgChannelUpgradeAckResponse.decode(_m0.Reader.create(data)));
    }
    ChannelUpgradeConfirm(request) {
        const data = exports.MsgChannelUpgradeConfirm.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelUpgradeConfirm", data);
        return promise.then((data)=>exports.MsgChannelUpgradeConfirmResponse.decode(_m0.Reader.create(data)));
    }
    ChannelUpgradeOpen(request) {
        const data = exports.MsgChannelUpgradeOpen.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelUpgradeOpen", data);
        return promise.then((data)=>exports.MsgChannelUpgradeOpenResponse.decode(_m0.Reader.create(data)));
    }
    ChannelUpgradeTimeout(request) {
        const data = exports.MsgChannelUpgradeTimeout.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelUpgradeTimeout", data);
        return promise.then((data)=>exports.MsgChannelUpgradeTimeoutResponse.decode(_m0.Reader.create(data)));
    }
    ChannelUpgradeCancel(request) {
        const data = exports.MsgChannelUpgradeCancel.encode(request).finish();
        const promise = this.rpc.request(this.service, "ChannelUpgradeCancel", data);
        return promise.then((data)=>exports.MsgChannelUpgradeCancelResponse.decode(_m0.Reader.create(data)));
    }
    UpdateChannelParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request(this.service, "UpdateChannelParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(_m0.Reader.create(data)));
    }
    PruneAcknowledgements(request) {
        const data = exports.MsgPruneAcknowledgements.encode(request).finish();
        const promise = this.rpc.request(this.service, "PruneAcknowledgements", data);
        return promise.then((data)=>exports.MsgPruneAcknowledgementsResponse.decode(_m0.Reader.create(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    } else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i){
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    } else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=tx.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/client/v1/tx.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/core/client/v1/tx.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgServiceName = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgIBCSoftwareUpgradeResponse = exports.MsgIBCSoftwareUpgrade = exports.MsgRecoverClientResponse = exports.MsgRecoverClient = exports.MsgSubmitMisbehaviourResponse = exports.MsgSubmitMisbehaviour = exports.MsgUpgradeClientResponse = exports.MsgUpgradeClient = exports.MsgUpdateClientResponse = exports.MsgUpdateClient = exports.MsgCreateClientResponse = exports.MsgCreateClient = exports.protobufPackage = void 0;
/* eslint-disable */ const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const upgrade_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/cosmos/upgrade/v1beta1/upgrade.js [app-ssr] (ecmascript)");
const any_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/google/protobuf/any.js [app-ssr] (ecmascript)");
const client_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/client/v1/client.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.core.client.v1";
function createBaseMsgCreateClient() {
    return {
        client_state: undefined,
        consensus_state: undefined,
        signer: ""
    };
}
exports.MsgCreateClient = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_state !== undefined) {
            any_1.Any.encode(message.client_state, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensus_state !== undefined) {
            any_1.Any.encode(message.consensus_state, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(26).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClient();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_state = any_1.Any.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.consensus_state = any_1.Any.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_state: isSet(object.client_state) ? any_1.Any.fromJSON(object.client_state) : undefined,
            consensus_state: isSet(object.consensus_state) ? any_1.Any.fromJSON(object.consensus_state) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.client_state !== undefined) {
            obj.client_state = any_1.Any.toJSON(message.client_state);
        }
        if (message.consensus_state !== undefined) {
            obj.consensus_state = any_1.Any.toJSON(message.consensus_state);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgCreateClient.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgCreateClient();
        message.client_state = object.client_state !== undefined && object.client_state !== null ? any_1.Any.fromPartial(object.client_state) : undefined;
        message.consensus_state = object.consensus_state !== undefined && object.consensus_state !== null ? any_1.Any.fromPartial(object.consensus_state) : undefined;
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseMsgCreateClientResponse() {
    return {};
}
exports.MsgCreateClientResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClientResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgCreateClientResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgCreateClientResponse();
        return message;
    }
};
function createBaseMsgUpdateClient() {
    return {
        client_id: "",
        client_message: undefined,
        signer: ""
    };
}
exports.MsgUpdateClient = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_id !== "") {
            writer.uint32(10).string(message.client_id);
        }
        if (message.client_message !== undefined) {
            any_1.Any.encode(message.client_message, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(26).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClient();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.client_message = any_1.Any.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            client_message: isSet(object.client_message) ? any_1.Any.fromJSON(object.client_message) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if (message.client_message !== undefined) {
            obj.client_message = any_1.Any.toJSON(message.client_message);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgUpdateClient.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseMsgUpdateClient();
        message.client_id = (_a = object.client_id) !== null && _a !== void 0 ? _a : "";
        message.client_message = object.client_message !== undefined && object.client_message !== null ? any_1.Any.fromPartial(object.client_message) : undefined;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseMsgUpdateClientResponse() {
    return {};
}
exports.MsgUpdateClientResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClientResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgUpdateClientResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateClientResponse();
        return message;
    }
};
function createBaseMsgUpgradeClient() {
    return {
        client_id: "",
        client_state: undefined,
        consensus_state: undefined,
        proof_upgrade_client: new Uint8Array(0),
        proof_upgrade_consensus_state: new Uint8Array(0),
        signer: ""
    };
}
exports.MsgUpgradeClient = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_id !== "") {
            writer.uint32(10).string(message.client_id);
        }
        if (message.client_state !== undefined) {
            any_1.Any.encode(message.client_state, writer.uint32(18).fork()).ldelim();
        }
        if (message.consensus_state !== undefined) {
            any_1.Any.encode(message.consensus_state, writer.uint32(26).fork()).ldelim();
        }
        if (message.proof_upgrade_client.length !== 0) {
            writer.uint32(34).bytes(message.proof_upgrade_client);
        }
        if (message.proof_upgrade_consensus_state.length !== 0) {
            writer.uint32(42).bytes(message.proof_upgrade_consensus_state);
        }
        if (message.signer !== "") {
            writer.uint32(50).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClient();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.client_state = any_1.Any.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.consensus_state = any_1.Any.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.proof_upgrade_client = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.proof_upgrade_consensus_state = reader.bytes();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            client_state: isSet(object.client_state) ? any_1.Any.fromJSON(object.client_state) : undefined,
            consensus_state: isSet(object.consensus_state) ? any_1.Any.fromJSON(object.consensus_state) : undefined,
            proof_upgrade_client: isSet(object.proof_upgrade_client) ? bytesFromBase64(object.proof_upgrade_client) : new Uint8Array(0),
            proof_upgrade_consensus_state: isSet(object.proof_upgrade_consensus_state) ? bytesFromBase64(object.proof_upgrade_consensus_state) : new Uint8Array(0),
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if (message.client_state !== undefined) {
            obj.client_state = any_1.Any.toJSON(message.client_state);
        }
        if (message.consensus_state !== undefined) {
            obj.consensus_state = any_1.Any.toJSON(message.consensus_state);
        }
        if (message.proof_upgrade_client.length !== 0) {
            obj.proof_upgrade_client = base64FromBytes(message.proof_upgrade_client);
        }
        if (message.proof_upgrade_consensus_state.length !== 0) {
            obj.proof_upgrade_consensus_state = base64FromBytes(message.proof_upgrade_consensus_state);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgUpgradeClient.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgUpgradeClient();
        message.client_id = (_a = object.client_id) !== null && _a !== void 0 ? _a : "";
        message.client_state = object.client_state !== undefined && object.client_state !== null ? any_1.Any.fromPartial(object.client_state) : undefined;
        message.consensus_state = object.consensus_state !== undefined && object.consensus_state !== null ? any_1.Any.fromPartial(object.consensus_state) : undefined;
        message.proof_upgrade_client = (_b = object.proof_upgrade_client) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.proof_upgrade_consensus_state = (_c = object.proof_upgrade_consensus_state) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
    }
};
function createBaseMsgUpgradeClientResponse() {
    return {};
}
exports.MsgUpgradeClientResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClientResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgUpgradeClientResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgUpgradeClientResponse();
        return message;
    }
};
function createBaseMsgSubmitMisbehaviour() {
    return {
        client_id: "",
        misbehaviour: undefined,
        signer: ""
    };
}
exports.MsgSubmitMisbehaviour = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_id !== "") {
            writer.uint32(10).string(message.client_id);
        }
        if (message.misbehaviour !== undefined) {
            any_1.Any.encode(message.misbehaviour, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(26).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviour();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.misbehaviour = any_1.Any.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            misbehaviour: isSet(object.misbehaviour) ? any_1.Any.fromJSON(object.misbehaviour) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if (message.misbehaviour !== undefined) {
            obj.misbehaviour = any_1.Any.toJSON(message.misbehaviour);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgSubmitMisbehaviour.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseMsgSubmitMisbehaviour();
        message.client_id = (_a = object.client_id) !== null && _a !== void 0 ? _a : "";
        message.misbehaviour = object.misbehaviour !== undefined && object.misbehaviour !== null ? any_1.Any.fromPartial(object.misbehaviour) : undefined;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseMsgSubmitMisbehaviourResponse() {
    return {};
}
exports.MsgSubmitMisbehaviourResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviourResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgSubmitMisbehaviourResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgSubmitMisbehaviourResponse();
        return message;
    }
};
function createBaseMsgRecoverClient() {
    return {
        subject_client_id: "",
        substitute_client_id: "",
        signer: ""
    };
}
exports.MsgRecoverClient = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.subject_client_id !== "") {
            writer.uint32(10).string(message.subject_client_id);
        }
        if (message.substitute_client_id !== "") {
            writer.uint32(18).string(message.substitute_client_id);
        }
        if (message.signer !== "") {
            writer.uint32(26).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRecoverClient();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subject_client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.substitute_client_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            subject_client_id: isSet(object.subject_client_id) ? globalThis.String(object.subject_client_id) : "",
            substitute_client_id: isSet(object.substitute_client_id) ? globalThis.String(object.substitute_client_id) : "",
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.subject_client_id !== "") {
            obj.subject_client_id = message.subject_client_id;
        }
        if (message.substitute_client_id !== "") {
            obj.substitute_client_id = message.substitute_client_id;
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgRecoverClient.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseMsgRecoverClient();
        message.subject_client_id = (_a = object.subject_client_id) !== null && _a !== void 0 ? _a : "";
        message.substitute_client_id = (_b = object.substitute_client_id) !== null && _b !== void 0 ? _b : "";
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseMsgRecoverClientResponse() {
    return {};
}
exports.MsgRecoverClientResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRecoverClientResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgRecoverClientResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgRecoverClientResponse();
        return message;
    }
};
function createBaseMsgIBCSoftwareUpgrade() {
    return {
        plan: undefined,
        upgraded_client_state: undefined,
        signer: ""
    };
}
exports.MsgIBCSoftwareUpgrade = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.plan !== undefined) {
            upgrade_1.Plan.encode(message.plan, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgraded_client_state !== undefined) {
            any_1.Any.encode(message.upgraded_client_state, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(26).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgIBCSoftwareUpgrade();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.upgraded_client_state = any_1.Any.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            plan: isSet(object.plan) ? upgrade_1.Plan.fromJSON(object.plan) : undefined,
            upgraded_client_state: isSet(object.upgraded_client_state) ? any_1.Any.fromJSON(object.upgraded_client_state) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.plan !== undefined) {
            obj.plan = upgrade_1.Plan.toJSON(message.plan);
        }
        if (message.upgraded_client_state !== undefined) {
            obj.upgraded_client_state = any_1.Any.toJSON(message.upgraded_client_state);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgIBCSoftwareUpgrade.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgIBCSoftwareUpgrade();
        message.plan = object.plan !== undefined && object.plan !== null ? upgrade_1.Plan.fromPartial(object.plan) : undefined;
        message.upgraded_client_state = object.upgraded_client_state !== undefined && object.upgraded_client_state !== null ? any_1.Any.fromPartial(object.upgraded_client_state) : undefined;
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseMsgIBCSoftwareUpgradeResponse() {
    return {};
}
exports.MsgIBCSoftwareUpgradeResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgIBCSoftwareUpgradeResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgIBCSoftwareUpgradeResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgIBCSoftwareUpgradeResponse();
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        signer: "",
        params: undefined
    };
}
exports.MsgUpdateParams = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.signer !== "") {
            writer.uint32(10).string(message.signer);
        }
        if (message.params !== undefined) {
            client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.params = client_1.Params.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
            params: isSet(object.params) ? client_1.Params.fromJSON(object.params) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        if (message.params !== undefined) {
            obj.params = client_1.Params.toJSON(message.params);
        }
        return obj;
    },
    create (base) {
        return exports.MsgUpdateParams.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgUpdateParams();
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        message.params = object.params !== undefined && object.params !== null ? client_1.Params.fromPartial(object.params) : undefined;
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgUpdateParamsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
exports.MsgServiceName = "ibc.core.client.v1.Msg";
class MsgClientImpl {
    constructor(rpc, opts){
        this.service = (opts === null || opts === void 0 ? void 0 : opts.service) || exports.MsgServiceName;
        this.rpc = rpc;
        this.CreateClient = this.CreateClient.bind(this);
        this.UpdateClient = this.UpdateClient.bind(this);
        this.UpgradeClient = this.UpgradeClient.bind(this);
        this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
        this.RecoverClient = this.RecoverClient.bind(this);
        this.IBCSoftwareUpgrade = this.IBCSoftwareUpgrade.bind(this);
        this.UpdateClientParams = this.UpdateClientParams.bind(this);
    }
    CreateClient(request) {
        const data = exports.MsgCreateClient.encode(request).finish();
        const promise = this.rpc.request(this.service, "CreateClient", data);
        return promise.then((data)=>exports.MsgCreateClientResponse.decode(_m0.Reader.create(data)));
    }
    UpdateClient(request) {
        const data = exports.MsgUpdateClient.encode(request).finish();
        const promise = this.rpc.request(this.service, "UpdateClient", data);
        return promise.then((data)=>exports.MsgUpdateClientResponse.decode(_m0.Reader.create(data)));
    }
    UpgradeClient(request) {
        const data = exports.MsgUpgradeClient.encode(request).finish();
        const promise = this.rpc.request(this.service, "UpgradeClient", data);
        return promise.then((data)=>exports.MsgUpgradeClientResponse.decode(_m0.Reader.create(data)));
    }
    SubmitMisbehaviour(request) {
        const data = exports.MsgSubmitMisbehaviour.encode(request).finish();
        const promise = this.rpc.request(this.service, "SubmitMisbehaviour", data);
        return promise.then((data)=>exports.MsgSubmitMisbehaviourResponse.decode(_m0.Reader.create(data)));
    }
    RecoverClient(request) {
        const data = exports.MsgRecoverClient.encode(request).finish();
        const promise = this.rpc.request(this.service, "RecoverClient", data);
        return promise.then((data)=>exports.MsgRecoverClientResponse.decode(_m0.Reader.create(data)));
    }
    IBCSoftwareUpgrade(request) {
        const data = exports.MsgIBCSoftwareUpgrade.encode(request).finish();
        const promise = this.rpc.request(this.service, "IBCSoftwareUpgrade", data);
        return promise.then((data)=>exports.MsgIBCSoftwareUpgradeResponse.decode(_m0.Reader.create(data)));
    }
    UpdateClientParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request(this.service, "UpdateClientParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(_m0.Reader.create(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    } else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i){
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    } else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=tx.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/commitment/v1/commitment.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/core/commitment/v1/commitment.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MerkleProof = exports.MerklePath = exports.MerklePrefix = exports.MerkleRoot = exports.protobufPackage = void 0;
/* eslint-disable */ const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const proofs_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/cosmos/ics23/v1/proofs.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.core.commitment.v1";
function createBaseMerkleRoot() {
    return {
        hash: new Uint8Array(0)
    };
}
exports.MerkleRoot = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.hash.length !== 0) {
            writer.uint32(10).bytes(message.hash);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMerkleRoot();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.hash = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0)
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.hash.length !== 0) {
            obj.hash = base64FromBytes(message.hash);
        }
        return obj;
    },
    create (base) {
        return exports.MerkleRoot.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMerkleRoot();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        return message;
    }
};
function createBaseMerklePrefix() {
    return {
        key_prefix: new Uint8Array(0)
    };
}
exports.MerklePrefix = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.key_prefix.length !== 0) {
            writer.uint32(10).bytes(message.key_prefix);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMerklePrefix();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key_prefix = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            key_prefix: isSet(object.key_prefix) ? bytesFromBase64(object.key_prefix) : new Uint8Array(0)
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.key_prefix.length !== 0) {
            obj.key_prefix = base64FromBytes(message.key_prefix);
        }
        return obj;
    },
    create (base) {
        return exports.MerklePrefix.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMerklePrefix();
        message.key_prefix = (_a = object.key_prefix) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        return message;
    }
};
function createBaseMerklePath() {
    return {
        key_path: []
    };
}
exports.MerklePath = {
    encode (message, writer = _m0.Writer.create()) {
        for (const v of message.key_path){
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMerklePath();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key_path.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            key_path: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.key_path) ? object.key_path.map((e)=>globalThis.String(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if ((_a = message.key_path) === null || _a === void 0 ? void 0 : _a.length) {
            obj.key_path = message.key_path;
        }
        return obj;
    },
    create (base) {
        return exports.MerklePath.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMerklePath();
        message.key_path = ((_a = object.key_path) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBaseMerkleProof() {
    return {
        proofs: []
    };
}
exports.MerkleProof = {
    encode (message, writer = _m0.Writer.create()) {
        for (const v of message.proofs){
            proofs_1.CommitmentProof.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMerkleProof();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.proofs.push(proofs_1.CommitmentProof.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            proofs: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.proofs) ? object.proofs.map((e)=>proofs_1.CommitmentProof.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if ((_a = message.proofs) === null || _a === void 0 ? void 0 : _a.length) {
            obj.proofs = message.proofs.map((e)=>proofs_1.CommitmentProof.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return exports.MerkleProof.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMerkleProof();
        message.proofs = ((_a = object.proofs) === null || _a === void 0 ? void 0 : _a.map((e)=>proofs_1.CommitmentProof.fromPartial(e))) || [];
        return message;
    }
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    } else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i){
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    } else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=commitment.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/connection/v1/connection.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/core/connection/v1/connection.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = exports.Version = exports.ConnectionPaths = exports.ClientPaths = exports.Counterparty = exports.IdentifiedConnection = exports.ConnectionEnd = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;
/* eslint-disable */ const long_1 = __importDefault(__turbopack_require__("[project]/node_modules/.pnpm/long@5.3.1/node_modules/long/umd/index.js [app-ssr] (ecmascript)"));
const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const commitment_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/commitment/v1/commitment.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.core.connection.v1";
/**
 * State defines if a connection is in one of the following states:
 * INIT, TRYOPEN, OPEN or UNINITIALIZED.
 */ var State;
(function(State) {
    /** STATE_UNINITIALIZED_UNSPECIFIED - Default State */ State[State["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
    /** STATE_INIT - A connection end has just started the opening handshake. */ State[State["STATE_INIT"] = 1] = "STATE_INIT";
    /**
     * STATE_TRYOPEN - A connection end has acknowledged the handshake step on the counterparty
     * chain.
     */ State[State["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
    /** STATE_OPEN - A connection end has completed the handshake. */ State[State["STATE_OPEN"] = 3] = "STATE_OPEN";
    State[State["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(State = exports.State || (exports.State = {}));
function stateFromJSON(object) {
    switch(object){
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
            return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
            return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
            return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
            return State.STATE_OPEN;
        case -1:
        case "UNRECOGNIZED":
        default:
            return State.UNRECOGNIZED;
    }
}
exports.stateFromJSON = stateFromJSON;
function stateToJSON(object) {
    switch(object){
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
            return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
            return "STATE_INIT";
        case State.STATE_TRYOPEN:
            return "STATE_TRYOPEN";
        case State.STATE_OPEN:
            return "STATE_OPEN";
        case State.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.stateToJSON = stateToJSON;
function createBaseConnectionEnd() {
    return {
        client_id: "",
        versions: [],
        state: 0,
        counterparty: undefined,
        delay_period: "0"
    };
}
exports.ConnectionEnd = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_id !== "") {
            writer.uint32(10).string(message.client_id);
        }
        for (const v of message.versions){
            exports.Version.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.state !== 0) {
            writer.uint32(24).int32(message.state);
        }
        if (message.counterparty !== undefined) {
            exports.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (message.delay_period !== "0") {
            writer.uint32(40).uint64(message.delay_period);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConnectionEnd();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.versions.push(exports.Version.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.state = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.delay_period = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            versions: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.versions) ? object.versions.map((e)=>exports.Version.fromJSON(e)) : [],
            state: isSet(object.state) ? stateFromJSON(object.state) : 0,
            counterparty: isSet(object.counterparty) ? exports.Counterparty.fromJSON(object.counterparty) : undefined,
            delay_period: isSet(object.delay_period) ? globalThis.String(object.delay_period) : "0"
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if ((_a = message.versions) === null || _a === void 0 ? void 0 : _a.length) {
            obj.versions = message.versions.map((e)=>exports.Version.toJSON(e));
        }
        if (message.state !== 0) {
            obj.state = stateToJSON(message.state);
        }
        if (message.counterparty !== undefined) {
            obj.counterparty = exports.Counterparty.toJSON(message.counterparty);
        }
        if (message.delay_period !== "0") {
            obj.delay_period = message.delay_period;
        }
        return obj;
    },
    create (base) {
        return exports.ConnectionEnd.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseConnectionEnd();
        message.client_id = (_a = object.client_id) !== null && _a !== void 0 ? _a : "";
        message.versions = ((_b = object.versions) === null || _b === void 0 ? void 0 : _b.map((e)=>exports.Version.fromPartial(e))) || [];
        message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
        message.counterparty = object.counterparty !== undefined && object.counterparty !== null ? exports.Counterparty.fromPartial(object.counterparty) : undefined;
        message.delay_period = (_d = object.delay_period) !== null && _d !== void 0 ? _d : "0";
        return message;
    }
};
function createBaseIdentifiedConnection() {
    return {
        id: "",
        client_id: "",
        versions: [],
        state: 0,
        counterparty: undefined,
        delay_period: "0"
    };
}
exports.IdentifiedConnection = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.client_id !== "") {
            writer.uint32(18).string(message.client_id);
        }
        for (const v of message.versions){
            exports.Version.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.state !== 0) {
            writer.uint32(32).int32(message.state);
        }
        if (message.counterparty !== undefined) {
            exports.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();
        }
        if (message.delay_period !== "0") {
            writer.uint32(48).uint64(message.delay_period);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedConnection();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.versions.push(exports.Version.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.state = reader.int32();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.delay_period = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            versions: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.versions) ? object.versions.map((e)=>exports.Version.fromJSON(e)) : [],
            state: isSet(object.state) ? stateFromJSON(object.state) : 0,
            counterparty: isSet(object.counterparty) ? exports.Counterparty.fromJSON(object.counterparty) : undefined,
            delay_period: isSet(object.delay_period) ? globalThis.String(object.delay_period) : "0"
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if ((_a = message.versions) === null || _a === void 0 ? void 0 : _a.length) {
            obj.versions = message.versions.map((e)=>exports.Version.toJSON(e));
        }
        if (message.state !== 0) {
            obj.state = stateToJSON(message.state);
        }
        if (message.counterparty !== undefined) {
            obj.counterparty = exports.Counterparty.toJSON(message.counterparty);
        }
        if (message.delay_period !== "0") {
            obj.delay_period = message.delay_period;
        }
        return obj;
    },
    create (base) {
        return exports.IdentifiedConnection.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseIdentifiedConnection();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.client_id = (_b = object.client_id) !== null && _b !== void 0 ? _b : "";
        message.versions = ((_c = object.versions) === null || _c === void 0 ? void 0 : _c.map((e)=>exports.Version.fromPartial(e))) || [];
        message.state = (_d = object.state) !== null && _d !== void 0 ? _d : 0;
        message.counterparty = object.counterparty !== undefined && object.counterparty !== null ? exports.Counterparty.fromPartial(object.counterparty) : undefined;
        message.delay_period = (_e = object.delay_period) !== null && _e !== void 0 ? _e : "0";
        return message;
    }
};
function createBaseCounterparty() {
    return {
        client_id: "",
        connection_id: "",
        prefix: undefined
    };
}
exports.Counterparty = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_id !== "") {
            writer.uint32(10).string(message.client_id);
        }
        if (message.connection_id !== "") {
            writer.uint32(18).string(message.connection_id);
        }
        if (message.prefix !== undefined) {
            commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.connection_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            connection_id: isSet(object.connection_id) ? globalThis.String(object.connection_id) : "",
            prefix: isSet(object.prefix) ? commitment_1.MerklePrefix.fromJSON(object.prefix) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if (message.connection_id !== "") {
            obj.connection_id = message.connection_id;
        }
        if (message.prefix !== undefined) {
            obj.prefix = commitment_1.MerklePrefix.toJSON(message.prefix);
        }
        return obj;
    },
    create (base) {
        return exports.Counterparty.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseCounterparty();
        message.client_id = (_a = object.client_id) !== null && _a !== void 0 ? _a : "";
        message.connection_id = (_b = object.connection_id) !== null && _b !== void 0 ? _b : "";
        message.prefix = object.prefix !== undefined && object.prefix !== null ? commitment_1.MerklePrefix.fromPartial(object.prefix) : undefined;
        return message;
    }
};
function createBaseClientPaths() {
    return {
        paths: []
    };
}
exports.ClientPaths = {
    encode (message, writer = _m0.Writer.create()) {
        for (const v of message.paths){
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientPaths();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.paths.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            paths: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.paths) ? object.paths.map((e)=>globalThis.String(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if ((_a = message.paths) === null || _a === void 0 ? void 0 : _a.length) {
            obj.paths = message.paths;
        }
        return obj;
    },
    create (base) {
        return exports.ClientPaths.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseClientPaths();
        message.paths = ((_a = object.paths) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBaseConnectionPaths() {
    return {
        client_id: "",
        paths: []
    };
}
exports.ConnectionPaths = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_id !== "") {
            writer.uint32(10).string(message.client_id);
        }
        for (const v of message.paths){
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConnectionPaths();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.paths.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            paths: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.paths) ? object.paths.map((e)=>globalThis.String(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if ((_a = message.paths) === null || _a === void 0 ? void 0 : _a.length) {
            obj.paths = message.paths;
        }
        return obj;
    },
    create (base) {
        return exports.ConnectionPaths.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseConnectionPaths();
        message.client_id = (_a = object.client_id) !== null && _a !== void 0 ? _a : "";
        message.paths = ((_b = object.paths) === null || _b === void 0 ? void 0 : _b.map((e)=>e)) || [];
        return message;
    }
};
function createBaseVersion() {
    return {
        identifier: "",
        features: []
    };
}
exports.Version = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.identifier !== "") {
            writer.uint32(10).string(message.identifier);
        }
        for (const v of message.features){
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVersion();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.identifier = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.features.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
            features: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.features) ? object.features.map((e)=>globalThis.String(e)) : []
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.identifier !== "") {
            obj.identifier = message.identifier;
        }
        if ((_a = message.features) === null || _a === void 0 ? void 0 : _a.length) {
            obj.features = message.features;
        }
        return obj;
    },
    create (base) {
        return exports.Version.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseVersion();
        message.identifier = (_a = object.identifier) !== null && _a !== void 0 ? _a : "";
        message.features = ((_b = object.features) === null || _b === void 0 ? void 0 : _b.map((e)=>e)) || [];
        return message;
    }
};
function createBaseParams() {
    return {
        max_expected_time_per_block: "0"
    };
}
exports.Params = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.max_expected_time_per_block !== "0") {
            writer.uint32(8).uint64(message.max_expected_time_per_block);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.max_expected_time_per_block = longToString(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            max_expected_time_per_block: isSet(object.max_expected_time_per_block) ? globalThis.String(object.max_expected_time_per_block) : "0"
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.max_expected_time_per_block !== "0") {
            obj.max_expected_time_per_block = message.max_expected_time_per_block;
        }
        return obj;
    },
    create (base) {
        return exports.Params.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseParams();
        message.max_expected_time_per_block = (_a = object.max_expected_time_per_block) !== null && _a !== void 0 ? _a : "0";
        return message;
    }
};
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=connection.js.map
}}),
"[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/connection/v1/tx.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v3.21.3
// source: ibc/core/connection/v1/tx.proto
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MsgClientImpl = exports.MsgServiceName = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgConnectionOpenConfirmResponse = exports.MsgConnectionOpenConfirm = exports.MsgConnectionOpenAckResponse = exports.MsgConnectionOpenAck = exports.MsgConnectionOpenTryResponse = exports.MsgConnectionOpenTry = exports.MsgConnectionOpenInitResponse = exports.MsgConnectionOpenInit = exports.protobufPackage = void 0;
/* eslint-disable */ const long_1 = __importDefault(__turbopack_require__("[project]/node_modules/.pnpm/long@5.3.1/node_modules/long/umd/index.js [app-ssr] (ecmascript)"));
const _m0 = __importStar(__turbopack_require__("[project]/node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)"));
const any_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/google/protobuf/any.js [app-ssr] (ecmascript)");
const client_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/client/v1/client.js [app-ssr] (ecmascript)");
const connection_1 = __turbopack_require__("[project]/node_modules/.pnpm/secretjs@1.15.1_encoding@0.1.13/node_modules/secretjs/dist/protobuf/ibc/core/connection/v1/connection.js [app-ssr] (ecmascript)");
exports.protobufPackage = "ibc.core.connection.v1";
function createBaseMsgConnectionOpenInit() {
    return {
        client_id: "",
        counterparty: undefined,
        version: undefined,
        delay_period: "0",
        signer: ""
    };
}
exports.MsgConnectionOpenInit = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_id !== "") {
            writer.uint32(10).string(message.client_id);
        }
        if (message.counterparty !== undefined) {
            connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();
        }
        if (message.version !== undefined) {
            connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.delay_period !== "0") {
            writer.uint32(32).uint64(message.delay_period);
        }
        if (message.signer !== "") {
            writer.uint32(42).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInit();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.version = connection_1.Version.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.delay_period = longToString(reader.uint64());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            counterparty: isSet(object.counterparty) ? connection_1.Counterparty.fromJSON(object.counterparty) : undefined,
            version: isSet(object.version) ? connection_1.Version.fromJSON(object.version) : undefined,
            delay_period: isSet(object.delay_period) ? globalThis.String(object.delay_period) : "0",
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if (message.counterparty !== undefined) {
            obj.counterparty = connection_1.Counterparty.toJSON(message.counterparty);
        }
        if (message.version !== undefined) {
            obj.version = connection_1.Version.toJSON(message.version);
        }
        if (message.delay_period !== "0") {
            obj.delay_period = message.delay_period;
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgConnectionOpenInit.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseMsgConnectionOpenInit();
        message.client_id = (_a = object.client_id) !== null && _a !== void 0 ? _a : "";
        message.counterparty = object.counterparty !== undefined && object.counterparty !== null ? connection_1.Counterparty.fromPartial(object.counterparty) : undefined;
        message.version = object.version !== undefined && object.version !== null ? connection_1.Version.fromPartial(object.version) : undefined;
        message.delay_period = (_b = object.delay_period) !== null && _b !== void 0 ? _b : "0";
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseMsgConnectionOpenInitResponse() {
    return {};
}
exports.MsgConnectionOpenInitResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInitResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgConnectionOpenInitResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgConnectionOpenInitResponse();
        return message;
    }
};
function createBaseMsgConnectionOpenTry() {
    return {
        client_id: "",
        previous_connection_id: "",
        client_state: undefined,
        counterparty: undefined,
        delay_period: "0",
        counterparty_versions: [],
        proof_height: undefined,
        proof_init: new Uint8Array(0),
        proof_client: new Uint8Array(0),
        proof_consensus: new Uint8Array(0),
        consensus_height: undefined,
        signer: "",
        host_consensus_state_proof: new Uint8Array(0)
    };
}
exports.MsgConnectionOpenTry = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.client_id !== "") {
            writer.uint32(10).string(message.client_id);
        }
        if (message.previous_connection_id !== "") {
            writer.uint32(18).string(message.previous_connection_id);
        }
        if (message.client_state !== undefined) {
            any_1.Any.encode(message.client_state, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterparty !== undefined) {
            connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (message.delay_period !== "0") {
            writer.uint32(40).uint64(message.delay_period);
        }
        for (const v of message.counterparty_versions){
            connection_1.Version.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(58).fork()).ldelim();
        }
        if (message.proof_init.length !== 0) {
            writer.uint32(66).bytes(message.proof_init);
        }
        if (message.proof_client.length !== 0) {
            writer.uint32(74).bytes(message.proof_client);
        }
        if (message.proof_consensus.length !== 0) {
            writer.uint32(82).bytes(message.proof_consensus);
        }
        if (message.consensus_height !== undefined) {
            client_1.Height.encode(message.consensus_height, writer.uint32(90).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(98).string(message.signer);
        }
        if (message.host_consensus_state_proof.length !== 0) {
            writer.uint32(106).bytes(message.host_consensus_state_proof);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.client_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.previous_connection_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.client_state = any_1.Any.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.delay_period = longToString(reader.uint64());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.counterparty_versions.push(connection_1.Version.decode(reader, reader.uint32()));
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.proof_init = reader.bytes();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.proof_client = reader.bytes();
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.proof_consensus = reader.bytes();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.consensus_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.host_consensus_state_proof = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
            previous_connection_id: isSet(object.previous_connection_id) ? globalThis.String(object.previous_connection_id) : "",
            client_state: isSet(object.client_state) ? any_1.Any.fromJSON(object.client_state) : undefined,
            counterparty: isSet(object.counterparty) ? connection_1.Counterparty.fromJSON(object.counterparty) : undefined,
            delay_period: isSet(object.delay_period) ? globalThis.String(object.delay_period) : "0",
            counterparty_versions: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.counterparty_versions) ? object.counterparty_versions.map((e)=>connection_1.Version.fromJSON(e)) : [],
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            proof_init: isSet(object.proof_init) ? bytesFromBase64(object.proof_init) : new Uint8Array(0),
            proof_client: isSet(object.proof_client) ? bytesFromBase64(object.proof_client) : new Uint8Array(0),
            proof_consensus: isSet(object.proof_consensus) ? bytesFromBase64(object.proof_consensus) : new Uint8Array(0),
            consensus_height: isSet(object.consensus_height) ? client_1.Height.fromJSON(object.consensus_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
            host_consensus_state_proof: isSet(object.host_consensus_state_proof) ? bytesFromBase64(object.host_consensus_state_proof) : new Uint8Array(0)
        };
    },
    toJSON (message) {
        var _a;
        const obj = {};
        if (message.client_id !== "") {
            obj.client_id = message.client_id;
        }
        if (message.previous_connection_id !== "") {
            obj.previous_connection_id = message.previous_connection_id;
        }
        if (message.client_state !== undefined) {
            obj.client_state = any_1.Any.toJSON(message.client_state);
        }
        if (message.counterparty !== undefined) {
            obj.counterparty = connection_1.Counterparty.toJSON(message.counterparty);
        }
        if (message.delay_period !== "0") {
            obj.delay_period = message.delay_period;
        }
        if ((_a = message.counterparty_versions) === null || _a === void 0 ? void 0 : _a.length) {
            obj.counterparty_versions = message.counterparty_versions.map((e)=>connection_1.Version.toJSON(e));
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.proof_init.length !== 0) {
            obj.proof_init = base64FromBytes(message.proof_init);
        }
        if (message.proof_client.length !== 0) {
            obj.proof_client = base64FromBytes(message.proof_client);
        }
        if (message.proof_consensus.length !== 0) {
            obj.proof_consensus = base64FromBytes(message.proof_consensus);
        }
        if (message.consensus_height !== undefined) {
            obj.consensus_height = client_1.Height.toJSON(message.consensus_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        if (message.host_consensus_state_proof.length !== 0) {
            obj.host_consensus_state_proof = base64FromBytes(message.host_consensus_state_proof);
        }
        return obj;
    },
    create (base) {
        return exports.MsgConnectionOpenTry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseMsgConnectionOpenTry();
        message.client_id = (_a = object.client_id) !== null && _a !== void 0 ? _a : "";
        message.previous_connection_id = (_b = object.previous_connection_id) !== null && _b !== void 0 ? _b : "";
        message.client_state = object.client_state !== undefined && object.client_state !== null ? any_1.Any.fromPartial(object.client_state) : undefined;
        message.counterparty = object.counterparty !== undefined && object.counterparty !== null ? connection_1.Counterparty.fromPartial(object.counterparty) : undefined;
        message.delay_period = (_c = object.delay_period) !== null && _c !== void 0 ? _c : "0";
        message.counterparty_versions = ((_d = object.counterparty_versions) === null || _d === void 0 ? void 0 : _d.map((e)=>connection_1.Version.fromPartial(e))) || [];
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.proof_init = (_e = object.proof_init) !== null && _e !== void 0 ? _e : new Uint8Array(0);
        message.proof_client = (_f = object.proof_client) !== null && _f !== void 0 ? _f : new Uint8Array(0);
        message.proof_consensus = (_g = object.proof_consensus) !== null && _g !== void 0 ? _g : new Uint8Array(0);
        message.consensus_height = object.consensus_height !== undefined && object.consensus_height !== null ? client_1.Height.fromPartial(object.consensus_height) : undefined;
        message.signer = (_h = object.signer) !== null && _h !== void 0 ? _h : "";
        message.host_consensus_state_proof = (_j = object.host_consensus_state_proof) !== null && _j !== void 0 ? _j : new Uint8Array(0);
        return message;
    }
};
function createBaseMsgConnectionOpenTryResponse() {
    return {};
}
exports.MsgConnectionOpenTryResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTryResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgConnectionOpenTryResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgConnectionOpenTryResponse();
        return message;
    }
};
function createBaseMsgConnectionOpenAck() {
    return {
        connection_id: "",
        counterparty_connection_id: "",
        version: undefined,
        client_state: undefined,
        proof_height: undefined,
        proof_try: new Uint8Array(0),
        proof_client: new Uint8Array(0),
        proof_consensus: new Uint8Array(0),
        consensus_height: undefined,
        signer: "",
        host_consensus_state_proof: new Uint8Array(0)
    };
}
exports.MsgConnectionOpenAck = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.connection_id !== "") {
            writer.uint32(10).string(message.connection_id);
        }
        if (message.counterparty_connection_id !== "") {
            writer.uint32(18).string(message.counterparty_connection_id);
        }
        if (message.version !== undefined) {
            connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.client_state !== undefined) {
            any_1.Any.encode(message.client_state, writer.uint32(34).fork()).ldelim();
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(42).fork()).ldelim();
        }
        if (message.proof_try.length !== 0) {
            writer.uint32(50).bytes(message.proof_try);
        }
        if (message.proof_client.length !== 0) {
            writer.uint32(58).bytes(message.proof_client);
        }
        if (message.proof_consensus.length !== 0) {
            writer.uint32(66).bytes(message.proof_consensus);
        }
        if (message.consensus_height !== undefined) {
            client_1.Height.encode(message.consensus_height, writer.uint32(74).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(82).string(message.signer);
        }
        if (message.host_consensus_state_proof.length !== 0) {
            writer.uint32(90).bytes(message.host_consensus_state_proof);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAck();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.connection_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.counterparty_connection_id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.version = connection_1.Version.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.client_state = any_1.Any.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.proof_try = reader.bytes();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.proof_client = reader.bytes();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.proof_consensus = reader.bytes();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.consensus_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.host_consensus_state_proof = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            connection_id: isSet(object.connection_id) ? globalThis.String(object.connection_id) : "",
            counterparty_connection_id: isSet(object.counterparty_connection_id) ? globalThis.String(object.counterparty_connection_id) : "",
            version: isSet(object.version) ? connection_1.Version.fromJSON(object.version) : undefined,
            client_state: isSet(object.client_state) ? any_1.Any.fromJSON(object.client_state) : undefined,
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            proof_try: isSet(object.proof_try) ? bytesFromBase64(object.proof_try) : new Uint8Array(0),
            proof_client: isSet(object.proof_client) ? bytesFromBase64(object.proof_client) : new Uint8Array(0),
            proof_consensus: isSet(object.proof_consensus) ? bytesFromBase64(object.proof_consensus) : new Uint8Array(0),
            consensus_height: isSet(object.consensus_height) ? client_1.Height.fromJSON(object.consensus_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
            host_consensus_state_proof: isSet(object.host_consensus_state_proof) ? bytesFromBase64(object.host_consensus_state_proof) : new Uint8Array(0)
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.connection_id !== "") {
            obj.connection_id = message.connection_id;
        }
        if (message.counterparty_connection_id !== "") {
            obj.counterparty_connection_id = message.counterparty_connection_id;
        }
        if (message.version !== undefined) {
            obj.version = connection_1.Version.toJSON(message.version);
        }
        if (message.client_state !== undefined) {
            obj.client_state = any_1.Any.toJSON(message.client_state);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.proof_try.length !== 0) {
            obj.proof_try = base64FromBytes(message.proof_try);
        }
        if (message.proof_client.length !== 0) {
            obj.proof_client = base64FromBytes(message.proof_client);
        }
        if (message.proof_consensus.length !== 0) {
            obj.proof_consensus = base64FromBytes(message.proof_consensus);
        }
        if (message.consensus_height !== undefined) {
            obj.consensus_height = client_1.Height.toJSON(message.consensus_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        if (message.host_consensus_state_proof.length !== 0) {
            obj.host_consensus_state_proof = base64FromBytes(message.host_consensus_state_proof);
        }
        return obj;
    },
    create (base) {
        return exports.MsgConnectionOpenAck.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseMsgConnectionOpenAck();
        message.connection_id = (_a = object.connection_id) !== null && _a !== void 0 ? _a : "";
        message.counterparty_connection_id = (_b = object.counterparty_connection_id) !== null && _b !== void 0 ? _b : "";
        message.version = object.version !== undefined && object.version !== null ? connection_1.Version.fromPartial(object.version) : undefined;
        message.client_state = object.client_state !== undefined && object.client_state !== null ? any_1.Any.fromPartial(object.client_state) : undefined;
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.proof_try = (_c = object.proof_try) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.proof_client = (_d = object.proof_client) !== null && _d !== void 0 ? _d : new Uint8Array(0);
        message.proof_consensus = (_e = object.proof_consensus) !== null && _e !== void 0 ? _e : new Uint8Array(0);
        message.consensus_height = object.consensus_height !== undefined && object.consensus_height !== null ? client_1.Height.fromPartial(object.consensus_height) : undefined;
        message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : "";
        message.host_consensus_state_proof = (_g = object.host_consensus_state_proof) !== null && _g !== void 0 ? _g : new Uint8Array(0);
        return message;
    }
};
function createBaseMsgConnectionOpenAckResponse() {
    return {};
}
exports.MsgConnectionOpenAckResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAckResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgConnectionOpenAckResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgConnectionOpenAckResponse();
        return message;
    }
};
function createBaseMsgConnectionOpenConfirm() {
    return {
        connection_id: "",
        proof_ack: new Uint8Array(0),
        proof_height: undefined,
        signer: ""
    };
}
exports.MsgConnectionOpenConfirm = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.connection_id !== "") {
            writer.uint32(10).string(message.connection_id);
        }
        if (message.proof_ack.length !== 0) {
            writer.uint32(18).bytes(message.proof_ack);
        }
        if (message.proof_height !== undefined) {
            client_1.Height.encode(message.proof_height, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
            writer.uint32(34).string(message.signer);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirm();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.connection_id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.proof_ack = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proof_height = client_1.Height.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            connection_id: isSet(object.connection_id) ? globalThis.String(object.connection_id) : "",
            proof_ack: isSet(object.proof_ack) ? bytesFromBase64(object.proof_ack) : new Uint8Array(0),
            proof_height: isSet(object.proof_height) ? client_1.Height.fromJSON(object.proof_height) : undefined,
            signer: isSet(object.signer) ? globalThis.String(object.signer) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.connection_id !== "") {
            obj.connection_id = message.connection_id;
        }
        if (message.proof_ack.length !== 0) {
            obj.proof_ack = base64FromBytes(message.proof_ack);
        }
        if (message.proof_height !== undefined) {
            obj.proof_height = client_1.Height.toJSON(message.proof_height);
        }
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        return obj;
    },
    create (base) {
        return exports.MsgConnectionOpenConfirm.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseMsgConnectionOpenConfirm();
        message.connection_id = (_a = object.connection_id) !== null && _a !== void 0 ? _a : "";
        message.proof_ack = (_b = object.proof_ack) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.proof_height = object.proof_height !== undefined && object.proof_height !== null ? client_1.Height.fromPartial(object.proof_height) : undefined;
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseMsgConnectionOpenConfirmResponse() {
    return {};
}
exports.MsgConnectionOpenConfirmResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirmResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgConnectionOpenConfirmResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgConnectionOpenConfirmResponse();
        return message;
    }
};
function createBaseMsgUpdateParams() {
    return {
        signer: "",
        params: undefined
    };
}
exports.MsgUpdateParams = {
    encode (message, writer = _m0.Writer.create()) {
        if (message.signer !== "") {
            writer.uint32(10).string(message.signer);
        }
        if (message.params !== undefined) {
            connection_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.params = connection_1.Params.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
            params: isSet(object.params) ? connection_1.Params.fromJSON(object.params) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        if (message.params !== undefined) {
            obj.params = connection_1.Params.toJSON(message.params);
        }
        return obj;
    },
    create (base) {
        return exports.MsgUpdateParams.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMsgUpdateParams();
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        message.params = object.params !== undefined && object.params !== null ? connection_1.Params.fromPartial(object.params) : undefined;
        return message;
    }
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    encode (_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    create (base) {
        return exports.MsgUpdateParamsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial (_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    }
};
exports.MsgServiceName = "ibc.core.connection.v1.Msg";
class MsgClientImpl {
    constructor(rpc, opts){
        this.service = (opts === null || opts === void 0 ? void 0 : opts.service) || exports.MsgServiceName;
        this.rpc = rpc;
        this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this);
        this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this);
        this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this);
        this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
        this.UpdateConnectionParams = this.UpdateConnectionParams.bind(this);
    }
    ConnectionOpenInit(request) {
        const data = exports.MsgConnectionOpenInit.encode(request).finish();
        const promise = this.rpc.request(this.service, "ConnectionOpenInit", data);
        return promise.then((data)=>exports.MsgConnectionOpenInitResponse.decode(_m0.Reader.create(data)));
    }
    ConnectionOpenTry(request) {
        const data = exports.MsgConnectionOpenTry.encode(request).finish();
        const promise = this.rpc.request(this.service, "ConnectionOpenTry", data);
        return promise.then((data)=>exports.MsgConnectionOpenTryResponse.decode(_m0.Reader.create(data)));
    }
    ConnectionOpenAck(request) {
        const data = exports.MsgConnectionOpenAck.encode(request).finish();
        const promise = this.rpc.request(this.service, "ConnectionOpenAck", data);
        return promise.then((data)=>exports.MsgConnectionOpenAckResponse.decode(_m0.Reader.create(data)));
    }
    ConnectionOpenConfirm(request) {
        const data = exports.MsgConnectionOpenConfirm.encode(request).finish();
        const promise = this.rpc.request(this.service, "ConnectionOpenConfirm", data);
        return promise.then((data)=>exports.MsgConnectionOpenConfirmResponse.decode(_m0.Reader.create(data)));
    }
    UpdateConnectionParams(request) {
        const data = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request(this.service, "UpdateConnectionParams", data);
        return promise.then((data)=>exports.MsgUpdateParamsResponse.decode(_m0.Reader.create(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    } else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i){
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    } else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=tx.js.map
}}),

};

//# sourceMappingURL=5b0a5_secretjs_dist_protobuf_ibc_3aa631._.js.map