{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///home/abubakrjimoh/Desktop/Coding%20Stuffs/hackathon/secret-network/memeAi_coin_creator/ai-meme-coin-creator/src/app/api/token/solana/%5B...cid%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { createAutoDriveApi, downloadFile } from \"@autonomys/auto-drive\";\n\nconst apiKey = process.env.AUTO_DRIVE_API_KEY;\nif (apiKey == undefined) {\n  throw new Error(\"AUTO_DRIVE_API_KEY is not set\");\n}\n\nasync function fetchFromAutoDrive(cid: string) {\n  const api = createAutoDriveApi({ apiKey, network: \"taurus\" });\n  try {\n    const stream = await downloadFile(api, cid);\n    let file = Buffer.alloc(0);\n    for await (const chunk of stream) {\n      file = Buffer.concat([file, chunk]);\n    }\n    return file;\n  } catch (error) {\n    console.error(\"Error downloading file:\", error);\n    throw new Error(\"CID not found\");\n  }\n}\n\nasync function processMetadata(cid: string): Promise<NextResponse> {\n  try {\n    const fileBuffer = await fetchFromAutoDrive(cid);\n    const jsonString = fileBuffer.toString(\"utf-8\");\n    const metadata = JSON.parse(jsonString.trim());\n\n    // Extract image CID from the URL\n    const imageCid = metadata.image.split(\"/\").pop();\n\n    // Extract only the required fields for Solana metadata format\n    const solanaMetadata = {\n      name: metadata.name,\n      symbol: metadata.symbol,\n      description: metadata.description || \"\",\n      image: `${process.env.NEXT_PUBLIC_HOST}/api/token/solana/image/${imageCid}`,\n    };\n\n    return NextResponse.json(solanaMetadata, { status: 200 });\n  } catch (error) {\n    console.error(\"Error processing metadata:\", error);\n    return NextResponse.json(\n      { error: \"Invalid metadata format\" },\n      { status: 400 }\n    );\n  }\n}\n\nasync function processImage(cid: string): Promise<NextResponse> {\n  try {\n    const fileBuffer = await fetchFromAutoDrive(cid);\n\n    return new NextResponse(fileBuffer, {\n      status: 200,\n      headers: {\n        \"Content-Type\": \"application/octet-stream\",\n        \"Content-Disposition\": `attachment; filename=\"image-${cid}\"`,\n      },\n    });\n  } catch (error) {\n    console.error(\"Error processing image:\", error);\n    return NextResponse.json(\n      { error: \"Failed to process image\" },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function GET(req: NextRequest) {\n  try {\n    const pathname = req.nextUrl.pathname;\n    const segments = pathname.split(\"/\").filter(Boolean);\n    const type = segments[segments.length - 2]; // 'image' or the CID for metadata\n    const cid = segments[segments.length - 1];\n\n    if (!cid) {\n      return NextResponse.json({ error: \"CID is required\" }, { status: 400 });\n    }\n\n    if (type === \"image\") {\n      return await processImage(cid);\n    } else {\n      return await processMetadata(cid);\n    }\n  } catch (err) {\n    console.error(\"Request failed:\", err);\n    return NextResponse.json(\n      { error: \"Failed to process request\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,kBAAkB;AAC7C,IAAI,UAAU,WAAW;IACvB,MAAM,IAAI,MAAM;AAClB;AAEA,eAAe,mBAAmB,GAAW;IAC3C,MAAM,MAAM,CAAA,GAAA,uOAAA,CAAA,qBAAkB,AAAD,EAAE;QAAE;QAAQ,SAAS;IAAS;IAC3D,IAAI;QACF,MAAM,SAAS,MAAM,CAAA,GAAA,uOAAA,CAAA,eAAY,AAAD,EAAE,KAAK;QACvC,IAAI,OAAO,OAAO,KAAK,CAAC;QACxB,WAAW,MAAM,SAAS,OAAQ;YAChC,OAAO,OAAO,MAAM,CAAC;gBAAC;gBAAM;aAAM;QACpC;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,MAAM,IAAI,MAAM;IAClB;AACF;AAEA,eAAe,gBAAgB,GAAW;IACxC,IAAI;QACF,MAAM,aAAa,MAAM,mBAAmB;QAC5C,MAAM,aAAa,WAAW,QAAQ,CAAC;QACvC,MAAM,WAAW,KAAK,KAAK,CAAC,WAAW,IAAI;QAE3C,iCAAiC;QACjC,MAAM,WAAW,SAAS,KAAK,CAAC,KAAK,CAAC,KAAK,GAAG;QAE9C,8DAA8D;QAC9D,MAAM,iBAAiB;YACrB,MAAM,SAAS,IAAI;YACnB,QAAQ,SAAS,MAAM;YACvB,aAAa,SAAS,WAAW,IAAI;YACrC,OAAO,6DAAgC,wBAAwB,EAAE,UAAU;QAC7E;QAEA,OAAO,iSAAA,CAAA,eAAY,CAAC,IAAI,CAAC,gBAAgB;YAAE,QAAQ;QAAI;IACzD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO,iSAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA0B,GACnC;YAAE,QAAQ;QAAI;IAElB;AACF;AAEA,eAAe,aAAa,GAAW;IACrC,IAAI;QACF,MAAM,aAAa,MAAM,mBAAmB;QAE5C,OAAO,IAAI,iSAAA,CAAA,eAAY,CAAC,YAAY;YAClC,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,uBAAuB,CAAC,4BAA4B,EAAE,IAAI,CAAC,CAAC;YAC9D;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,iSAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA0B,GACnC;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,IAAI,GAAgB;IACxC,IAAI;QACF,MAAM,WAAW,IAAI,OAAO,CAAC,QAAQ;QACrC,MAAM,WAAW,SAAS,KAAK,CAAC,KAAK,MAAM,CAAC;QAC5C,MAAM,OAAO,QAAQ,CAAC,SAAS,MAAM,GAAG,EAAE,EAAE,kCAAkC;QAC9E,MAAM,MAAM,QAAQ,CAAC,SAAS,MAAM,GAAG,EAAE;QAEzC,IAAI,CAAC,KAAK;YACR,OAAO,iSAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAkB,GAAG;gBAAE,QAAQ;YAAI;QACvE;QAEA,IAAI,SAAS,SAAS;YACpB,OAAO,MAAM,aAAa;QAC5B,OAAO;YACL,OAAO,MAAM,gBAAgB;QAC/B;IACF,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,mBAAmB;QACjC,OAAO,iSAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA4B,GACrC;YAAE,QAAQ;QAAI;IAElB;AACF"}},
    {"offset": {"line": 294, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}